From: Ms2ger <ms2ger@gmail.com>

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -85,17 +85,17 @@
 #include "nsContentUtils.h"
 #include "nsDOMError.h"
 #include "nsAutoPtr.h"
 #include "nsTArray.h"
 #include "prlog.h"
 #include "CSSCalc.h"
 #include "nsMediaFeatures.h"
 
-namespace css = mozilla::css;
+using namespace mozilla::css;
 
 // Flags for ParseVariant method
 #define VARIANT_KEYWORD         0x000001  // K
 #define VARIANT_LENGTH          0x000002  // L
 #define VARIANT_PERCENT         0x000004  // P
 #define VARIANT_COLOR           0x000008  // C eCSSUnit_Color, eCSSUnit_Ident (e.g.  "red")
 #define VARIANT_URL             0x000010  // U
 #define VARIANT_NUMBER          0x000020  // N
@@ -173,19 +173,19 @@ nsCSSProps::kParserVariantTable[eCSSProp
 #undef CSS_PROP
 };
 
 //----------------------------------------------------------------------
 
 namespace {
 
 // Rule processing function
-typedef void (* RuleAppendFunc) (css::Rule* aRule, void* aData);
-static void AppendRuleToArray(css::Rule* aRule, void* aArray);
-static void AppendRuleToSheet(css::Rule* aRule, void* aParser);
+typedef void (* RuleAppendFunc) (Rule* aRule, void* aData);
+static void AppendRuleToArray(Rule* aRule, void* aArray);
+static void AppendRuleToSheet(Rule* aRule, void* aParser);
 
 // Your basic top-down recursive descent style parser
 // The exposed methods and members of this class are precisely those
 // needed by nsCSSParser, far below.
 class CSSParserImpl {
 public:
   CSSParserImpl();
   ~CSSParserImpl();
@@ -193,53 +193,53 @@ public:
   nsresult SetStyleSheet(nsCSSStyleSheet* aSheet);
 
   nsresult SetQuirkMode(bool aQuirkMode);
 
 #ifdef  MOZ_SVG
   nsresult SetSVGMode(bool aSVGMode);
 #endif
 
-  nsresult SetChildLoader(mozilla::css::Loader* aChildLoader);
+  nsresult SetChildLoader(Loader* aChildLoader);
 
   // Clears everything set by the above Set*() functions.
   void Reset();
 
   nsresult Parse(nsIUnicharInputStream* aInput,
                  nsIURI*                aSheetURI,
                  nsIURI*                aBaseURI,
                  nsIPrincipal*          aSheetPrincipal,
                  uint32_t               aLineNumber,
                  bool                   aAllowUnsafeRules);
 
   nsresult ParseStyleAttribute(const nsAString&  aAttributeValue,
                                nsIURI*           aDocURL,
                                nsIURI*           aBaseURL,
                                nsIPrincipal*     aNodePrincipal,
-                               css::StyleRule**  aResult);
+                               StyleRule**       aResult);
 
   nsresult ParseDeclarations(const nsAString&  aBuffer,
                              nsIURI*           aSheetURL,
                              nsIURI*           aBaseURL,
                              nsIPrincipal*     aSheetPrincipal,
-                             css::Declaration* aDeclaration,
+                             Declaration*      aDeclaration,
                              bool*           aChanged);
 
   nsresult ParseRule(const nsAString&        aRule,
                      nsIURI*                 aSheetURL,
                      nsIURI*                 aBaseURL,
                      nsIPrincipal*           aSheetPrincipal,
-                     nsCOMArray<css::Rule>&  aResult);
+                     nsCOMArray<Rule>&       aResult);
 
   nsresult ParseProperty(const nsCSSProperty aPropID,
                          const nsAString& aPropValue,
                          nsIURI* aSheetURL,
                          nsIURI* aBaseURL,
                          nsIPrincipal* aSheetPrincipal,
-                         css::Declaration* aDeclaration,
+                         Declaration* aDeclaration,
                          bool* aChanged,
                          bool aIsImportant);
 
   nsresult ParseMediaList(const nsSubstring& aBuffer,
                           nsIURI* aURL, // for error reporting
                           uint32_t aLineNumber, // for error reporting
                           nsMediaList* aMediaList,
                           bool aHTMLMode);
@@ -265,18 +265,18 @@ public:
                                    uint32_t aLineNumber, // for error reporting
                                    nsTArray<float>& aSelectorList);
 #endif
 
 protected:
   class nsAutoParseCompoundProperty;
   friend class nsAutoParseCompoundProperty;
 
-  void AppendRule(css::Rule* aRule);
-  friend void AppendRuleToSheet(css::Rule*, void*); // calls AppendRule
+  void AppendRule(Rule* aRule);
+  friend void AppendRuleToSheet(Rule*, void*); // calls AppendRule
 
   /**
    * This helper class automatically calls SetParsingCompoundProperty in its
    * constructor and takes care of resetting it to false in its destructor.
    */
   class nsAutoParseCompoundProperty {
     public:
       nsAutoParseCompoundProperty(CSSParserImpl* aParser) : mParser(aParser)
@@ -331,17 +331,17 @@ protected:
   bool CheckEndProperty();
   nsSubstring* NextIdent();
   void SkipUntil(PRUnichar aStopSymbol);
   void SkipUntilOneOf(const PRUnichar* aStopSymbolChars);
   void SkipRuleSet(bool aInsideBraces);
   bool SkipAtRule(bool aInsideBlock);
   bool SkipDeclaration(bool aCheckForBraces);
 
-  bool PushGroup(css::GroupRule* aRule);
+  bool PushGroup(GroupRule* aRule);
   void PopGroup();
 
   bool ParseRuleSet(RuleAppendFunc aAppendFunc, void* aProcessData,
                       bool aInsideBraces = false);
   bool ParseAtRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   bool ParseCharsetRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   bool ParseImportRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   bool ParseURLOrString(nsString& aURL);
@@ -349,27 +349,27 @@ protected:
                      bool aInAtRule);
   bool ParseMediaQuery(bool aInAtRule, nsMediaQuery **aQuery,
                          bool *aParsedSomething, bool *aHitStop);
   bool ParseMediaQueryExpression(nsMediaQuery* aQuery);
   void ProcessImport(const nsString& aURLSpec,
                      nsMediaList* aMedia,
                      RuleAppendFunc aAppendFunc,
                      void* aProcessData);
-  bool ParseGroupRule(css::GroupRule* aRule, RuleAppendFunc aAppendFunc,
+  bool ParseGroupRule(GroupRule* aRule, RuleAppendFunc aAppendFunc,
                         void* aProcessData);
   bool ParseMediaRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   bool ParseMozDocumentRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   bool ParseNameSpaceRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   void ProcessNameSpace(const nsString& aPrefix,
                         const nsString& aURLSpec, RuleAppendFunc aAppendFunc,
                         void* aProcessData);
 
   bool ParseFontFaceRule(RuleAppendFunc aAppendFunc, void* aProcessData);
-  bool ParseFontDescriptor(nsCSSFontFaceRule* aRule);
+  bool ParseFontDescriptor(FontFaceRule* aRule);
   bool ParseFontDescriptorValue(nsCSSFontDesc aDescID,
                                   nsCSSValue& aValue);
 
   bool ParsePageRule(RuleAppendFunc aAppendFunc, void* aProcessData);
 #ifdef MOZ_CSS_ANIMATIONS
   bool ParseKeyframesRule(RuleAppendFunc aAppendFunc, void* aProcessData);
   already_AddRefed<nsCSSKeyframeRule> ParseKeyframeRule();
   bool ParseKeyframeSelectorList(nsTArray<float>& aSelectorList);
@@ -423,18 +423,18 @@ protected:
 
   // If aStopChar is non-zero, the selector list is done when we hit
   // aStopChar.  Otherwise, it's done when we hit EOF.
   bool ParseSelectorList(nsCSSSelectorList*& aListHead,
                            PRUnichar aStopChar);
   bool ParseSelectorGroup(nsCSSSelectorList*& aListHead);
   bool ParseSelector(nsCSSSelectorList* aList, PRUnichar aPrevCombinator);
 
-  css::Declaration* ParseDeclarationBlock(bool aCheckForBraces);
-  bool ParseDeclaration(css::Declaration* aDeclaration,
+  Declaration* ParseDeclarationBlock(bool aCheckForBraces);
+  bool ParseDeclaration(Declaration* aDeclaration,
                           bool aCheckForBraces,
                           bool aMustCallValueAppended,
                           bool* aChanged);
 
   bool ParseProperty(nsCSSProperty aPropID);
   bool ParsePropertyByFunction(nsCSSProperty aPropID);
   bool ParseSingleValueProperty(nsCSSValue& aValue,
                                   nsCSSProperty aPropID);
@@ -638,17 +638,17 @@ protected:
 
   // The principal of the sheet involved
   nsCOMPtr<nsIPrincipal> mSheetPrincipal;
 
   // The sheet we're parsing into
   nsRefPtr<nsCSSStyleSheet> mSheet;
 
   // Used for @import rules
-  mozilla::css::Loader* mChildLoader; // not ref counted, it owns us
+  Loader* mChildLoader; // not ref counted, it owns us
 
   // Sheet section we're in.  This is used to enforce correct ordering of the
   // various rule types (eg the fact that a @charset rule must come before
   // anything else).  Note that there are checks of similar things in various
   // places in nsCSSStyleSheet.cpp (e.g in insertRule, RebuildChildList).
   enum nsCSSSection {
     eCSSSection_Charset,
     eCSSSection_Import,
@@ -681,39 +681,39 @@ protected:
   // when it encounters a prefix that is not mapped to a namespace.
   bool          mFoundUnresolvablePrefix : 1;
 
 #ifdef DEBUG
   bool mScannerInited : 1;
 #endif
 
   // Stack of rule groups; used for @media and such.
-  nsTArray<nsRefPtr<css::GroupRule> > mGroupStack;
+  nsTArray< nsRefPtr<GroupRule> > mGroupStack;
 
   // During the parsing of a property (which may be a shorthand), the data
   // are stored in |mTempData|.  (It is needed to ensure that parser
   // errors cause the data to be ignored, and to ensure that a
   // non-'!important' declaration does not override an '!important'
   // one.)
   nsCSSExpandedDataBlock mTempData;
 
   // All data from successfully parsed properties are placed into |mData|.
   nsCSSExpandedDataBlock mData;
 
 public:
   // Used from nsCSSParser constructors and destructors
   CSSParserImpl* mNextFree;
 };
 
-static void AppendRuleToArray(css::Rule* aRule, void* aArray)
-{
-  static_cast<nsCOMArray<css::Rule>*>(aArray)->AppendObject(aRule);
-}
-
-static void AppendRuleToSheet(css::Rule* aRule, void* aParser)
+static void AppendRuleToArray(Rule* aRule, void* aArray)
+{
+  static_cast<nsCOMArray<Rule>*>(aArray)->AppendObject(aRule);
+}
+
+static void AppendRuleToSheet(Rule* aRule, void* aParser)
 {
   CSSParserImpl* parser = (CSSParserImpl*) aParser;
   parser->AppendRule(aRule);
 }
 
 #ifdef CSS_REPORT_PARSE_ERRORS
 
 #define REPORT_UNEXPECTED(msg_) \
@@ -812,17 +812,17 @@ CSSParserImpl::SetSVGMode(bool aSVGMod
   NS_ASSERTION(aSVGMode == true || aSVGMode == false,
                "bad bool value");
   mScanner.SetSVGMode(aSVGMode);
   return NS_OK;
 }
 #endif
 
 nsresult
-CSSParserImpl::SetChildLoader(mozilla::css::Loader* aChildLoader)
+CSSParserImpl::SetChildLoader(Loader* aChildLoader)
 {
   mChildLoader = aChildLoader;  // not ref counted, it owns us
   return NS_OK;
 }
 
 void
 CSSParserImpl::Reset()
 {
@@ -916,25 +916,25 @@ CSSParserImpl::Parse(nsIUnicharInputStre
                equal,
                "Sheet principal does not match passed principal");
 #endif
 
   InitScanner(aInput, aSheetURI, aLineNumber, aBaseURI, aSheetPrincipal);
 
   int32_t ruleCount = mSheet->StyleRuleCount();
   if (0 < ruleCount) {
-    css::Rule* lastRule = nullptr;
+    Rule* lastRule = nullptr;
     mSheet->GetStyleRuleAt(ruleCount - 1, lastRule);
     if (lastRule) {
       switch (lastRule->GetType()) {
-        case css::Rule::CHARSET_RULE:
-        case css::Rule::IMPORT_RULE:
+        case Rule::CHARSET_RULE:
+        case Rule::IMPORT_RULE:
           mSection = eCSSSection_Import;
           break;
-        case css::Rule::NAMESPACE_RULE:
+        case Rule::NAMESPACE_RULE:
           mSection = eCSSSection_NameSpace;
           break;
         default:
           mSection = eCSSSection_General;
           break;
       }
       NS_RELEASE(lastRule);
     }
@@ -985,17 +985,17 @@ NonMozillaVendorIdentifier(const nsAStri
 
 }
 
 nsresult
 CSSParserImpl::ParseStyleAttribute(const nsAString& aAttributeValue,
                                    nsIURI*          aDocURI,
                                    nsIURI*          aBaseURI,
                                    nsIPrincipal*    aNodePrincipal,
-                                   css::StyleRule** aResult)
+                                   StyleRule**      aResult)
 {
   NS_PRECONDITION(aNodePrincipal, "Must have principal here!");
   AssertInitialState();
 
   NS_ASSERTION(nullptr != aBaseURI, "need base URI");
 
   // XXX line number?
   InitScanner(aAttributeValue, aDocURI, 0, aBaseURI, aNodePrincipal);
@@ -1009,36 +1009,36 @@ CSSParserImpl::ParseStyleAttribute(const
     haveBraces = eCSSToken_Symbol == mToken.mType &&
                  '{' == mToken.mSymbol;
     UngetToken();
   }
   else {
     haveBraces = false;
   }
 
-  css::Declaration* declaration = ParseDeclarationBlock(haveBraces);
+  Declaration* declaration = ParseDeclarationBlock(haveBraces);
   if (declaration) {
     // Create a style rule for the declaration
-    NS_ADDREF(*aResult = new css::StyleRule(nullptr, declaration));
+    NS_ADDREF(*aResult = new StyleRule(nullptr, declaration));
   } else {
     *aResult = nullptr;
   }
 
   ReleaseScanner();
 
   // XXX check for low level errors
   return NS_OK;
 }
 
 nsresult
 CSSParserImpl::ParseDeclarations(const nsAString&  aBuffer,
                                  nsIURI*           aSheetURI,
                                  nsIURI*           aBaseURI,
                                  nsIPrincipal*     aSheetPrincipal,
-                                 css::Declaration* aDeclaration,
+                                 Declaration*      aDeclaration,
                                  bool*           aChanged)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   AssertInitialState();
 
   *aChanged = false;
 
   InitScanner(aBuffer, aSheetURI, 0, aBaseURI, aSheetPrincipal);
@@ -1071,17 +1071,17 @@ CSSParserImpl::ParseDeclarations(const n
   return rv;
 }
 
 nsresult
 CSSParserImpl::ParseRule(const nsAString&        aRule,
                          nsIURI*                 aSheetURI,
                          nsIURI*                 aBaseURI,
                          nsIPrincipal*           aSheetPrincipal,
-                         nsCOMArray<css::Rule>&  aResult)
+                         nsCOMArray<Rule>&       aResult)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   AssertInitialState();
 
   NS_ASSERTION(nullptr != aBaseURI, "need base URI");
 
   InitScanner(aRule, aSheetURI, 0, aBaseURI, aSheetPrincipal);
 
@@ -1106,17 +1106,17 @@ CSSParserImpl::ParseRule(const nsAString
 }
 
 nsresult
 CSSParserImpl::ParseProperty(const nsCSSProperty aPropID,
                              const nsAString& aPropValue,
                              nsIURI* aSheetURI,
                              nsIURI* aBaseURI,
                              nsIPrincipal* aSheetPrincipal,
-                             css::Declaration* aDeclaration,
+                             Declaration* aDeclaration,
                              bool* aChanged,
                              bool aIsImportant)
 {
   NS_PRECONDITION(aSheetPrincipal, "Must have principal here!");
   NS_PRECONDITION(aBaseURI, "need base URI");
   NS_PRECONDITION(aDeclaration, "Need declaration to parse into!");
   AssertInitialState();
   mData.AssertInitialState();
@@ -1206,17 +1206,17 @@ CSSParserImpl::ParseMediaList(const nsSu
 
   // For aHTMLMode, we used to follow the parsing rules in
   // http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors
   // which wouldn't work for media queries since they remove all but the
   // first word.  However, they're changed in
   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-document.html#media2
   // (as of 2008-05-29) which says that the media attribute just points
   // to a media query.  (The main substative difference is the relative
-  // precedence of commas and paretheses.)
+  // precedence of commas and parentheses.)
 
   if (!GatherMedia(aMediaList, false)) {
     aMediaList->Clear();
     aMediaList->SetNonEmpty(); // don't match anything
     if (!mHTMLMediaMode) {
       OUTPUT_ERROR();
     }
   }
@@ -1640,17 +1640,17 @@ CSSParserImpl::ParseCharsetRule(RuleAppe
   }
 
   nsAutoString charset = mToken.mIdent;
 
   if (!ExpectSymbol(';', true)) {
     return false;
   }
 
-  nsRefPtr<css::CharsetRule> rule = new css::CharsetRule(charset);
+  nsRefPtr<CharsetRule> rule = new CharsetRule(charset);
   (*aAppendFunc)(rule, aData);
 
   return true;
 }
 
 bool
 CSSParserImpl::ParseURLOrString(nsString& aURL)
 {
@@ -2005,17 +2005,17 @@ CSSParserImpl::ParseImportRule(RuleAppen
 
 
 void
 CSSParserImpl::ProcessImport(const nsString& aURLSpec,
                              nsMediaList* aMedia,
                              RuleAppendFunc aAppendFunc,
                              void* aData)
 {
-  nsRefPtr<css::ImportRule> rule = new css::ImportRule(aMedia, aURLSpec);
+  nsRefPtr<ImportRule> rule = new ImportRule(aMedia, aURLSpec);
   (*aAppendFunc)(rule, aData);
 
   // Diagnose bad URIs even if we don't have a child loader.
   nsCOMPtr<nsIURI> url;
   // Charset will be deduced from mBaseURI, which is more or less correct.
   nsresult rv = NS_NewURI(getter_AddRefs(url), aURLSpec, nullptr, mBaseURI);
 
   if (NS_FAILED(rv)) {
@@ -2032,17 +2032,17 @@ CSSParserImpl::ProcessImport(const nsStr
 
   if (mChildLoader) {
     mChildLoader->LoadChildSheet(mSheet, url, aMedia, rule);
   }
 }
 
 // Parse the {} part of an @media or @-moz-document rule.
 bool
-CSSParserImpl::ParseGroupRule(css::GroupRule* aRule,
+CSSParserImpl::ParseGroupRule(GroupRule* aRule,
                               RuleAppendFunc aAppendFunc,
                               void* aData)
 {
   // XXXbz this could use better error reporting throughout the method
   if (!ExpectSymbol('{', true)) {
     return false;
   }
 
@@ -2086,17 +2086,17 @@ CSSParserImpl::ParseGroupRule(css::Group
 // Parse a CSS2 media rule: "@media medium [, medium] { ... }"
 bool
 CSSParserImpl::ParseMediaRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   nsRefPtr<nsMediaList> media = new nsMediaList();
 
   if (GatherMedia(media, true)) {
     // XXXbz this could use better error reporting throughout the method
-    nsRefPtr<css::MediaRule> rule = new css::MediaRule();
+    nsRefPtr<MediaRule> rule = new MediaRule();
     // Append first, so when we do SetMedia() the rule
     // knows what its stylesheet is.
     if (ParseGroupRule(rule, aAppendFunc, aData)) {
       rule->SetMedia(media);
       return true;
     }
   }
 
@@ -2208,17 +2208,17 @@ CSSParserImpl::ProcessNameSpace(const ns
                                 void* aData)
 {
   nsCOMPtr<nsIAtom> prefix;
 
   if (!aPrefix.IsEmpty()) {
     prefix = do_GetAtom(aPrefix);
   }
 
-  nsRefPtr<css::NameSpaceRule> rule = new css::NameSpaceRule(prefix, aURLSpec);
+  nsRefPtr<NameSpaceRule> rule = new NameSpaceRule(prefix, aURLSpec);
   (*aAppendFunc)(rule, aData);
 
   // If this was the first namespace rule encountered, it will trigger
   // creation of a namespace map.
   if (!mNameSpaceMap) {
     mNameSpaceMap = mSheet->GetNameSpaceMap();
   }
 }
@@ -2228,21 +2228,17 @@ CSSParserImpl::ProcessNameSpace(const ns
 bool
 CSSParserImpl::ParseFontFaceRule(RuleAppendFunc aAppendFunc, void* aData)
 {
   if (!ExpectSymbol('{', true)) {
     REPORT_UNEXPECTED_TOKEN(PEBadFontBlockStart);
     return false;
   }
 
-  nsRefPtr<nsCSSFontFaceRule> rule(new nsCSSFontFaceRule());
-  if (!rule) {
-    mScanner.SetLowLevelError(NS_ERROR_OUT_OF_MEMORY);
-    return false;
-  }
+  nsRefPtr<FontFaceRule> rule = new FontFaceRule();
 
   for (;;) {
     if (!GetToken(true)) {
       REPORT_UNEXPECTED_EOF(PEFontFaceEOF);
       break;
     }
     if (mToken.IsSymbol('}')) { // done!
       UngetToken();
@@ -2276,17 +2272,17 @@ CSSParserImpl::ParseFontFaceRule(RuleApp
 //                | unicode-range-desc
 //
 // All font-*-desc productions follow the pattern
 //    IDENT ':' value ';'
 //
 // On entry to this function, mToken is the IDENT.
 
 bool
-CSSParserImpl::ParseFontDescriptor(nsCSSFontFaceRule* aRule)
+CSSParserImpl::ParseFontDescriptor(FontFaceRule* aRule)
 {
   if (eCSSToken_Ident != mToken.mType) {
     REPORT_UNEXPECTED_TOKEN(PEFontDescExpected);
     return false;
   }
 
   nsString descName = mToken.mIdent;
   if (!ExpectSymbol(':', true)) {
@@ -2376,17 +2372,17 @@ already_AddRefed<nsCSSKeyframeRule>
 CSSParserImpl::ParseKeyframeRule()
 {
   nsTArray<float> selectorList;
   if (!ParseKeyframeSelectorList(selectorList)) {
     REPORT_UNEXPECTED(PEBadSelectorKeyframeRuleIgnored);
     return nullptr;
   }
 
-  nsAutoPtr<css::Declaration> declaration(ParseDeclarationBlock(true));
+  nsAutoPtr<Declaration> declaration(ParseDeclarationBlock(true));
   if (!declaration) {
     REPORT_UNEXPECTED(PEBadSelectorKeyframeRuleIgnored);
     return nullptr;
   }
 
   // Takes ownership of declaration, and steals contents of selectorList.
   nsRefPtr<nsCSSKeyframeRule> rule =
     new nsCSSKeyframeRule(selectorList, declaration);
@@ -2558,17 +2554,17 @@ CSSParserImpl::SkipRuleSet(bool aInsid
     } else if (eCSSToken_Function == tk->mType ||
                eCSSToken_Bad_URL == tk->mType) {
       SkipUntil(')');
     }
   } 
 }
 
 bool
-CSSParserImpl::PushGroup(css::GroupRule* aRule)
+CSSParserImpl::PushGroup(GroupRule* aRule)
 {
   if (mGroupStack.AppendElement(aRule))
     return true;
 
   return false;
 }
 
 void
@@ -2576,17 +2572,17 @@ CSSParserImpl::PopGroup()
 {
   uint32_t count = mGroupStack.Length();
   if (0 < count) {
     mGroupStack.RemoveElementAt(count - 1);
   }
 }
 
 void
-CSSParserImpl::AppendRule(css::Rule* aRule)
+CSSParserImpl::AppendRule(Rule* aRule)
 {
   uint32_t count = mGroupStack.Length();
   if (0 < count) {
     mGroupStack[count - 1]->AppendStyleRule(aRule);
   }
   else {
     mSheet->AppendStyleRule(aRule);
   }
@@ -2604,32 +2600,32 @@ CSSParserImpl::ParseRuleSet(RuleAppendFu
     OUTPUT_ERROR();
     SkipRuleSet(aInsideBraces);
     return false;
   }
   NS_ASSERTION(nullptr != slist, "null selector list");
   CLEAR_ERROR();
 
   // Next parse the declaration block
-  css::Declaration* declaration = ParseDeclarationBlock(true);
+  Declaration* declaration = ParseDeclarationBlock(true);
   if (nullptr == declaration) {
     delete slist;
     return false;
   }
 
 #if 0
   slist->Dump();
   fputs("{\n", stdout);
   declaration->List();
   fputs("}\n", stdout);
 #endif
 
   // Translate the selector list and declaration block into style data
 
-  nsRefPtr<css::StyleRule> rule = new css::StyleRule(slist, declaration);
+  nsRefPtr<StyleRule> rule = new StyleRule(slist, declaration);
   rule->SetLineNumber(linenum);
   (*aAppendFunc)(rule, aData);
 
   return true;
 }
 
 bool
 CSSParserImpl::ParseSelectorList(nsCSSSelectorList*& aListHead,
@@ -3725,27 +3721,27 @@ CSSParserImpl::ParseSelector(nsCSSSelect
     selector->mLowercaseTag.swap(pseudoElement);
     selector->mClassList = pseudoElementArgs.forget();
     selector->SetPseudoType(pseudoElementType);
   }
 
   return true;
 }
 
-css::Declaration*
+Declaration*
 CSSParserImpl::ParseDeclarationBlock(bool aCheckForBraces)
 {
   if (aCheckForBraces) {
     if (!ExpectSymbol('{', true)) {
       REPORT_UNEXPECTED_TOKEN(PEBadDeclBlockStart);
       OUTPUT_ERROR();
       return nullptr;
     }
   }
-  css::Declaration* declaration = new css::Declaration();
+  Declaration* declaration = new Declaration();
   mData.AssertInitialState();
   if (declaration) {
     for (;;) {
       bool changed;
       if (!ParseDeclaration(declaration, aCheckForBraces,
                             true, &changed)) {
         if (!SkipDeclaration(aCheckForBraces)) {
           break;
@@ -4129,17 +4125,17 @@ CSSParserImpl::ParseTreePseudoElement(ns
   fakeSelector.mClassList = nullptr;
   return true;
 }
 #endif
 
 //----------------------------------------------------------------------
 
 bool
-CSSParserImpl::ParseDeclaration(css::Declaration* aDeclaration,
+CSSParserImpl::ParseDeclaration(Declaration* aDeclaration,
                                 bool aCheckForBraces,
                                 bool aMustCallValueAppended,
                                 bool* aChanged)
 {
   mTempData.AssertInitialState();
 
   // Get property name
   nsCSSToken* tk = &mToken;
@@ -6644,28 +6640,28 @@ CSSParserImpl::ParseCalcAdditiveExpressi
 
     nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(2);
     arr->Item(0) = aValue;
     storage = &arr->Item(1);
     aValue.SetArrayValue(arr, unit);
   }
 }
 
-struct ReduceNumberCalcOps : public mozilla::css::BasicFloatCalcOps,
-                             public mozilla::css::CSSValueInputCalcOps
+struct ReduceNumberCalcOps : public BasicFloatCalcOps,
+                             public CSSValueInputCalcOps
 {
   result_type ComputeLeafValue(const nsCSSValue& aValue)
   {
     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Number, "unexpected unit");
     return aValue.GetFloatValue();
   }
 
   float ComputeNumber(const nsCSSValue& aValue)
   {
-    return mozilla::css::ComputeCalc(aValue, *this);
+    return ComputeCalc(aValue, *this);
   }
 };
 
 //  * If aVariantMask is VARIANT_NUMBER, this function parses the
 //    <number-multiplicative-expression> production.
 //  * If aVariantMask does not contain VARIANT_NUMBER, this function
 //    parses the <value-multiplicative-expression> production.
 //  * Otherwise (VARIANT_NUMBER and other bits) this function parses
@@ -6701,31 +6697,31 @@ CSSParserImpl::ParseCalcMultiplicativeEx
     NS_ABORT_IF_FALSE(!(variantMask & VARIANT_NUMBER) ||
                       !(variantMask & ~int32_t(VARIANT_NUMBER)),
                       "ParseCalcTerm did not set variantMask appropriately");
 
     if (variantMask & VARIANT_NUMBER) {
       // Simplify the value immediately so we can check for division by
       // zero.
       ReduceNumberCalcOps ops;
-      float number = mozilla::css::ComputeCalc(*storage, ops);
+      float number = ComputeCalc(*storage, ops);
       if (number == 0.0 && afterDivision)
         return false;
       storage->SetFloatValue(number, eCSSUnit_Number);
     } else {
       gotValue = true;
 
       if (storage != &aValue) {
         // Simplify any numbers in the Times_L position (which are
         // not simplified by the check above).
         NS_ABORT_IF_FALSE(storage == &aValue.GetArrayValue()->Item(1),
                           "unexpected relationship to current storage");
         nsCSSValue &leftValue = aValue.GetArrayValue()->Item(0);
         ReduceNumberCalcOps ops;
-        float number = mozilla::css::ComputeCalc(leftValue, ops);
+        float number = ComputeCalc(leftValue, ops);
         leftValue.SetFloatValue(number, eCSSUnit_Number);
       }
     }
 
     bool hadWS = RequireWhitespace();
     if (!GetToken(false)) {
       *aHadFinalWS = hadWS;
       break;
@@ -8685,17 +8681,17 @@ CSSParserImpl::ParseMarker()
 #endif
 
 } // anonymous namespace
 
 // Recycling of parser implementation objects
 
 static CSSParserImpl* gFreeList = nullptr;
 
-nsCSSParser::nsCSSParser(mozilla::css::Loader* aLoader,
+nsCSSParser::nsCSSParser(Loader* aLoader,
                          nsCSSStyleSheet* aSheet)
 {
   CSSParserImpl *impl = gFreeList;
   if (impl) {
     gFreeList = impl->mNextFree;
     impl->mNextFree = nullptr;
   } else {
     impl = new CSSParserImpl();
@@ -8755,17 +8751,17 @@ nsresult
 nsCSSParser::SetSVGMode(bool aSVGMode)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     SetSVGMode(aSVGMode);
 }
 #endif
 
 nsresult
-nsCSSParser::SetChildLoader(mozilla::css::Loader* aChildLoader)
+nsCSSParser::SetChildLoader(Loader* aChildLoader)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     SetChildLoader(aChildLoader);
 }
 
 nsresult
 nsCSSParser::Parse(nsIUnicharInputStream* aInput,
                    nsIURI*                aSheetURI,
@@ -8779,54 +8775,54 @@ nsCSSParser::Parse(nsIUnicharInputStream
           aAllowUnsafeRules);
 }
 
 nsresult
 nsCSSParser::ParseStyleAttribute(const nsAString&  aAttributeValue,
                                  nsIURI*           aDocURI,
                                  nsIURI*           aBaseURI,
                                  nsIPrincipal*     aNodePrincipal,
-                                 css::StyleRule**  aResult)
+                                 StyleRule**       aResult)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseStyleAttribute(aAttributeValue, aDocURI, aBaseURI,
                         aNodePrincipal, aResult);
 }
 
 nsresult
 nsCSSParser::ParseDeclarations(const nsAString&  aBuffer,
                                nsIURI*           aSheetURI,
                                nsIURI*           aBaseURI,
                                nsIPrincipal*     aSheetPrincipal,
-                               css::Declaration* aDeclaration,
+                               Declaration*      aDeclaration,
                                bool*           aChanged)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseDeclarations(aBuffer, aSheetURI, aBaseURI, aSheetPrincipal,
                       aDeclaration, aChanged);
 }
 
 nsresult
 nsCSSParser::ParseRule(const nsAString&        aRule,
                        nsIURI*                 aSheetURI,
                        nsIURI*                 aBaseURI,
                        nsIPrincipal*           aSheetPrincipal,
-                       nsCOMArray<css::Rule>&  aResult)
+                       nsCOMArray<Rule>&       aResult)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseRule(aRule, aSheetURI, aBaseURI, aSheetPrincipal, aResult);
 }
 
 nsresult
 nsCSSParser::ParseProperty(const nsCSSProperty aPropID,
                            const nsAString&    aPropValue,
                            nsIURI*             aSheetURI,
                            nsIURI*             aBaseURI,
                            nsIPrincipal*       aSheetPrincipal,
-                           css::Declaration*   aDeclaration,
+                           Declaration*        aDeclaration,
                            bool*             aChanged,
                            bool                aIsImportant)
 {
   return static_cast<CSSParserImpl*>(mImpl)->
     ParseProperty(aPropID, aPropValue, aSheetURI, aBaseURI,
                   aSheetPrincipal, aDeclaration, aChanged, aIsImportant);
 }
 
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -109,20 +109,20 @@ static nsTArray< nsCOMPtr<nsIAtom> >* sS
 uint8_t nsCSSRuleProcessor::sWinThemeId = nsILookAndFeel::eWindowsTheme_Generic;
 #endif
 
 /**
  * A struct representing a given CSS rule and a particular selector
  * from that rule's selector list.
  */
 struct RuleSelectorPair {
-  RuleSelectorPair(css::StyleRule* aRule, nsCSSSelector* aSelector)
+  RuleSelectorPair(StyleRule* aRule, nsCSSSelector* aSelector)
     : mRule(aRule), mSelector(aSelector) {}
 
-  css::StyleRule*   mRule;
+  StyleRule*   mRule;
   nsCSSSelector*    mSelector; // which of |mRule|'s selectors
 };
 
 /**
  * A struct representing a particular rule in an ordered list of rules
  * (the ordering depending on the weight of mSelector and the order of
  * our rules to start with).
  */
@@ -588,17 +588,17 @@ void RuleHash::AppendRule(const RuleSele
 #define RULE_HASH_STAT_INCREMENT_LIST_COUNT(list_, var_) \
   (var_) += (list_).Length()
 #else
 #define RULE_HASH_STAT_INCREMENT_LIST_COUNT(list_, var_) \
   PR_BEGIN_MACRO PR_END_MACRO
 #endif
 
 static inline
-void ContentEnumFunc(css::StyleRule* aRule, nsCSSSelector* aSelector,
+void ContentEnumFunc(StyleRule* aRule, nsCSSSelector* aSelector,
                      RuleProcessorData* data, NodeMatchContext& nodeContext);
 
 void RuleHash::EnumerateAllRules(Element* aElement, RuleProcessorData* aData,
                                  NodeMatchContext& aNodeContext)
 {
   int32_t nameSpace = aElement->GetNameSpaceID();
   nsIAtom* tag = aElement->Tag();
   nsIAtom* id = aElement->GetID();
@@ -837,17 +837,17 @@ struct RuleCascadeData {
   nsTArray<nsCSSSelector*> mPossiblyNegatedClassSelectors;
   nsTArray<nsCSSSelector*> mPossiblyNegatedIDSelectors;
   PLDHashTable             mAttributeSelectors;
   PLDHashTable             mAnonBoxRules;
 #ifdef MOZ_XUL
   PLDHashTable             mXULTreeRules;
 #endif
 
-  nsTArray<nsFontFaceRuleContainer> mFontFaceRules;
+  nsTArray<FontFaceRuleContainer> mFontFaceRules;
 #ifdef MOZ_CSS_ANIMATIONS
   nsTArray<nsCSSKeyframesRule*> mKeyframesRules;
 #endif
 
   // Looks up or creates the appropriate list in |mAttributeSelectors|.
   // Returns null only on allocation failure.
   nsTArray<nsCSSSelector*>* AttributeListFor(nsIAtom* aAttribute);
 
@@ -2154,17 +2154,17 @@ static bool SelectorMatchesTree(Elemen
       }
     }
     prevElement = element;
   }
   return true; // all the selectors matched.
 }
 
 static inline
-void ContentEnumFunc(css::StyleRule* aRule, nsCSSSelector* aSelector,
+void ContentEnumFunc(StyleRule* aRule, nsCSSSelector* aSelector,
                      RuleProcessorData* data, NodeMatchContext& nodeContext)
 {
   if (nodeContext.mIsRelevantLink) {
     data->mTreeMatchContext.SetHaveRelevantLink();
   }
   if (SelectorMatches(data->mElement, aSelector, nodeContext,
                       data->mTreeMatchContext)) {
     nsCSSSelector *next = aSelector->mNext;
@@ -2461,17 +2461,17 @@ nsCSSRuleProcessor::MediumFeaturesChange
   return (old != mRuleCascades);
 }
 
 // Append all the currently-active font face rules to aArray.  Return
 // true for success and false for failure.
 bool
 nsCSSRuleProcessor::AppendFontFaceRules(
                               nsPresContext *aPresContext,
-                              nsTArray<nsFontFaceRuleContainer>& aArray)
+                              nsTArray<FontFaceRuleContainer>& aArray)
 {
   RuleCascadeData* cascade = GetRuleCascade(aPresContext);
 
   if (cascade) {
     if (!aArray.AppendElements(cascade->mFontFaceRules))
       return false;
   }
   
@@ -2767,17 +2767,17 @@ static PLDHashTableOps gRulesByWeightOps
     PL_DHashMoveEntryStub,
     ClearWeightEntry,
     PL_DHashFinalizeStub,
     InitWeightEntry
 };
 
 struct CascadeEnumData {
   CascadeEnumData(nsPresContext* aPresContext,
-                  nsTArray<nsFontFaceRuleContainer>& aFontFaceRules,
+                  nsTArray<FontFaceRuleContainer>& aFontFaceRules,
 #ifdef MOZ_CSS_ANIMATIONS
                   nsTArray<nsCSSKeyframesRule*>& aKeyframesRules,
 #endif
                   nsMediaQueryResultCacheKey& aKey,
                   PLArenaPool& aArena,
                   uint8_t aSheetType)
     : mPresContext(aPresContext),
       mFontFaceRules(aFontFaceRules),
@@ -2795,17 +2795,17 @@ struct CascadeEnumData {
 
   ~CascadeEnumData()
   {
     if (mRulesByWeight.ops)
       PL_DHashTableFinish(&mRulesByWeight);
   }
 
   nsPresContext* mPresContext;
-  nsTArray<nsFontFaceRuleContainer>& mFontFaceRules;
+  nsTArray<FontFaceRuleContainer>& mFontFaceRules;
 #ifdef MOZ_CSS_ANIMATIONS
   nsTArray<nsCSSKeyframesRule*>& mKeyframesRules;
 #endif
   nsMediaQueryResultCacheKey& mCacheKey;
   PLArenaPool& mArena;
   // Hooray, a manual PLDHashTable since nsClassHashtable doesn't
   // provide a getter that gives me a *reference* to the value.
   PLDHashTable mRulesByWeight; // of RuleValue* linked lists (?)
@@ -2817,55 +2817,55 @@ struct CascadeEnumData {
  * grouping rules) in order to:
  *  (1) add any style rules, in order, into data->mRulesByWeight (for
  *      the primary CSS cascade), where they are separated by weight
  *      but kept in order per-weight, and
  *  (2) add any @font-face rules, in order, into data->mFontFaceRules.
  *  (3) add any @keyframes rules, in order, into data->mKeyframesRules.
  */
 static bool
-CascadeRuleEnumFunc(css::Rule* aRule, void* aData)
+CascadeRuleEnumFunc(Rule* aRule, void* aData)
 {
   CascadeEnumData* data = (CascadeEnumData*)aData;
   int32_t type = aRule->GetType();
 
-  if (css::Rule::STYLE_RULE == type) {
-    css::StyleRule* styleRule = static_cast<css::StyleRule*>(aRule);
+  if (Rule::STYLE_RULE == type) {
+    StyleRule* styleRule = static_cast<StyleRule*>(aRule);
 
     for (nsCSSSelectorList *sel = styleRule->Selector();
          sel; sel = sel->mNext) {
       int32_t weight = sel->mWeight;
       RuleByWeightEntry *entry = static_cast<RuleByWeightEntry*>(
         PL_DHashTableOperate(&data->mRulesByWeight, NS_INT32_TO_PTR(weight),
                              PL_DHASH_ADD));
       if (!entry)
         return false;
       entry->data.mWeight = weight;
       // entry->data.mRules must be in forward order.
       entry->data.mRules.AppendElement(RuleSelectorPair(styleRule,
                                                         sel->mSelectors));
     }
   }
-  else if (css::Rule::MEDIA_RULE == type ||
-           css::Rule::DOCUMENT_RULE == type) {
-    css::GroupRule* groupRule = static_cast<css::GroupRule*>(aRule);
+  else if (Rule::MEDIA_RULE == type ||
+           Rule::DOCUMENT_RULE == type) {
+    GroupRule* groupRule = static_cast<GroupRule*>(aRule);
     if (groupRule->UseForPresentation(data->mPresContext, data->mCacheKey))
       if (!groupRule->EnumerateRulesForwards(CascadeRuleEnumFunc, aData))
         return false;
   }
-  else if (css::Rule::FONT_FACE_RULE == type) {
-    nsCSSFontFaceRule *fontFaceRule = static_cast<nsCSSFontFaceRule*>(aRule);
-    nsFontFaceRuleContainer *ptr = data->mFontFaceRules.AppendElement();
+  else if (Rule::FONT_FACE_RULE == type) {
+    FontFaceRule* fontFaceRule = static_cast<FontFaceRule*>(aRule);
+    FontFaceRuleContainer *ptr = data->mFontFaceRules.AppendElement();
     if (!ptr)
       return false;
     ptr->mRule = fontFaceRule;
     ptr->mSheetType = data->mSheetType;
   }
 #ifdef MOZ_CSS_ANIMATIONS
-  else if (css::Rule::KEYFRAMES_RULE == type) {
+  else if (Rule::KEYFRAMES_RULE == type) {
     nsCSSKeyframesRule *keyframesRule =
       static_cast<nsCSSKeyframesRule*>(aRule);
     if (!data->mKeyframesRules.AppendElement(keyframesRule)) {
       return false;
     }
   }
 #endif
 
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -1198,18 +1198,21 @@ NameSpaceRule::GetParentRule(nsIDOMCSSRu
 }
 
 } // namespace css
 } // namespace mozilla
 
 // Must be outside namespace
 DOMCI_DATA(CSSNameSpaceRule, css::NameSpaceRule)
 
+namespace mozilla {
+namespace css {
+
 // -------------------------------------------
-// nsCSSFontFaceStyleDecl and related routines
+// FontFaceStyleDecl and related routines
 //
 
 // A src: descriptor is represented as an array value; each entry in
 // the array can be eCSSUnit_URL, eCSSUnit_Local_Font, or
 // eCSSUnit_Font_Format.  Blocks of eCSSUnit_Font_Format may appear
 // only after one of the first two.  (css3-fonts only contemplates
 // annotating URLs with formats, but we handle the general case.)
 static void
@@ -1301,55 +1304,62 @@ AppendSerializedUnicodeRange(nsCSSValue 
       AppendSerializedUnicodePoint(max, buf);
     }
     buf.AppendLiteral(", ");
   }
   buf.Truncate(buf.Length() - 2); // remove the last comma-space
   CopyASCIItoUTF16(buf, aResult);
 }
 
-// Mapping from nsCSSFontDesc codes to nsCSSFontFaceStyleDecl fields.
+// Mapping from nsCSSFontDesc codes to FontFaceStyleDecl fields.
 // Keep this in sync with enum nsCSSFontDesc in nsCSSProperty.h.
-nsCSSValue nsCSSFontFaceStyleDecl::* const
-nsCSSFontFaceStyleDecl::Fields[] = {
-    &nsCSSFontFaceStyleDecl::mFamily,
-    &nsCSSFontFaceStyleDecl::mStyle,
-    &nsCSSFontFaceStyleDecl::mWeight,
-    &nsCSSFontFaceStyleDecl::mStretch,
-    &nsCSSFontFaceStyleDecl::mSrc,
-    &nsCSSFontFaceStyleDecl::mUnicodeRange,
-    &nsCSSFontFaceStyleDecl::mFontFeatureSettings,
-    &nsCSSFontFaceStyleDecl::mFontLanguageOverride
+nsCSSValue FontFaceStyleDecl::* const
+FontFaceStyleDecl::Fields[] = {
+    &FontFaceStyleDecl::mFamily,
+    &FontFaceStyleDecl::mStyle,
+    &FontFaceStyleDecl::mWeight,
+    &FontFaceStyleDecl::mStretch,
+    &FontFaceStyleDecl::mSrc,
+    &FontFaceStyleDecl::mUnicodeRange,
+    &FontFaceStyleDecl::mFontFeatureSettings,
+    &FontFaceStyleDecl::mFontLanguageOverride
 };
 
-DOMCI_DATA(CSSFontFaceStyleDecl, nsCSSFontFaceStyleDecl)
+} // namespace css
+} // namespace mozilla
 
-// QueryInterface implementation for nsCSSFontFaceStyleDecl
-NS_INTERFACE_MAP_BEGIN(nsCSSFontFaceStyleDecl)
+// Must be outside namespace
+DOMCI_DATA(CSSFontFaceStyleDecl, css::FontFaceStyleDecl)
+
+namespace mozilla {
+namespace css {
+
+// QueryInterface implementation for FontFaceStyleDecl
+NS_INTERFACE_MAP_BEGIN(FontFaceStyleDecl)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSStyleDeclaration)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSFontFaceStyleDecl)
 NS_INTERFACE_MAP_END
 
-NS_IMPL_ADDREF_USING_AGGREGATOR(nsCSSFontFaceStyleDecl, ContainingRule())
-NS_IMPL_RELEASE_USING_AGGREGATOR(nsCSSFontFaceStyleDecl, ContainingRule())
+NS_IMPL_ADDREF_USING_AGGREGATOR(FontFaceStyleDecl, ContainingRule())
+NS_IMPL_RELEASE_USING_AGGREGATOR(FontFaceStyleDecl, ContainingRule())
 
 // helper for string GetPropertyValue and RemovePropertyValue
 nsresult
-nsCSSFontFaceStyleDecl::GetPropertyValue(nsCSSFontDesc aFontDescID,
-                                         nsAString & aResult NS_OUTPARAM) const
+FontFaceStyleDecl::GetPropertyValue(nsCSSFontDesc aFontDescID,
+                                    nsAString& aResult NS_OUTPARAM) const
 {
   NS_ENSURE_ARG_RANGE(aFontDescID, eCSSFontDesc_UNKNOWN,
                       eCSSFontDesc_COUNT - 1);
 
   aResult.Truncate();
   if (aFontDescID == eCSSFontDesc_UNKNOWN)
     return NS_OK;
 
-  const nsCSSValue& val = this->*nsCSSFontFaceStyleDecl::Fields[aFontDescID];
+  const nsCSSValue& val = this->*FontFaceStyleDecl::Fields[aFontDescID];
 
   if (val.GetUnit() == eCSSUnit_Null) {
     // Avoid having to check no-value in the Family and Src cases below.
     return NS_OK;
   }
 
   switch (aFontDescID) {
   case eCSSFontDesc_Family: {
@@ -1389,286 +1399,296 @@ nsCSSFontFaceStyleDecl::GetPropertyValue
   case eCSSFontDesc_UnicodeRange:
     AppendSerializedUnicodeRange(val, aResult);
     return NS_OK;
 
   case eCSSFontDesc_UNKNOWN:
   case eCSSFontDesc_COUNT:
     ;
   }
-  NS_NOTREACHED("nsCSSFontFaceStyleDecl::GetPropertyValue: "
+  NS_NOTREACHED("css::FontFaceStyleDecl::GetPropertyValue: "
                 "out-of-range value got to the switch");
   return NS_ERROR_INVALID_ARG;
 }
 
 
 // attribute DOMString cssText;
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::GetCssText(nsAString & aCssText)
+FontFaceStyleDecl::GetCssText(nsAString& aCssText)
 {
   nsAutoString descStr;
 
   aCssText.Truncate();
   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
        id < eCSSFontDesc_COUNT;
        id = nsCSSFontDesc(id + 1)) {
-    if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
+    if ((this->*FontFaceStyleDecl::Fields[id]).GetUnit()
           != eCSSUnit_Null &&
         NS_SUCCEEDED(GetPropertyValue(id, descStr))) {
       NS_ASSERTION(descStr.Length() > 0,
                    "GetCssText: non-null unit, empty property value");
       aCssText.AppendLiteral("  ");
       aCssText.AppendASCII(nsCSSProps::GetStringValue(id).get());
       aCssText.AppendLiteral(": ");
       aCssText.Append(descStr);
       aCssText.AppendLiteral(";\n");
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::SetCssText(const nsAString & aCssText)
+FontFaceStyleDecl::SetCssText(const nsAString& aCssText)
 {
   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
 }
 
 // DOMString getPropertyValue (in DOMString propertyName);
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::GetPropertyValue(const nsAString & propertyName,
-                                         nsAString & aResult NS_OUTPARAM)
+FontFaceStyleDecl::GetPropertyValue(const nsAString& propertyName,
+                                    nsAString& aResult NS_OUTPARAM)
 {
   return GetPropertyValue(nsCSSProps::LookupFontDesc(propertyName), aResult);
 }
 
 // nsIDOMCSSValue getPropertyCSSValue (in DOMString propertyName);
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::GetPropertyCSSValue(const nsAString & propertyName,
-                                            nsIDOMCSSValue **aResult NS_OUTPARAM)
+FontFaceStyleDecl::GetPropertyCSSValue(const nsAString& propertyName,
+                                       nsIDOMCSSValue** aResult NS_OUTPARAM)
 {
   // ??? nsDOMCSSDeclaration returns null/NS_OK, but that seems wrong.
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 // DOMString removeProperty (in DOMString propertyName) raises (DOMException);
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::RemoveProperty(const nsAString & propertyName,
-                                       nsAString & aResult NS_OUTPARAM)
+FontFaceStyleDecl::RemoveProperty(const nsAString& propertyName,
+                                  nsAString& aResult NS_OUTPARAM)
 {
   nsCSSFontDesc descID = nsCSSProps::LookupFontDesc(propertyName);
   NS_ASSERTION(descID >= eCSSFontDesc_UNKNOWN &&
                descID < eCSSFontDesc_COUNT,
                "LookupFontDesc returned value out of range");
 
   if (descID == eCSSFontDesc_UNKNOWN) {
     aResult.Truncate();
   } else {
     nsresult rv = GetPropertyValue(descID, aResult);
     NS_ENSURE_SUCCESS(rv, rv);
-    (this->*nsCSSFontFaceStyleDecl::Fields[descID]).Reset();
+    (this->*FontFaceStyleDecl::Fields[descID]).Reset();
   }
   return NS_OK;
 }
 
 // DOMString getPropertyPriority (in DOMString propertyName);
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::GetPropertyPriority(const nsAString & propertyName,
-                                            nsAString & aResult NS_OUTPARAM)
+FontFaceStyleDecl::GetPropertyPriority(const nsAString& propertyName,
+                                       nsAString& aResult NS_OUTPARAM)
 {
   // font descriptors do not have priorities at present
   aResult.Truncate();
   return NS_OK;
 }
 
 // void setProperty (in DOMString propertyName, in DOMString value,
 //                   in DOMString priority)  raises (DOMException);
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::SetProperty(const nsAString & propertyName,
-                                    const nsAString & value,
-                                    const nsAString & priority)
+FontFaceStyleDecl::SetProperty(const nsAString& propertyName,
+                               const nsAString& value,
+                               const nsAString& priority)
 {
   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
 }
 
 // readonly attribute unsigned long length;
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::GetLength(uint32_t *aLength)
+FontFaceStyleDecl::GetLength(uint32_t* aLength)
 {
   uint32_t len = 0;
   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
        id < eCSSFontDesc_COUNT;
        id = nsCSSFontDesc(id + 1))
-    if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit() != eCSSUnit_Null)
+    if ((this->*FontFaceStyleDecl::Fields[id]).GetUnit() != eCSSUnit_Null)
       len++;
 
   *aLength = len;
   return NS_OK;
 }
 
 // DOMString item (in unsigned long index);
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::Item(uint32_t index, nsAString & aResult NS_OUTPARAM)
- {
+FontFaceStyleDecl::Item(uint32_t index, nsAString& aResult NS_OUTPARAM)
+{
   int32_t nset = -1;
   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
        id < eCSSFontDesc_COUNT;
        id = nsCSSFontDesc(id + 1)) {
-    if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
+    if ((this->*FontFaceStyleDecl::Fields[id]).GetUnit()
         != eCSSUnit_Null) {
       nset++;
       if (nset == int32_t(index)) {
         aResult.AssignASCII(nsCSSProps::GetStringValue(id).get());
         return NS_OK;
       }
     }
   }
   aResult.Truncate();
   return NS_OK;
 }
 
 // readonly attribute nsIDOMCSSRule parentRule;
 NS_IMETHODIMP
-nsCSSFontFaceStyleDecl::GetParentRule(nsIDOMCSSRule** aParentRule)
+FontFaceStyleDecl::GetParentRule(nsIDOMCSSRule** aParentRule)
 {
    NS_IF_ADDREF(*aParentRule = ContainingRule()->GetDOMRule());
    return NS_OK;
 }
 
 
 // -------------------------------------------
-// nsCSSFontFaceRule
+// FontFaceRule
 // 
 
 /* virtual */ already_AddRefed<css::Rule>
-nsCSSFontFaceRule::Clone() const
+FontFaceRule::Clone() const
 {
-  nsRefPtr<css::Rule> clone = new nsCSSFontFaceRule(*this);
+  nsRefPtr<css::Rule> clone = new FontFaceRule(*this);
   return clone.forget();
 }
 
-NS_IMPL_ADDREF_INHERITED(nsCSSFontFaceRule, css::Rule)
-NS_IMPL_RELEASE_INHERITED(nsCSSFontFaceRule, css::Rule)
+NS_IMPL_ADDREF_INHERITED(FontFaceRule, Rule)
+NS_IMPL_RELEASE_INHERITED(FontFaceRule, Rule)
 
-DOMCI_DATA(CSSFontFaceRule, nsCSSFontFaceRule)
+} // namespace css
+} // namespace mozilla
 
-// QueryInterface implementation for nsCSSFontFaceRule
-NS_INTERFACE_MAP_BEGIN(nsCSSFontFaceRule)
+// Must be outside namespace
+DOMCI_DATA(CSSFontFaceRule, css::FontFaceRule)
+
+namespace mozilla {
+namespace css {
+
+// QueryInterface implementation for FontFaceRule
+NS_INTERFACE_MAP_BEGIN(FontFaceRule)
   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSFontFaceRule)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSFontFaceRule)
 NS_INTERFACE_MAP_END
 
-IMPL_STYLE_RULE_INHERIT(nsCSSFontFaceRule, Rule)
+IMPL_STYLE_RULE_INHERIT(FontFaceRule, Rule)
 
 #ifdef DEBUG
 void
-nsCSSFontFaceRule::List(FILE* out, int32_t aIndent) const
+FontFaceRule::List(FILE* out, int32_t aIndent) const
 {
   nsCString baseInd, descInd;
   for (int32_t indent = aIndent; --indent >= 0; ) {
     baseInd.AppendLiteral("  ");
     descInd.AppendLiteral("  ");
   }
   descInd.AppendLiteral("  ");
 
   nsString descStr;
 
   fprintf(out, "%s@font-face {\n", baseInd.get());
   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
        id < eCSSFontDesc_COUNT;
        id = nsCSSFontDesc(id + 1))
-    if ((mDecl.*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
+    if ((mDecl.*FontFaceStyleDecl::Fields[id]).GetUnit()
         != eCSSUnit_Null) {
       if (NS_FAILED(mDecl.GetPropertyValue(id, descStr)))
         descStr.AssignLiteral("#<serialization error>");
       else if (descStr.Length() == 0)
         descStr.AssignLiteral("#<serialization missing>");
       fprintf(out, "%s%s: %s\n",
               descInd.get(), nsCSSProps::GetStringValue(id).get(),
               NS_ConvertUTF16toUTF8(descStr).get());
     }
   fprintf(out, "%s}\n", baseInd.get());
 }
 #endif
 
 /* virtual */ int32_t
-nsCSSFontFaceRule::GetType() const
+FontFaceRule::GetType() const
 {
   return css::Rule::FONT_FACE_RULE;
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceRule::GetType(uint16_t* aType)
+FontFaceRule::GetType(uint16_t* aType)
 {
   *aType = nsIDOMCSSRule::FONT_FACE_RULE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceRule::GetCssText(nsAString& aCssText)
+FontFaceRule::GetCssText(nsAString& aCssText)
 {
   nsAutoString propText;
   mDecl.GetCssText(propText);
 
   aCssText.AssignLiteral("@font-face {\n");
   aCssText.Append(propText);
   aCssText.Append('}');
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceRule::SetCssText(const nsAString& aCssText)
+FontFaceRule::SetCssText(const nsAString& aCssText)
 {
   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
+FontFaceRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
 {
   return Rule::GetParentStyleSheet(aSheet);
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceRule::GetParentRule(nsIDOMCSSRule** aParentRule)
+FontFaceRule::GetParentRule(nsIDOMCSSRule** aParentRule)
 {
   return Rule::GetParentRule(aParentRule);
 }
 
 NS_IMETHODIMP
-nsCSSFontFaceRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
+FontFaceRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
 {
   NS_IF_ADDREF(*aStyle = &mDecl);
   return NS_OK;
 }
 
-// Arguably these should forward to nsCSSFontFaceStyleDecl methods.
+// Arguably these should forward to FontFaceStyleDecl methods.
 void
-nsCSSFontFaceRule::SetDesc(nsCSSFontDesc aDescID, nsCSSValue const & aValue)
+FontFaceRule::SetDesc(nsCSSFontDesc aDescID, nsCSSValue const& aValue)
 {
   NS_PRECONDITION(aDescID > eCSSFontDesc_UNKNOWN &&
                   aDescID < eCSSFontDesc_COUNT,
-                  "aDescID out of range in nsCSSFontFaceRule::SetDesc");
+                  "aDescID out of range in FontFaceRule::SetDesc");
 
   // FIXME: handle dynamic changes
 
-  mDecl.*nsCSSFontFaceStyleDecl::Fields[aDescID] = aValue;
+  mDecl.*FontFaceStyleDecl::Fields[aDescID] = aValue;
 }
 
 void
-nsCSSFontFaceRule::GetDesc(nsCSSFontDesc aDescID, nsCSSValue & aValue)
+FontFaceRule::GetDesc(nsCSSFontDesc aDescID, nsCSSValue& aValue)
 {
   NS_PRECONDITION(aDescID > eCSSFontDesc_UNKNOWN &&
                   aDescID < eCSSFontDesc_COUNT,
-                  "aDescID out of range in nsCSSFontFaceRule::GetDesc");
+                  "aDescID out of range in FontFaceRule::GetDesc");
 
-  aValue = mDecl.*nsCSSFontFaceStyleDecl::Fields[aDescID];
+  aValue = mDecl.*FontFaceStyleDecl::Fields[aDescID];
 }
 
+} // namespace css
+} // namespace mozilla
+
 #ifdef MOZ_CSS_ANIMATIONS
 // -------------------------------------------
 // nsCSSKeyframeStyleDeclaration
 //
 
 nsCSSKeyframeStyleDeclaration::nsCSSKeyframeStyleDeclaration(nsCSSKeyframeRule *aRule)
   : mRule(aRule)
 {
diff --git a/layout/style/nsCSSRules.h b/layout/style/nsCSSRules.h
--- a/layout/style/nsCSSRules.h
+++ b/layout/style/nsCSSRules.h
@@ -173,113 +173,107 @@ public:
   };
 
   void SetURLs(URL *aURLs) { mURLs = aURLs; }
 
 protected:
   nsAutoPtr<URL> mURLs; // linked list of |struct URL| above.
 };
 
-} // namespace css
-} // namespace mozilla
-
-// A nsCSSFontFaceStyleDecl is always embedded in a nsCSSFontFaceRule.
-class nsCSSFontFaceRule;
-class nsCSSFontFaceStyleDecl : public nsIDOMCSSStyleDeclaration
+// A FontFaceStyleDecl is always embedded in a nsCSSFontFaceRule.
+class FontFaceRule;
+class FontFaceStyleDecl : public nsIDOMCSSStyleDeclaration
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDOMCSSSTYLEDECLARATION
 
   nsresult GetPropertyValue(nsCSSFontDesc aFontDescID,
                             nsAString & aResult NS_OUTPARAM) const;
 
 protected:
-  friend class nsCSSFontFaceRule;
+  friend class FontFaceRule;
   nsCSSValue mFamily;
   nsCSSValue mStyle;
   nsCSSValue mWeight;
   nsCSSValue mStretch;
   nsCSSValue mSrc;
   nsCSSValue mUnicodeRange;
   nsCSSValue mFontFeatureSettings;
   nsCSSValue mFontLanguageOverride;
 
-  static nsCSSValue nsCSSFontFaceStyleDecl::* const Fields[];  
-  inline nsCSSFontFaceRule* ContainingRule();
-  inline const nsCSSFontFaceRule* ContainingRule() const;
+  static nsCSSValue FontFaceStyleDecl::* const Fields[];  
+  inline FontFaceRule* ContainingRule();
+  inline const FontFaceRule* ContainingRule() const;
 
 private:
   // NOT TO BE IMPLEMENTED
   // This object cannot be allocated on its own, only as part of
-  // nsCSSFontFaceRule.
+  // FontFaceRule.
   void* operator new(size_t size) CPP_THROW_NEW;
 };
 
-class NS_FINAL_CLASS nsCSSFontFaceRule : public mozilla::css::Rule,
-                                         public nsIDOMCSSFontFaceRule
+class NS_FINAL_CLASS FontFaceRule : public Rule,
+                                    public nsIDOMCSSFontFaceRule
 {
 public:
-  nsCSSFontFaceRule() {}
+  FontFaceRule() {}
 
-  nsCSSFontFaceRule(const nsCSSFontFaceRule& aCopy)
+  FontFaceRule(const FontFaceRule& aCopy)
     // copy everything except our reference count
-    : mozilla::css::Rule(aCopy), mDecl(aCopy.mDecl) {}
+    : Rule(aCopy), mDecl(aCopy.mDecl) {}
 
   NS_DECL_ISUPPORTS_INHERITED
 
   // nsIStyleRule methods
 #ifdef DEBUG
   virtual void List(FILE* out = stdout, int32_t aIndent = 0) const;
 #endif
 
   // Rule methods
   DECL_STYLE_RULE_INHERIT
 
   virtual int32_t GetType() const;
-  virtual already_AddRefed<mozilla::css::Rule> Clone() const;
+  virtual already_AddRefed<Rule> Clone() const;
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMCSSFontFaceRule interface
   NS_DECL_NSIDOMCSSFONTFACERULE
 
   void SetDesc(nsCSSFontDesc aDescID, nsCSSValue const & aValue);
   void GetDesc(nsCSSFontDesc aDescID, nsCSSValue & aValue);
 
 protected:
-  friend class nsCSSFontFaceStyleDecl;
-  nsCSSFontFaceStyleDecl mDecl;
+  friend class FontFaceStyleDecl;
+  FontFaceStyleDecl mDecl;
 };
 
-// nsFontFaceRuleContainer - used for associating sheet type with 
+// FontFaceRuleContainer - used for associating sheet type with 
 // specific @font-face rules
-struct nsFontFaceRuleContainer {
+struct FontFaceRuleContainer {
   nsRefPtr<nsCSSFontFaceRule> mRule;
   uint8_t mSheetType;
 };
 
-inline nsCSSFontFaceRule*
-nsCSSFontFaceStyleDecl::ContainingRule()
+inline FontFaceRule*
+FontFaceStyleDecl::ContainingRule()
 {
   return reinterpret_cast<nsCSSFontFaceRule*>
     (reinterpret_cast<char*>(this) - offsetof(nsCSSFontFaceRule, mDecl));
 }
 
-inline const nsCSSFontFaceRule*
-nsCSSFontFaceStyleDecl::ContainingRule() const
+inline const FontFaceRule*
+FontFaceStyleDecl::ContainingRule() const
 {
-  return reinterpret_cast<const nsCSSFontFaceRule*>
-    (reinterpret_cast<const char*>(this) - offsetof(nsCSSFontFaceRule, mDecl));
+  return reinterpret_cast<const FontFaceRule*>
+    (reinterpret_cast<const char*>(this) - offsetof(FontFaceRule, mDecl));
 }
 
-namespace mozilla {
-namespace css {
-
 class NS_FINAL_CLASS CharsetRule : public Rule,
                                    public nsIDOMCSSCharsetRule
 {
 public:
   CharsetRule(const nsAString& aEncoding);
 private:
   // For |Clone|
   CharsetRule(const CharsetRule& aCopy);
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -77,16 +77,17 @@
 
 #ifdef PR_LOGGING
 static PRLogModuleInfo *gFontDownloaderLog = PR_NewLogModule("fontdownloader");
 #endif /* PR_LOGGING */
 
 #define LOG(args) PR_LOG(gFontDownloaderLog, PR_LOG_DEBUG, args)
 #define LOG_ENABLED() PR_LOG_TEST(gFontDownloaderLog, PR_LOG_DEBUG)
 
+using namespace mozilla::css;
 
 nsFontFaceLoader::nsFontFaceLoader(gfxProxyFontEntry *aProxy, nsIURI *aFontURI,
                                    nsUserFontSet *aFontSet, nsIChannel *aChannel)
   : mFontEntry(aProxy), mFontURI(aFontURI), mFontSet(aFontSet),
     mChannel(aChannel)
 {
 }
 
@@ -429,17 +430,17 @@ nsUserFontSet::StartLoad(gfxProxyFontEnt
     mLoaders.PutEntry(fontLoader);
     fontLoader->StartedLoading(streamLoader);
   }
 
   return rv;
 }
 
 bool
-nsUserFontSet::UpdateRules(const nsTArray<nsFontFaceRuleContainer>& aRules)
+nsUserFontSet::UpdateRules(const nsTArray<FontFaceRuleContainer>& aRules)
 {
   bool modified = false;
 
   // destroy any current loaders, as the entries they refer to
   // may be about to get replaced
   if (mLoaders.Count() > 0) {
     modified = true; // trigger reflow so that any necessary downloads
                         // will be reinitiated
@@ -469,17 +470,17 @@ nsUserFontSet::UpdateRules(const nsTArra
   if (modified) {
     IncrementGeneration();
   }
 
   return modified;
 }
 
 void
-nsUserFontSet::InsertRule(nsCSSFontFaceRule *aRule, uint8_t aSheetType,
+nsUserFontSet::InsertRule(FontFaceRule* aRule, uint8_t aSheetType,
                           nsTArray<FontFaceRuleRecord>& aOldRules,
                           bool& aFontSetModified)
 {
   NS_ABORT_IF_FALSE(aRule->GetType() == mozilla::css::Rule::FONT_FACE_RULE,
                     "InsertRule passed a non-fontface CSS rule");
 
   // set up family name
   nsAutoString fontfamily;
diff --git a/layout/style/nsFontFaceLoader.h b/layout/style/nsFontFaceLoader.h
--- a/layout/style/nsFontFaceLoader.h
+++ b/layout/style/nsFontFaceLoader.h
@@ -53,17 +53,22 @@
 #include "nsCSSRules.h"
 
 class nsIRequest;
 class nsISupports;
 class nsPresContext;
 class nsIPrincipal;
 
 class nsFontFaceLoader;
-class nsCSSFontFaceRule;
+
+namespace mozilla {
+namespace css {
+class FontFaceRule;
+} // namespace css
+} // namespace mozilla
 
 // nsUserFontSet - defines the loading mechanism for downloadable fonts
 class nsUserFontSet : public gfxUserFontSet
 {
 public:
   nsUserFontSet(nsPresContext *aContext);
   ~nsUserFontSet();
 
@@ -74,34 +79,34 @@ public:
   // returns whether load process successfully started or not
   nsresult StartLoad(gfxProxyFontEntry *aFontToLoad, 
                      const gfxFontFaceSrc *aFontFaceSrc);
 
   // Called by nsFontFaceLoader when the loader has completed normally.
   // It's removed from the mLoaders set.
   void RemoveLoader(nsFontFaceLoader *aLoader);
 
-  bool UpdateRules(const nsTArray<nsFontFaceRuleContainer>& aRules);
+  bool UpdateRules(const nsTArray<mozilla::css::FontFaceRuleContainer>& aRules);
 
   nsPresContext *GetPresContext() { return mPresContext; }
 
   virtual void ReplaceFontEntry(gfxProxyFontEntry *aProxy,
                                 gfxFontEntry *aFontEntry);
 
 protected:
   // The font-set keeps track of the collection of rules, and their
   // corresponding font entries (whether proxies or real entries),
   // so that we can update the set without having to throw away
   // all the existing fonts.
   struct FontFaceRuleRecord {
-    nsRefPtr<gfxFontEntry>       mFontEntry;
-    nsFontFaceRuleContainer      mContainer;
+    nsRefPtr<gfxFontEntry> mFontEntry;
+    mozilla::css::FontFaceRuleContainer mContainer;
   };
 
-  void InsertRule(nsCSSFontFaceRule *aRule, uint8_t aSheetType,
+  void InsertRule(mozilla::css::FontFaceRule* aRule, uint8_t aSheetType,
                   nsTArray<FontFaceRuleRecord>& oldRules,
                   bool& aFontSetModified);
 
   nsPresContext *mPresContext;  // weak reference
 
   // Set of all loaders pointing to us. These are not strong pointers,
   // but that's OK because nsFontFaceLoader always calls RemoveLoader on
   // us before it dies (unless we die first).
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -54,24 +54,30 @@
 #include "nsTArray.h"
 #include "nsCOMArray.h"
 #include "nsAutoPtr.h"
 #include "nsIStyleRule.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCSSAnonBoxes.h"
 
 class nsIURI;
-class nsCSSFontFaceRule;
 #ifdef MOZ_CSS_ANIMATIONS
 class nsCSSKeyframesRule;
 #endif
 class nsRuleWalker;
 struct RuleProcessorData;
 struct TreeMatchContext;
 
+namespace mozilla {
+namespace css {
+class FontFaceRule;
+} // namespace css
+} // namespace mozilla
+
+
 class nsEmptyStyleRule : public nsIStyleRule
 {
   NS_DECL_ISUPPORTS
   virtual void MapRuleInfoInto(nsRuleData* aRuleData);
 #ifdef DEBUG
   virtual void List(FILE* out = stdout, int32_t aIndent = 0) const;
 #endif
 };
@@ -167,17 +173,17 @@ class nsStyleSet
                             nsIAtom* aPseudoTag,
                             nsStyleContext* aParentContext,
                             nsICSSPseudoComparator* aComparator);
 #endif
 
   // Append all the currently-active font face rules to aArray.  Return
   // true for success and false for failure.
   bool AppendFontFaceRules(nsPresContext* aPresContext,
-                             nsTArray<nsFontFaceRuleContainer>& aArray);
+                             nsTArray<mozilla::css::FontFaceRuleContainer>& aArray);
 
 #ifdef MOZ_CSS_ANIMATIONS
   // Append all the currently-active keyframes rules to aArray.  Return
   // true for success and false for failure.
   bool AppendKeyframesRules(nsPresContext* aPresContext,
                               nsTArray<nsCSSKeyframesRule*>& aArray);
 #endif
 
