From: Ms2ger <ms2ger@gmail.com>

diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -78,75 +78,73 @@
 #include "mozilla/Preferences.h"
 #include "private/pprio.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 // Maximum size that we'll grow an ArrayBuffer instead of doubling,
 // once doubling reaches this threshold
-#define XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH (32*1024*1024)
+#define XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH (32 * 1024 * 1024)
 // start at 32k to avoid lots of doubling right at the start
-#define XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE (32*1024)
+#define XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE (32 * 1024)
 // the maximum Content-Length that we'll preallocate.  1GB.  Must fit
 // in an int32_t!
-#define XML_HTTP_REQUEST_MAX_CONTENT_LENGTH_PREALLOCATE (1*1024*1024*1024LL)
+#define XML_HTTP_REQUEST_MAX_CONTENT_LENGTH_PREALLOCATE                        \
+  (1 * 1024 * 1024 * 1024LL)
 
 #define LOAD_STR "load"
 #define ERROR_STR "error"
 #define ABORT_STR "abort"
 #define TIMEOUT_STR "timeout"
 #define LOADSTART_STR "loadstart"
 #define PROGRESS_STR "progress"
 #define READYSTATE_STR "readystatechange"
 #define LOADEND_STR "loadend"
 
 // CIDs
 
 // State
-#define XML_HTTP_REQUEST_UNSENT           (1 << 0) // 0 UNSENT
-#define XML_HTTP_REQUEST_OPENED           (1 << 1) // 1 OPENED
+#define XML_HTTP_REQUEST_UNSENT (1 << 0)           // 0 UNSENT
+#define XML_HTTP_REQUEST_OPENED (1 << 1)           // 1 OPENED
 #define XML_HTTP_REQUEST_HEADERS_RECEIVED (1 << 2) // 2 HEADERS_RECEIVED
-#define XML_HTTP_REQUEST_LOADING          (1 << 3) // 3 LOADING
-#define XML_HTTP_REQUEST_DONE             (1 << 4) // 4 DONE
-#define XML_HTTP_REQUEST_SENT             (1 << 5) // Internal, OPENED in IE and external view
+#define XML_HTTP_REQUEST_LOADING (1 << 3)          // 3 LOADING
+#define XML_HTTP_REQUEST_DONE (1 << 4)             // 4 DONE
+#define XML_HTTP_REQUEST_SENT                                                  \
+  (1 << 5) // Internal, OPENED in IE and external view
 // The above states are mutually exclusive, change with ChangeState() only.
 // The states below can be combined.
-#define XML_HTTP_REQUEST_ABORTED        (1 << 7)  // Internal
-#define XML_HTTP_REQUEST_ASYNC          (1 << 8)  // Internal
-#define XML_HTTP_REQUEST_PARSEBODY      (1 << 9)  // Internal
-#define XML_HTTP_REQUEST_SYNCLOOPING    (1 << 10) // Internal
-#define XML_HTTP_REQUEST_BACKGROUND     (1 << 13) // Internal
-#define XML_HTTP_REQUEST_USE_XSITE_AC   (1 << 14) // Internal
-#define XML_HTTP_REQUEST_NEED_AC_PREFLIGHT (1 << 15) // Internal
+#define XML_HTTP_REQUEST_ABORTED (1 << 7)              // Internal
+#define XML_HTTP_REQUEST_ASYNC (1 << 8)                // Internal
+#define XML_HTTP_REQUEST_PARSEBODY (1 << 9)            // Internal
+#define XML_HTTP_REQUEST_SYNCLOOPING (1 << 10)         // Internal
+#define XML_HTTP_REQUEST_BACKGROUND (1 << 13)          // Internal
+#define XML_HTTP_REQUEST_USE_XSITE_AC (1 << 14)        // Internal
+#define XML_HTTP_REQUEST_NEED_AC_PREFLIGHT (1 << 15)   // Internal
 #define XML_HTTP_REQUEST_AC_WITH_CREDENTIALS (1 << 16) // Internal
-#define XML_HTTP_REQUEST_TIMED_OUT (1 << 17) // Internal
-#define XML_HTTP_REQUEST_DELETED (1 << 18) // Internal
-
-#define XML_HTTP_REQUEST_LOADSTATES         \
-  (XML_HTTP_REQUEST_UNSENT |                \
-   XML_HTTP_REQUEST_OPENED |                \
-   XML_HTTP_REQUEST_HEADERS_RECEIVED |      \
-   XML_HTTP_REQUEST_LOADING |               \
-   XML_HTTP_REQUEST_DONE |                  \
-   XML_HTTP_REQUEST_SENT)
-
-#define NS_BADCERTHANDLER_CONTRACTID \
+#define XML_HTTP_REQUEST_TIMED_OUT (1 << 17)           // Internal
+#define XML_HTTP_REQUEST_DELETED (1 << 18)             // Internal
+
+#define XML_HTTP_REQUEST_LOADSTATES                                            \
+  (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_OPENED |                         \
+   XML_HTTP_REQUEST_HEADERS_RECEIVED | XML_HTTP_REQUEST_LOADING |              \
+   XML_HTTP_REQUEST_DONE | XML_HTTP_REQUEST_SENT)
+
+#define NS_BADCERTHANDLER_CONTRACTID                                           \
   "@mozilla.org/content/xmlhttprequest-bad-cert-handler;1"
 
 #define NS_PROGRESS_EVENT_INTERVAL 50
 
-#define IMPL_CSTRING_GETTER(_name)                                              \
-  NS_IMETHODIMP                                                                 \
-  nsXMLHttpRequest::_name(nsACString& aOut)                                     \
-  {                                                                             \
-    nsCString tmp;                                                              \
-    _name(tmp);                                                                 \
-    aOut = tmp;                                                                 \
-    return NS_OK;                                                               \
+#define IMPL_CSTRING_GETTER(_name)                                             \
+  NS_IMETHODIMP nsXMLHttpRequest::_name(nsACString& aOut)                      \
+  {                                                                            \
+    nsCString tmp;                                                             \
+    _name(tmp);                                                                \
+    aOut = tmp;                                                                \
+    return NS_OK;                                                              \
   }
 
 NS_IMPL_ISUPPORTS(nsXHRParseEndListener, nsIDOMEventListener)
 
 class nsResumeTimeoutsEvent : public nsRunnable
 {
 public:
   nsResumeTimeoutsEvent(nsPIDOMWindow* aWindow) : mWindow(aWindow) {}
@@ -156,20 +154,20 @@ public:
     mWindow->ResumeTimeouts(false);
     return NS_OK;
   }
 
 private:
   nsCOMPtr<nsPIDOMWindow> mWindow;
 };
 
-
 // This helper function adds the given load flags to the request's existing
 // load flags.
-static void AddLoadFlags(nsIRequest *request, nsLoadFlags newFlags)
+static void
+AddLoadFlags(nsIRequest* request, nsLoadFlags newFlags)
 {
   nsLoadFlags flags;
   request->GetLoadFlags(&flags);
   flags |= newFlags;
   request->SetLoadFlags(flags);
 }
 
 //-----------------------------------------------------------------------------
@@ -199,43 +197,38 @@ XMLHttpRequestAuthPrompt::~XMLHttpReques
 }
 
 NS_IMETHODIMP
 XMLHttpRequestAuthPrompt::Prompt(const char16_t* aDialogTitle,
                                  const char16_t* aText,
                                  const char16_t* aPasswordRealm,
                                  uint32_t aSavePassword,
                                  const char16_t* aDefaultText,
-                                 char16_t** aResult,
-                                 bool* aRetval)
+                                 char16_t** aResult, bool* aRetval)
 {
   *aRetval = false;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-XMLHttpRequestAuthPrompt::PromptUsernameAndPassword(const char16_t* aDialogTitle,
-                                                    const char16_t* aDialogText,
-                                                    const char16_t* aPasswordRealm,
-                                                    uint32_t aSavePassword,
-                                                    char16_t** aUser,
-                                                    char16_t** aPwd,
-                                                    bool* aRetval)
+XMLHttpRequestAuthPrompt::PromptUsernameAndPassword(
+  const char16_t* aDialogTitle, const char16_t* aDialogText,
+  const char16_t* aPasswordRealm, uint32_t aSavePassword, char16_t** aUser,
+  char16_t** aPwd, bool* aRetval)
 {
   *aRetval = false;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 XMLHttpRequestAuthPrompt::PromptPassword(const char16_t* aDialogTitle,
                                          const char16_t* aText,
                                          const char16_t* aPasswordRealm,
                                          uint32_t aSavePassword,
-                                         char16_t** aPwd,
-                                         bool* aRetval)
+                                         char16_t** aPwd, bool* aRetval)
 {
   *aRetval = false;
   return NS_OK;
 }
 
 /////////////////////////////////////////////
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsXHREventTarget)
@@ -244,88 +237,92 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
                                                   DOMEventTargetHelper)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXHREventTarget,
                                                 DOMEventTargetHelper)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXHREventTarget)
-  NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestEventTarget)
+NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestEventTarget)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 NS_IMPL_ADDREF_INHERITED(nsXHREventTarget, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(nsXHREventTarget, DOMEventTargetHelper)
 
 void
 nsXHREventTarget::DisconnectFromOwner()
 {
   DOMEventTargetHelper::DisconnectFromOwner();
 }
 
 /////////////////////////////////////////////
 
 NS_INTERFACE_MAP_BEGIN(nsXMLHttpRequestUpload)
-  NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestUpload)
+NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestUpload)
 NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
 
 NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
 NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
 
-/* virtual */ JSObject*
-nsXMLHttpRequestUpload::WrapObject(JSContext* aCx)
+  /* virtual */ JSObject* nsXMLHttpRequestUpload::WrapObject(JSContext* aCx)
 {
   return XMLHttpRequestUploadBinding::Wrap(aCx, this);
 }
 
 /////////////////////////////////////////////
 //
 //
 /////////////////////////////////////////////
 
-bool
-nsXMLHttpRequest::sDontWarnAboutSyncXHR = false;
+bool nsXMLHttpRequest::sDontWarnAboutSyncXHR = false;
 
 nsXMLHttpRequest::nsXMLHttpRequest()
-  : mResponseBodyDecodedPos(0),
-    mResponseType(XML_HTTP_RESPONSE_TYPE_DEFAULT),
-    mRequestObserver(nullptr), mState(XML_HTTP_REQUEST_UNSENT),
-    mUploadTransferred(0), mUploadTotal(0), mUploadComplete(true),
-    mProgressSinceLastProgressEvent(false),
-    mRequestSentTime(0), mTimeoutMilliseconds(0),
-    mErrorLoad(false), mWaitingForOnStopRequest(false),
-    mProgressTimerIsActive(false),
-    mIsHtml(false),
-    mWarnAboutSyncHtml(false),
-    mLoadLengthComputable(false), mLoadTotal(0),
-    mIsSystem(false),
-    mIsAnon(false),
-    mFirstStartRequestSeen(false),
-    mInLoadProgressEvent(false),
-    mResultJSON(JSVAL_VOID),
-    mResultArrayBuffer(nullptr),
-    mIsMappedArrayBuffer(false),
-    mXPCOMifier(nullptr)
+  : mResponseBodyDecodedPos(0)
+  , mResponseType(XML_HTTP_RESPONSE_TYPE_DEFAULT)
+  , mRequestObserver(nullptr)
+  , mState(XML_HTTP_REQUEST_UNSENT)
+  , mUploadTransferred(0)
+  , mUploadTotal(0)
+  , mUploadComplete(true)
+  , mProgressSinceLastProgressEvent(false)
+  , mRequestSentTime(0)
+  , mTimeoutMilliseconds(0)
+  , mErrorLoad(false)
+  , mWaitingForOnStopRequest(false)
+  , mProgressTimerIsActive(false)
+  , mIsHtml(false)
+  , mWarnAboutSyncHtml(false)
+  , mLoadLengthComputable(false)
+  , mLoadTotal(0)
+  , mIsSystem(false)
+  , mIsAnon(false)
+  , mFirstStartRequestSeen(false)
+  , mInLoadProgressEvent(false)
+  , mResultJSON(JSVAL_VOID)
+  , mResultArrayBuffer(nullptr)
+  , mIsMappedArrayBuffer(false)
+  , mXPCOMifier(nullptr)
 {
   SetIsDOMBinding();
 #ifdef DEBUG
   StaticAssertions();
 #endif
 }
 
 nsXMLHttpRequest::~nsXMLHttpRequest()
 {
   mState |= XML_HTTP_REQUEST_DELETED;
 
-  if (mState & (XML_HTTP_REQUEST_SENT |
-                XML_HTTP_REQUEST_LOADING)) {
+  if (mState & (XML_HTTP_REQUEST_SENT | XML_HTTP_REQUEST_LOADING)) {
     Abort();
   }
 
-  NS_ABORT_IF_FALSE(!(mState & XML_HTTP_REQUEST_SYNCLOOPING), "we rather crash than hang");
+  NS_ABORT_IF_FALSE(!(mState & XML_HTTP_REQUEST_SYNCLOOPING),
+                    "we rather crash than hang");
   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
 
   mResultJSON = JSVAL_VOID;
   mResultArrayBuffer = nullptr;
   mozilla::DropJSObjects(this);
 }
 
 void
@@ -357,26 +354,25 @@ nsXMLHttpRequest::Init()
 }
 
 /**
  * This Init method should only be called by C++ consumers.
  */
 NS_IMETHODIMP
 nsXMLHttpRequest::Init(nsIPrincipal* aPrincipal,
                        nsIScriptContext* aScriptContext,
-                       nsIGlobalObject* aGlobalObject,
-                       nsIURI* aBaseURI)
+                       nsIGlobalObject* aGlobalObject, nsIURI* aBaseURI)
 {
   NS_ENSURE_ARG_POINTER(aPrincipal);
-  
+
   if (nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aGlobalObject)) {
     if (win->IsOuterWindow()) {
       // Must be bound to inner window, innerize if necessary.
-      nsCOMPtr<nsIGlobalObject> inner = do_QueryInterface(
-        win->GetCurrentInnerWindow());
+      nsCOMPtr<nsIGlobalObject> inner =
+        do_QueryInterface(win->GetCurrentInnerWindow());
       aGlobalObject = inner.get();
     }
   }
 
   Construct(aPrincipal, aGlobalObject, aBaseURI);
   return NS_OK;
 }
 
@@ -397,18 +393,17 @@ nsXMLHttpRequest::InitParameters(bool aA
   // for non-chrome pages.
   if (!IsSystemXHR() && aSystem) {
     nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
     if (!doc) {
       return;
     }
 
     nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
-    nsCOMPtr<nsIPermissionManager> permMgr =
-      services::GetPermissionManager();
+    nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
     if (!permMgr)
       return;
 
     uint32_t permission;
     nsresult rv =
       permMgr->TestPermissionFromPrincipal(principal, "systemXHR", &permission);
     if (NS_FAILED(rv) || permission != nsIPermissionManager::ALLOW_ACTION) {
       return;
@@ -438,106 +433,106 @@ void
 nsXMLHttpRequest::SetRequestObserver(nsIRequestObserver* aObserver)
 {
   mRequestObserver = aObserver;
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpRequest)
 
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsXMLHttpRequest)
-  bool isBlack = tmp->IsBlack();
-  if (isBlack || tmp->mWaitingForOnStopRequest) {
-    if (tmp->mListenerManager) {
-      tmp->mListenerManager->MarkForCC();
-    }
-    if (!isBlack && tmp->PreservingWrapper()) {
-      // This marks the wrapper black.
-      tmp->GetWrapper();
-    }
-    return true;
+bool isBlack = tmp->IsBlack();
+if (isBlack || tmp->mWaitingForOnStopRequest) {
+  if (tmp->mListenerManager) {
+    tmp->mListenerManager->MarkForCC();
   }
+  if (!isBlack && tmp->PreservingWrapper()) {
+    // This marks the wrapper black.
+    tmp->GetWrapper();
+  }
+  return true;
+}
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
 
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsXMLHttpRequest)
-  return tmp->
-    IsBlackAndDoesNotNeedTracing(static_cast<DOMEventTargetHelper*>(tmp));
+return tmp->IsBlackAndDoesNotNeedTracing(
+  static_cast<DOMEventTargetHelper*>(tmp));
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
 
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsXMLHttpRequest)
-  return tmp->IsBlack();
+return tmp->IsBlack();
 NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXMLHttpRequest,
                                                   nsXHREventTarget)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mContext)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mChannel)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mResponseXML)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCORSPreflightChannel)
-
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mXMLParserStreamListener)
-
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mChannelEventSink)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mProgressEventSink)
-
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mUpload)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mContext)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mChannel)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mResponseXML)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCORSPreflightChannel)
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mXMLParserStreamListener)
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mChannelEventSink)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mProgressEventSink)
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mUpload)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXMLHttpRequest,
                                                 nsXHREventTarget)
-  tmp->mResultArrayBuffer = nullptr;
-  tmp->mArrayBufferBuilder.reset();
-  tmp->mResultJSON = JSVAL_VOID;
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mContext)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mChannel)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mResponseXML)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCORSPreflightChannel)
-
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mXMLParserStreamListener)
-
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mChannelEventSink)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mProgressEventSink)
-
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mUpload)
+tmp->mResultArrayBuffer = nullptr;
+tmp->mArrayBufferBuilder.reset();
+tmp->mResultJSON = JSVAL_VOID;
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mContext)
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mChannel)
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mResponseXML)
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mCORSPreflightChannel)
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mXMLParserStreamListener)
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mChannelEventSink)
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mProgressEventSink)
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK(mUpload)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(nsXMLHttpRequest,
                                                nsXHREventTarget)
-  NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mResultArrayBuffer)
-  NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK(mResultJSON)
+NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mResultArrayBuffer)
+NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK(mResultJSON)
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 // QueryInterface implementation for nsXMLHttpRequest
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXMLHttpRequest)
-  NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequest)
-  NS_INTERFACE_MAP_ENTRY(nsIJSXMLHttpRequest)
-  NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
-  NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
-  NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
-  NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
-  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
-  NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
-  NS_INTERFACE_MAP_ENTRY(nsISizeOfEventTarget)
+NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequest)
+NS_INTERFACE_MAP_ENTRY(nsIJSXMLHttpRequest)
+NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
+NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
+NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
+NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
+NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
+NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
+NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+NS_INTERFACE_MAP_ENTRY(nsISizeOfEventTarget)
 NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
 
 NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
 NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
 
 NS_IMPL_EVENT_HANDLER(nsXMLHttpRequest, readystatechange)
 
 void
 nsXMLHttpRequest::DisconnectFromOwner()
 {
   nsXHREventTarget::DisconnectFromOwner();
   Abort();
 }
 
 size_t
-nsXMLHttpRequest::SizeOfEventTargetIncludingThis(
-  MallocSizeOf aMallocSizeOf) const
+nsXMLHttpRequest::SizeOfEventTargetIncludingThis(MallocSizeOf aMallocSizeOf)
+  const
 {
   size_t n = aMallocSizeOf(this);
   n += mResponseBody.SizeOfExcludingThisIfUnshared(aMallocSizeOf);
 
   // Why is this safe?  Because no-one else will report this string.  The
   // other possible sharers of this string are as follows.
   //
   // - The JS engine could hold copies if the JS code holds references, e.g.
@@ -554,39 +549,39 @@ nsXMLHttpRequest::SizeOfEventTargetInclu
 
   // Measurement of the following members may be added later if DMD finds it is
   // worthwhile:
   // - lots
 }
 
 /* readonly attribute nsIChannel channel; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetChannel(nsIChannel **aChannel)
+nsXMLHttpRequest::GetChannel(nsIChannel** aChannel)
 {
   NS_ENSURE_ARG_POINTER(aChannel);
   NS_IF_ADDREF(*aChannel = mChannel);
 
   return NS_OK;
 }
 
-static void LogMessage(const char* aWarning, nsPIDOMWindow* aWindow)
+static void
+LogMessage(const char* aWarning, nsPIDOMWindow* aWindow)
 {
   nsCOMPtr<nsIDocument> doc;
   if (aWindow) {
     doc = aWindow->GetExtantDoc();
   }
   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
                                   NS_LITERAL_CSTRING("DOM"), doc,
-                                  nsContentUtils::eDOM_PROPERTIES,
-                                  aWarning);
+                                  nsContentUtils::eDOM_PROPERTIES, aWarning);
 }
 
 /* readonly attribute nsIDOMDocument responseXML; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetResponseXML(nsIDOMDocument **aResponseXML)
+nsXMLHttpRequest::GetResponseXML(nsIDOMDocument** aResponseXML)
 {
   ErrorResult rv;
   nsIDocument* responseXML = GetResponseXML(rv);
   if (rv.Failed()) {
     return rv.ErrorCode();
   }
 
   if (!responseXML) {
@@ -625,18 +620,17 @@ nsXMLHttpRequest::DetectCharset()
   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
       mResponseType != XML_HTTP_RESPONSE_TYPE_TEXT &&
       mResponseType != XML_HTTP_RESPONSE_TYPE_JSON &&
       mResponseType != XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
     return NS_OK;
   }
 
   nsAutoCString charsetVal;
-  bool ok = mChannel &&
-            NS_SUCCEEDED(mChannel->GetContentCharset(charsetVal)) &&
+  bool ok = mChannel && NS_SUCCEEDED(mChannel->GetContentCharset(charsetVal)) &&
             EncodingUtils::FindEncodingForLabel(charsetVal, mResponseCharset);
   if (!ok || mResponseCharset.IsEmpty()) {
     // MS documentation states UTF-8 is default for responseText
     mResponseCharset.AssignLiteral("UTF-8");
   }
 
   if (mResponseType == XML_HTTP_RESPONSE_TYPE_JSON &&
       !mResponseCharset.EqualsLiteral("UTF-8")) {
@@ -646,42 +640,40 @@ nsXMLHttpRequest::DetectCharset()
   }
 
   mDecoder = EncodingUtils::DecoderForEncoding(mResponseCharset);
 
   return NS_OK;
 }
 
 nsresult
-nsXMLHttpRequest::AppendToResponseText(const char * aSrcBuffer,
+nsXMLHttpRequest::AppendToResponseText(const char* aSrcBuffer,
                                        uint32_t aSrcBufferLen)
 {
   NS_ENSURE_STATE(mDecoder);
 
   int32_t destBufferLen;
-  nsresult rv = mDecoder->GetMaxLength(aSrcBuffer, aSrcBufferLen,
-                                       &destBufferLen);
+  nsresult rv =
+    mDecoder->GetMaxLength(aSrcBuffer, aSrcBufferLen, &destBufferLen);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  if (!mResponseText.SetCapacity(mResponseText.Length() + destBufferLen, fallible_t())) {
+  if (!mResponseText.SetCapacity(mResponseText.Length() + destBufferLen,
+                                 fallible_t())) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   char16_t* destBuffer = mResponseText.BeginWriting() + mResponseText.Length();
 
   int32_t totalChars = mResponseText.Length();
 
   // This code here is basically a copy of a similar thing in
   // nsScanner::Append(const char* aBuffer, uint32_t aLen).
   int32_t srclen = (int32_t)aSrcBufferLen;
   int32_t destlen = (int32_t)destBufferLen;
-  rv = mDecoder->Convert(aSrcBuffer,
-                         &srclen,
-                         destBuffer,
-                         &destlen);
+  rv = mDecoder->Convert(aSrcBuffer, &srclen, destBuffer, &destlen);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 
   totalChars += destlen;
 
   mResponseText.SetLength(totalChars);
 
   return NS_OK;
 }
@@ -717,18 +709,17 @@ nsXMLHttpRequest::GetResponseText(nsStri
 
   if (!(mState & (XML_HTTP_REQUEST_DONE | XML_HTTP_REQUEST_LOADING))) {
     return;
   }
 
   // We only decode text lazily if we're also parsing to a doc.
   // Also, if we've decoded all current data already, then no need to decode
   // more.
-  if (!mResponseXML ||
-      mResponseBodyDecodedPos == mResponseBody.Length()) {
+  if (!mResponseXML || mResponseBodyDecodedPos == mResponseBody.Length()) {
     aResponseText = mResponseText;
     return;
   }
 
   if (mResponseCharset != mResponseXML->GetDocumentCharacterSet()) {
     mResponseCharset = mResponseXML->GetDocumentCharacterSet();
     mResponseText.Truncate();
     mResponseBodyDecodedPos = 0;
@@ -739,17 +730,17 @@ nsXMLHttpRequest::GetResponseText(nsStri
                "Unexpected mResponseBodyDecodedPos");
   aRv = AppendToResponseText(mResponseBody.get() + mResponseBodyDecodedPos,
                              mResponseBody.Length() - mResponseBodyDecodedPos);
   if (aRv.Failed()) {
     return;
   }
 
   mResponseBodyDecodedPos = mResponseBody.Length();
-  
+
   if (mState & XML_HTTP_REQUEST_DONE) {
     // Free memory buffer which we no longer need
     mResponseBody.Truncate();
     mResponseBodyDecodedPos = 0;
   }
 
   aResponseText = mResponseText;
 }
@@ -759,35 +750,33 @@ nsXMLHttpRequest::CreateResponseParsedJS
 {
   if (!aCx) {
     return NS_ERROR_FAILURE;
   }
   RootJSResultObjects();
 
   // The Unicode converter has already zapped the BOM if there was one
   JS::Rooted<JS::Value> value(aCx);
-  if (!JS_ParseJSON(aCx,
-                    static_cast<const jschar*>(mResponseText.get()), mResponseText.Length(),
-                    &value)) {
+  if (!JS_ParseJSON(aCx, static_cast<const jschar*>(mResponseText.get()),
+                    mResponseText.Length(), &value)) {
     return NS_ERROR_FAILURE;
   }
 
   mResultJSON = value;
   return NS_OK;
 }
 
 void
 nsXMLHttpRequest::CreatePartialBlob()
 {
   if (mDOMFile) {
     if (mLoadTotal == mLoadTransferred) {
       mResponseBlob = mDOMFile;
     } else {
-      mResponseBlob =
-        mDOMFile->CreateSlice(0, mLoadTransferred, EmptyString());
+      mResponseBlob = mDOMFile->CreateSlice(0, mLoadTransferred, EmptyString());
     }
     return;
   }
 
   // mBlobSet can be null if the request has been canceled
   if (!mBlobSet) {
     return;
   }
@@ -796,17 +785,18 @@ nsXMLHttpRequest::CreatePartialBlob()
   if (mLoadTotal == mLoadTransferred) {
     mChannel->GetContentType(contentType);
   }
 
   mResponseBlob = mBlobSet->GetBlobInternal(contentType);
 }
 
 /* attribute AString responseType; */
-NS_IMETHODIMP nsXMLHttpRequest::GetResponseType(nsAString& aResponseType)
+NS_IMETHODIMP
+nsXMLHttpRequest::GetResponseType(nsAString& aResponseType)
 {
   switch (mResponseType) {
   case XML_HTTP_RESPONSE_TYPE_DEFAULT:
     aResponseType.Truncate();
     break;
   case XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER:
     aResponseType.AssignLiteral("arraybuffer");
     break;
@@ -837,37 +827,37 @@ NS_IMETHODIMP nsXMLHttpRequest::GetRespo
 
   return NS_OK;
 }
 
 #ifdef DEBUG
 void
 nsXMLHttpRequest::StaticAssertions()
 {
-#define ASSERT_ENUM_EQUAL(_lc, _uc) \
-  static_assert(\
-    static_cast<int>(XMLHttpRequestResponseType::_lc)  \
-    == XML_HTTP_RESPONSE_TYPE_ ## _uc, \
-    #_uc " should match")
+#define ASSERT_ENUM_EQUAL(_lc, _uc)                                            \
+  static_assert(static_cast<int>(XMLHttpRequestResponseType::_lc) ==           \
+                  XML_HTTP_RESPONSE_TYPE_##_uc,                                \
+                #_uc " should match")
 
   ASSERT_ENUM_EQUAL(_empty, DEFAULT);
   ASSERT_ENUM_EQUAL(Arraybuffer, ARRAYBUFFER);
   ASSERT_ENUM_EQUAL(Blob, BLOB);
   ASSERT_ENUM_EQUAL(Document, DOCUMENT);
   ASSERT_ENUM_EQUAL(Json, JSON);
   ASSERT_ENUM_EQUAL(Text, TEXT);
   ASSERT_ENUM_EQUAL(Moz_chunked_text, CHUNKED_TEXT);
   ASSERT_ENUM_EQUAL(Moz_chunked_arraybuffer, CHUNKED_ARRAYBUFFER);
   ASSERT_ENUM_EQUAL(Moz_blob, MOZ_BLOB);
 #undef ASSERT_ENUM_EQUAL
 }
 #endif
 
 /* attribute AString responseType; */
-NS_IMETHODIMP nsXMLHttpRequest::SetResponseType(const nsAString& aResponseType)
+NS_IMETHODIMP
+nsXMLHttpRequest::SetResponseType(const nsAString& aResponseType)
 {
   nsXMLHttpRequest::ResponseTypeEnum responseType;
   if (aResponseType.IsEmpty()) {
     responseType = XML_HTTP_RESPONSE_TYPE_DEFAULT;
   } else if (aResponseType.EqualsLiteral("arraybuffer")) {
     responseType = XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER;
   } else if (aResponseType.EqualsLiteral("blob")) {
     responseType = XML_HTTP_RESPONSE_TYPE_BLOB;
@@ -895,18 +885,18 @@ NS_IMETHODIMP nsXMLHttpRequest::SetRespo
 void
 nsXMLHttpRequest::SetResponseType(XMLHttpRequestResponseType aType,
                                   ErrorResult& aRv)
 {
   SetResponseType(ResponseTypeEnum(static_cast<int>(aType)), aRv);
 }
 
 void
-nsXMLHttpRequest::SetResponseType(nsXMLHttpRequest::ResponseTypeEnum aResponseType,
-                                  ErrorResult& aRv)
+nsXMLHttpRequest::SetResponseType(
+  nsXMLHttpRequest::ResponseTypeEnum aResponseType, ErrorResult& aRv)
 {
   // If the state is not OPENED or HEADERS_RECEIVED raise an
   // INVALID_STATE_ERR exception and terminate these steps.
   if (!(mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT |
                   XML_HTTP_REQUEST_HEADERS_RECEIVED))) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
@@ -923,52 +913,50 @@ nsXMLHttpRequest::SetResponseType(nsXMLH
       (aResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT ||
        aResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER)) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
   // Set the responseType attribute's value to the given value.
   mResponseType = aResponseType;
-
 }
 
 /* readonly attribute jsval response; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetResponse(JSContext *aCx, JS::MutableHandle<JS::Value> aResult)
+nsXMLHttpRequest::GetResponse(JSContext* aCx,
+                              JS::MutableHandle<JS::Value> aResult)
 {
   ErrorResult rv;
   aResult.set(GetResponse(aCx, rv));
   return rv.ErrorCode();
 }
 
 JS::Value
 nsXMLHttpRequest::GetResponse(JSContext* aCx, ErrorResult& aRv)
 {
   switch (mResponseType) {
   case XML_HTTP_RESPONSE_TYPE_DEFAULT:
   case XML_HTTP_RESPONSE_TYPE_TEXT:
-  case XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT:
-  {
+  case XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT: {
     nsString str;
     aRv = GetResponseText(str);
     if (aRv.Failed()) {
       return JSVAL_NULL;
     }
     JS::Rooted<JS::Value> result(aCx);
     if (!xpc::StringToJsval(aCx, str, &result)) {
       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
       return JSVAL_NULL;
     }
     return result;
   }
 
   case XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER:
-  case XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER:
-  {
+  case XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER: {
     if (!(mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
           mState & XML_HTTP_REQUEST_DONE) &&
         !(mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER &&
           mInLoadProgressEvent)) {
       return JSVAL_NULL;
     }
 
     if (!mResultArrayBuffer) {
@@ -978,18 +966,17 @@ nsXMLHttpRequest::GetResponse(JSContext*
       if (!mResultArrayBuffer) {
         aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
         return JSVAL_NULL;
       }
     }
     return OBJECT_TO_JSVAL(mResultArrayBuffer);
   }
   case XML_HTTP_RESPONSE_TYPE_BLOB:
-  case XML_HTTP_RESPONSE_TYPE_MOZ_BLOB:
-  {
+  case XML_HTTP_RESPONSE_TYPE_MOZ_BLOB: {
     if (!(mState & XML_HTTP_REQUEST_DONE)) {
       if (mResponseType != XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
         return JSVAL_NULL;
       }
 
       if (!mResponseBlob) {
         CreatePartialBlob();
       }
@@ -998,28 +985,26 @@ nsXMLHttpRequest::GetResponse(JSContext*
     if (!mResponseBlob) {
       return JSVAL_NULL;
     }
 
     JS::Rooted<JS::Value> result(aCx);
     aRv = nsContentUtils::WrapNative(aCx, mResponseBlob, &result);
     return result;
   }
-  case XML_HTTP_RESPONSE_TYPE_DOCUMENT:
-  {
+  case XML_HTTP_RESPONSE_TYPE_DOCUMENT: {
     if (!(mState & XML_HTTP_REQUEST_DONE) || !mResponseXML) {
       return JSVAL_NULL;
     }
 
     JS::Rooted<JS::Value> result(aCx);
     aRv = nsContentUtils::WrapNative(aCx, mResponseXML, &result);
     return result;
   }
-  case XML_HTTP_RESPONSE_TYPE_JSON:
-  {
+  case XML_HTTP_RESPONSE_TYPE_JSON: {
     if (!(mState & XML_HTTP_REQUEST_DONE)) {
       return JSVAL_NULL;
     }
 
     if (mResultJSON == JSVAL_VOID) {
       aRv = CreateResponseParsedJSON(aCx);
       mResponseText.Truncate();
       if (aRv.Failed()) {
@@ -1079,17 +1064,17 @@ nsXMLHttpRequest::GetResponseURL(nsAStri
 
   nsAutoCString temp;
   responseUrl->GetSpec(temp);
   CopyUTF8toUTF16(temp, aUrl);
 }
 
 /* readonly attribute unsigned long status; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetStatus(uint32_t *aStatus)
+nsXMLHttpRequest::GetStatus(uint32_t* aStatus)
 {
   *aStatus = Status();
   return NS_OK;
 }
 
 uint32_t
 nsXMLHttpRequest::Status()
 {
@@ -1156,17 +1141,16 @@ nsXMLHttpRequest::GetStatusText(nsCStrin
 
   // Make sure we don't leak status information from denied cross-site
   // requests.
   if (IsDeniedCrossSiteRequest()) {
     return;
   }
 
   httpChannel->GetResponseStatusText(aStatusText);
-
 }
 
 void
 nsXMLHttpRequest::CloseRequestWithError(const nsAString& aType,
                                         const uint32_t aFlag)
 {
   if (mChannel) {
     mChannel->Cancel(NS_BINDING_ABORTED);
@@ -1182,18 +1166,17 @@ nsXMLHttpRequest::CloseRequestWithError(
   mState |= aFlag;
 
   // If we're in the destructor, don't risk dispatching an event.
   if (mState & XML_HTTP_REQUEST_DELETED) {
     mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
     return;
   }
 
-  if (!(mState & (XML_HTTP_REQUEST_UNSENT |
-                  XML_HTTP_REQUEST_OPENED |
+  if (!(mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_OPENED |
                   XML_HTTP_REQUEST_DONE))) {
     ChangeState(XML_HTTP_REQUEST_DONE, true);
 
     if (!(mState & XML_HTTP_REQUEST_SYNCLOOPING)) {
       DispatchProgressEvent(this, aType, mLoadLengthComputable, responseLength,
                             mLoadTotal);
       if (mUpload && !mUploadComplete) {
         mUploadComplete = true;
@@ -1202,17 +1185,17 @@ nsXMLHttpRequest::CloseRequestWithError(
       }
     }
   }
 
   // The ChangeState call above calls onreadystatechange handlers which
   // if they load a new url will cause nsXMLHttpRequest::Open to clear
   // the abort state bit. If this occurs we're not uninitialized (bug 361773).
   if (mState & XML_HTTP_REQUEST_ABORTED) {
-    ChangeState(XML_HTTP_REQUEST_UNSENT, false);  // IE seems to do it
+    ChangeState(XML_HTTP_REQUEST_UNSENT, false); // IE seems to do it
   }
 
   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
 }
 
 /* void abort (); */
 void
 nsXMLHttpRequest::Abort()
@@ -1225,54 +1208,52 @@ nsXMLHttpRequest::SlowAbort()
 {
   Abort();
   return NS_OK;
 }
 
 /*Method that checks if it is safe to expose a header value to the client.
 It is used to check what headers are exposed for CORS requests.*/
 bool
-nsXMLHttpRequest::IsSafeHeader(const nsACString& header, nsIHttpChannel* httpChannel)
+nsXMLHttpRequest::IsSafeHeader(const nsACString& header,
+                               nsIHttpChannel* httpChannel)
 {
   // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
-  if (!IsSystemXHR() &&
-       (header.LowerCaseEqualsASCII("set-cookie") ||
-        header.LowerCaseEqualsASCII("set-cookie2"))) {
+  if (!IsSystemXHR() && (header.LowerCaseEqualsASCII("set-cookie") ||
+                         header.LowerCaseEqualsASCII("set-cookie2"))) {
     NS_WARNING("blocked access to response header");
     return false;
   }
   // if this is not a CORS call all headers are safe
-  if (!(mState & XML_HTTP_REQUEST_USE_XSITE_AC)){
+  if (!(mState & XML_HTTP_REQUEST_USE_XSITE_AC)) {
     return true;
   }
   // Check for dangerous headers
   // Make sure we don't leak header information from denied cross-site
   // requests.
   if (mChannel) {
     nsresult status;
     mChannel->GetStatus(&status);
     if (NS_FAILED(status)) {
       return false;
     }
-  }  
-  const char* kCrossOriginSafeHeaders[] = {
-    "cache-control", "content-language", "content-type", "expires",
-    "last-modified", "pragma"
-  };
+  }
+  const char* kCrossOriginSafeHeaders[] = { "cache-control", "content-language",
+                                            "content-type",  "expires",
+                                            "last-modified", "pragma" };
   for (uint32_t i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
     if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
       return true;
     }
   }
   nsAutoCString headerVal;
   // The "Access-Control-Expose-Headers" header contains a comma separated
   // list of method names.
-  httpChannel->
-      GetResponseHeader(NS_LITERAL_CSTRING("Access-Control-Expose-Headers"),
-                        headerVal);
+  httpChannel->GetResponseHeader(
+    NS_LITERAL_CSTRING("Access-Control-Expose-Headers"), headerVal);
   nsCCharSeparatedTokenizer exposeTokens(headerVal, ',');
   bool isSafe = false;
   while (exposeTokens.hasMoreTokens()) {
     const nsDependentCSubstring& token = exposeTokens.nextToken();
     if (token.IsEmpty()) {
       continue;
     }
     if (!IsValidHTTPToken(token)) {
@@ -1289,18 +1270,18 @@ nsXMLHttpRequest::IsSafeHeader(const nsA
 IMPL_CSTRING_GETTER(GetAllResponseHeaders)
 void
 nsXMLHttpRequest::GetAllResponseHeaders(nsCString& aResponseHeaders)
 {
   aResponseHeaders.Truncate();
 
   // If the state is UNSENT or OPENED,
   // return the empty string and terminate these steps.
-  if (mState & (XML_HTTP_REQUEST_UNSENT |
-                XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
+  if (mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_OPENED |
+                XML_HTTP_REQUEST_SENT)) {
     return;
   }
 
   if (nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel()) {
     nsRefPtr<nsHeaderVisitor> visitor = new nsHeaderVisitor(this, httpChannel);
     if (NS_SUCCEEDED(httpChannel->VisitResponseHeaders(visitor))) {
       aResponseHeaders = visitor->Headers();
     }
@@ -1346,27 +1327,26 @@ nsXMLHttpRequest::GetResponseHeader(cons
 {
   _retval.SetIsVoid(true);
 
   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
 
   if (!httpChannel) {
     // If the state is UNSENT or OPENED,
     // return null and terminate these steps.
-    if (mState & (XML_HTTP_REQUEST_UNSENT |
-                  XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
+    if (mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_OPENED |
+                  XML_HTTP_REQUEST_SENT)) {
       return;
     }
 
     // Even non-http channels supply content type and content length.
     // Remember we don't leak header information from denied cross-site
     // requests.
     nsresult status;
-    if (!mChannel ||
-        NS_FAILED(mChannel->GetStatus(&status)) ||
+    if (!mChannel || NS_FAILED(mChannel->GetStatus(&status)) ||
         NS_FAILED(status)) {
       return;
     }
 
     // Content Type:
     if (header.LowerCaseEqualsASCII("content-type")) {
       if (NS_FAILED(mChannel->GetContentType(_retval))) {
         // Means no content type
@@ -1404,44 +1384,41 @@ nsXMLHttpRequest::GetResponseHeader(cons
     _retval.SetIsVoid(true);
     aRv = NS_OK;
   }
 }
 
 already_AddRefed<nsILoadGroup>
 nsXMLHttpRequest::GetLoadGroup() const
 {
-  if (mState & XML_HTTP_REQUEST_BACKGROUND) {                 
+  if (mState & XML_HTTP_REQUEST_BACKGROUND) {
     return nullptr;
   }
 
   nsresult rv = NS_ERROR_FAILURE;
   nsIScriptContext* sc =
     const_cast<nsXMLHttpRequest*>(this)->GetContextForEventHandlers(&rv);
-  nsCOMPtr<nsIDocument> doc =
-    nsContentUtils::GetDocumentFromScriptContext(sc);
+  nsCOMPtr<nsIDocument> doc = nsContentUtils::GetDocumentFromScriptContext(sc);
   if (doc) {
     return doc->GetDocumentLoadGroup();
   }
 
   return nullptr;
 }
 
 nsresult
 nsXMLHttpRequest::CreateReadystatechangeEvent(nsIDOMEvent** aDOMEvent)
 {
-  nsresult rv = EventDispatcher::CreateEvent(this, nullptr, nullptr,
-                                             NS_LITERAL_STRING("Events"),
-                                             aDOMEvent);
+  nsresult rv = EventDispatcher::CreateEvent(
+    this, nullptr, nullptr, NS_LITERAL_STRING("Events"), aDOMEvent);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  (*aDOMEvent)->InitEvent(NS_LITERAL_STRING(READYSTATE_STR),
-                          false, false);
+  (*aDOMEvent)->InitEvent(NS_LITERAL_STRING(READYSTATE_STR), false, false);
 
   // We assume anyone who managed to call CreateReadystatechangeEvent is trusted
   (*aDOMEvent)->SetTrusted(true);
 
   return NS_OK;
 }
 
 void
@@ -1453,46 +1430,45 @@ nsXMLHttpRequest::DispatchProgressEvent(
   NS_ASSERTION(aTarget, "null target");
   NS_ASSERTION(!aType.IsEmpty(), "missing event type");
 
   if (NS_FAILED(CheckInnerWindowCorrectness()) ||
       (!AllowUploadProgress() && aTarget == mUpload)) {
     return;
   }
 
-  bool dispatchLoadend = aType.EqualsLiteral(LOAD_STR) ||
-                         aType.EqualsLiteral(ERROR_STR) ||
-                         aType.EqualsLiteral(TIMEOUT_STR) ||
-                         aType.EqualsLiteral(ABORT_STR);
+  bool dispatchLoadend =
+    aType.EqualsLiteral(LOAD_STR) || aType.EqualsLiteral(ERROR_STR) ||
+    aType.EqualsLiteral(TIMEOUT_STR) || aType.EqualsLiteral(ABORT_STR);
 
   nsCOMPtr<nsIDOMEvent> event;
-  nsresult rv = NS_NewDOMProgressEvent(getter_AddRefs(event), this,
-                                       nullptr, nullptr);
+  nsresult rv =
+    NS_NewDOMProgressEvent(getter_AddRefs(event), this, nullptr, nullptr);
   if (NS_FAILED(rv)) {
     return;
   }
 
   nsCOMPtr<nsIDOMProgressEvent> progress = do_QueryInterface(event);
   if (!progress) {
     return;
   }
 
-  progress->InitProgressEvent(aType, false, false, aLengthComputable,
-                              aLoaded, (aTotal == UINT64_MAX) ? 0 : aTotal);
+  progress->InitProgressEvent(aType, false, false, aLengthComputable, aLoaded,
+                              (aTotal == UINT64_MAX) ? 0 : aTotal);
 
   event->SetTrusted(true);
 
   aTarget->DispatchDOMEvent(nullptr, event, nullptr, nullptr);
 
   if (dispatchLoadend) {
     DispatchProgressEvent(aTarget, NS_LITERAL_STRING(LOADEND_STR),
                           aLengthComputable, aLoaded, aTotal);
   }
 }
-                                          
+
 already_AddRefed<nsIHttpChannel>
 nsXMLHttpRequest::GetCurrentHttpChannel()
 {
   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel);
   return httpChannel.forget();
 }
 
 already_AddRefed<nsIJARChannel>
@@ -1511,17 +1487,17 @@ nsXMLHttpRequest::IsSystemXHR()
 nsresult
 nsXMLHttpRequest::CheckChannelForCrossSiteRequest(nsIChannel* aChannel)
 {
   // A system XHR (chrome code or a web app with the right permission) can
   // always perform cross-site requests. In the web app case, however, we
   // must still check for protected URIs like file:///.
   if (IsSystemXHR()) {
     if (!nsContentUtils::IsSystemPrincipal(mPrincipal)) {
-      nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
+      nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
       nsCOMPtr<nsIURI> uri;
       aChannel->GetOriginalURI(getter_AddRefs(uri));
       return secMan->CheckLoadURIWithPrincipal(
         mPrincipal, uri, nsIScriptSecurityManager::STANDARD);
     }
     return NS_OK;
   }
 
@@ -1535,18 +1511,17 @@ nsXMLHttpRequest::CheckChannelForCrossSi
   mState |= XML_HTTP_REQUEST_USE_XSITE_AC;
 
   // Check if we need to do a preflight request.
   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
   NS_ENSURE_TRUE(httpChannel, NS_ERROR_DOM_BAD_URI);
 
   nsAutoCString method;
   httpChannel->GetRequestMethod(method);
-  if (!mCORSUnsafeHeaders.IsEmpty() ||
-      (mUpload && mUpload->HasListeners()) ||
+  if (!mCORSUnsafeHeaders.IsEmpty() || (mUpload && mUpload->HasListeners()) ||
       (!method.LowerCaseEqualsLiteral("get") &&
        !method.LowerCaseEqualsLiteral("post") &&
        !method.LowerCaseEqualsLiteral("head"))) {
     mState |= XML_HTTP_REQUEST_NEED_AC_PREFLIGHT;
   }
 
   return NS_OK;
 }
@@ -1578,18 +1553,17 @@ nsXMLHttpRequest::Open(const nsACString&
 {
   NS_ENSURE_ARG(!inMethod.IsEmpty());
 
   if (!async && !DontWarnAboutSyncXHR() && GetOwner() &&
       GetOwner()->GetExtantDoc()) {
     GetOwner()->GetExtantDoc()->WarnOnceAbout(nsIDocument::eSyncXMLHttpRequest);
   }
 
-  Telemetry::Accumulate(Telemetry::XMLHTTPREQUEST_ASYNC_OR_SYNC,
-                        async ? 0 : 1);
+  Telemetry::Accumulate(Telemetry::XMLHTTPREQUEST_ASYNC_OR_SYNC, async ? 0 : 1);
 
   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
 
   // Disallow HTTP/1.1 TRACE method (see bug 302489)
   // and MS IIS equivalent TRACK (see bug 381264)
   // and CONNECT
   if (inMethod.LowerCaseEqualsLiteral("trace") ||
       inMethod.LowerCaseEqualsLiteral("connect") ||
@@ -1613,38 +1587,35 @@ nsXMLHttpRequest::Open(const nsACString&
     method.AssignLiteral("PUT");
   } else {
     method = inMethod; // other methods are not normalized
   }
 
   // sync request is not allowed using withCredential or responseType
   // in window context
   if (!async && HasOrHasHadOwner() &&
-      (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS ||
-       mTimeoutMilliseconds ||
+      (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS || mTimeoutMilliseconds ||
        mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT)) {
     if (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS) {
       LogMessage("WithCredentialsSyncXHRWarning", GetOwner());
     }
     if (mTimeoutMilliseconds) {
       LogMessage("TimeoutSyncXHRWarning", GetOwner());
     }
     if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT) {
       LogMessage("ResponseTypeSyncXHRWarning", GetOwner());
     }
     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
   }
 
   nsresult rv;
   nsCOMPtr<nsIURI> uri;
 
-  if (mState & (XML_HTTP_REQUEST_OPENED |
-                XML_HTTP_REQUEST_HEADERS_RECEIVED |
-                XML_HTTP_REQUEST_LOADING |
-                XML_HTTP_REQUEST_SENT)) {
+  if (mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_HEADERS_RECEIVED |
+                XML_HTTP_REQUEST_LOADING | XML_HTTP_REQUEST_SENT)) {
     // IE aborts as well
     Abort();
 
     // XXX We should probably send a warning to the JS console
     //     that load was aborted and event listeners were cleared
     //     since this looks like a situation that could happen
     //     by accident and you could spend a lot of time wondering
     //     why things didn't work.
@@ -1656,43 +1627,40 @@ nsXMLHttpRequest::Open(const nsACString&
   if (async) {
     mState |= XML_HTTP_REQUEST_ASYNC;
   } else {
     mState &= ~XML_HTTP_REQUEST_ASYNC;
   }
 
   nsIScriptContext* sc = GetContextForEventHandlers(&rv);
   NS_ENSURE_SUCCESS(rv, rv);
-  nsCOMPtr<nsIDocument> doc =
-    nsContentUtils::GetDocumentFromScriptContext(sc);
-  
+  nsCOMPtr<nsIDocument> doc = nsContentUtils::GetDocumentFromScriptContext(sc);
+
   nsCOMPtr<nsIURI> baseURI;
   if (mBaseURI) {
     baseURI = mBaseURI;
-  }
-  else if (doc) {
+  } else if (doc) {
     baseURI = doc->GetBaseURI();
   }
 
   rv = NS_NewURI(getter_AddRefs(uri), url, nullptr, baseURI);
-  if (NS_FAILED(rv)) return rv;
+  if (NS_FAILED(rv))
+    return rv;
 
   rv = CheckInnerWindowCorrectness();
   NS_ENSURE_SUCCESS(rv, rv);
   int16_t shouldLoad = nsIContentPolicy::ACCEPT;
-  rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XMLHTTPREQUEST,
-                                 uri,
-                                 mPrincipal,
-                                 doc,
-                                 EmptyCString(), //mime guess
-                                 nullptr,         //extra
-                                 &shouldLoad,
-                                 nsContentUtils::GetContentPolicy(),
-                                 nsContentUtils::GetSecurityManager());
-  if (NS_FAILED(rv)) return rv;
+  rv =
+    NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XMLHTTPREQUEST, uri,
+                              mPrincipal, doc, EmptyCString(), // mime guess
+                              nullptr, // extra
+                              &shouldLoad, nsContentUtils::GetContentPolicy(),
+                              nsContentUtils::GetSecurityManager());
+  if (NS_FAILED(rv))
+    return rv;
   if (NS_CP_REJECTED(shouldLoad)) {
     // Disallowed by content policy
     return NS_ERROR_CONTENT_BLOCKED;
   }
 
   // XXXbz this is wrong: we should only be looking at whether
   // user/password were passed, not at the values!  See bug 759624.
   if (user.WasPassed() && !user.Value().IsEmpty()) {
@@ -1719,27 +1687,24 @@ nsXMLHttpRequest::Open(const nsACString&
   nsCOMPtr<nsIContentSecurityPolicy> csp;
   rv = mPrincipal->GetCsp(getter_AddRefs(csp));
   NS_ENSURE_SUCCESS(rv, rv);
   if (csp) {
     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
     channelPolicy->SetContentSecurityPolicy(csp);
     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_XMLHTTPREQUEST);
   }
-  rv = NS_NewChannel(getter_AddRefs(mChannel),
-                     uri,
-                     nullptr,                    // ioService
-                     loadGroup,
-                     nullptr,                    // callbacks
-                     nsIRequest::LOAD_BACKGROUND,
-                     channelPolicy);
-  if (NS_FAILED(rv)) return rv;
-
-  mState &= ~(XML_HTTP_REQUEST_USE_XSITE_AC |
-              XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
+  rv = NS_NewChannel(getter_AddRefs(mChannel), uri, nullptr, // ioService
+                     loadGroup, nullptr,                     // callbacks
+                     nsIRequest::LOAD_BACKGROUND, channelPolicy);
+  if (NS_FAILED(rv))
+    return rv;
+
+  mState &=
+    ~(XML_HTTP_REQUEST_USE_XSITE_AC | XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
 
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
   if (httpChannel) {
     rv = httpChannel->SetRequestMethod(method);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Set the initiator type
     nsCOMPtr<nsITimedChannel> timedChannel(do_QueryInterface(httpChannel));
@@ -1752,26 +1717,25 @@ nsXMLHttpRequest::Open(const nsACString&
 
   return rv;
 }
 
 /*
  * "Copy" from a stream.
  */
 NS_METHOD
-nsXMLHttpRequest::StreamReaderFunc(nsIInputStream* in,
-                                   void* closure,
+nsXMLHttpRequest::StreamReaderFunc(nsIInputStream* in, void* closure,
                                    const char* fromRawSegment,
-                                   uint32_t toOffset,
-                                   uint32_t count,
-                                   uint32_t *writeCount)
+                                   uint32_t toOffset, uint32_t count,
+                                   uint32_t* writeCount)
 {
   nsXMLHttpRequest* xmlHttpRequest = static_cast<nsXMLHttpRequest*>(closure);
   if (!xmlHttpRequest || !writeCount) {
-    NS_WARNING("XMLHttpRequest cannot read from stream: no closure or writeCount");
+    NS_WARNING(
+      "XMLHttpRequest cannot read from stream: no closure or writeCount");
     return NS_ERROR_FAILURE;
   }
 
   nsresult rv = NS_OK;
 
   if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
     if (!xmlHttpRequest->mDOMFile) {
@@ -1779,58 +1743,65 @@ nsXMLHttpRequest::StreamReaderFunc(nsIIn
         xmlHttpRequest->mBlobSet = new BlobSet();
       }
       rv = xmlHttpRequest->mBlobSet->AppendVoidPtr(fromRawSegment, count);
     }
     // Clear the cache so that the blob size is updated.
     if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
       xmlHttpRequest->mResponseBlob = nullptr;
     }
-  } else if ((xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
+  } else if ((xmlHttpRequest->mResponseType ==
+                XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
               !xmlHttpRequest->mIsMappedArrayBuffer) ||
-             xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
-    // get the initial capacity to something reasonable to avoid a bunch of reallocs right
+             xmlHttpRequest->mResponseType ==
+               XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
+    // get the initial capacity to something reasonable to avoid a bunch of
+    // reallocs right
     // at the start
     if (xmlHttpRequest->mArrayBufferBuilder.capacity() == 0)
-      xmlHttpRequest->mArrayBufferBuilder.setCapacity(PR_MAX(count, XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE));
-
-    xmlHttpRequest->mArrayBufferBuilder.append(reinterpret_cast<const uint8_t*>(fromRawSegment), count,
-                                               XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH);
+      xmlHttpRequest->mArrayBufferBuilder.setCapacity(
+        PR_MAX(count, XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE));
+
+    xmlHttpRequest->mArrayBufferBuilder.append(
+      reinterpret_cast<const uint8_t*>(fromRawSegment), count,
+      XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH);
   } else if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT &&
              xmlHttpRequest->mResponseXML) {
     // Copy for our own use
     uint32_t previousLength = xmlHttpRequest->mResponseBody.Length();
-    xmlHttpRequest->mResponseBody.Append(fromRawSegment,count);
+    xmlHttpRequest->mResponseBody.Append(fromRawSegment, count);
     if (count > 0 && xmlHttpRequest->mResponseBody.Length() == previousLength) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
   } else if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_TEXT ||
              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_JSON ||
-             xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
+             xmlHttpRequest->mResponseType ==
+               XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
     NS_ASSERTION(!xmlHttpRequest->mResponseXML,
                  "We shouldn't be parsing a doc here");
     xmlHttpRequest->AppendToResponseText(fromRawSegment, count);
   }
 
   if (xmlHttpRequest->mState & XML_HTTP_REQUEST_PARSEBODY) {
     // Give the same data to the parser.
 
     // We need to wrap the data in a new lightweight stream and pass that
     // to the parser, because calling ReadSegments() recursively on the same
     // stream is not supported.
     nsCOMPtr<nsIInputStream> copyStream;
-    rv = NS_NewByteInputStream(getter_AddRefs(copyStream), fromRawSegment, count);
+    rv =
+      NS_NewByteInputStream(getter_AddRefs(copyStream), fromRawSegment, count);
 
     if (NS_SUCCEEDED(rv) && xmlHttpRequest->mXMLParserStreamListener) {
       NS_ASSERTION(copyStream, "NS_NewByteInputStream lied");
-      nsresult parsingResult = xmlHttpRequest->mXMLParserStreamListener
-                                  ->OnDataAvailable(xmlHttpRequest->mChannel,
-                                                    xmlHttpRequest->mContext,
-                                                    copyStream, toOffset, count);
+      nsresult parsingResult =
+        xmlHttpRequest->mXMLParserStreamListener->OnDataAvailable(
+          xmlHttpRequest->mChannel, xmlHttpRequest->mContext, copyStream,
+          toOffset, count);
 
       // No use to continue parsing if we failed here, but we
       // should still finish reading the stream
       if (NS_FAILED(parsingResult)) {
         xmlHttpRequest->mState &= ~XML_HTTP_REQUEST_PARSEBODY;
       }
     }
   }
@@ -1839,17 +1810,18 @@ nsXMLHttpRequest::StreamReaderFunc(nsIIn
     *writeCount = count;
   } else {
     *writeCount = 0;
   }
 
   return rv;
 }
 
-bool nsXMLHttpRequest::CreateDOMFile(nsIRequest *request)
+bool
+nsXMLHttpRequest::CreateDOMFile(nsIRequest* request)
 {
   nsCOMPtr<nsIFile> file;
   nsCOMPtr<nsIFileChannel> fc = do_QueryInterface(request);
   if (fc) {
     fc->GetFile(getter_AddRefs(file));
   }
 
   if (!file)
@@ -1861,31 +1833,31 @@ bool nsXMLHttpRequest::CreateDOMFile(nsI
   mDOMFile =
     new nsDOMFileFile(file, EmptyString(), NS_ConvertASCIItoUTF16(contentType));
   mBlobSet = nullptr;
   NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
   return true;
 }
 
 NS_IMETHODIMP
-nsXMLHttpRequest::OnDataAvailable(nsIRequest *request,
-                                  nsISupports *ctxt,
-                                  nsIInputStream *inStr,
-                                  uint64_t sourceOffset,
+nsXMLHttpRequest::OnDataAvailable(nsIRequest* request, nsISupports* ctxt,
+                                  nsIInputStream* inStr, uint64_t sourceOffset,
                                   uint32_t count)
 {
   NS_ENSURE_ARG_POINTER(inStr);
 
-  NS_ABORT_IF_FALSE(mContext.get() == ctxt,"start context different from OnDataAvailable context");
+  NS_ABORT_IF_FALSE(mContext.get() == ctxt,
+                    "start context different from OnDataAvailable context");
 
   mProgressSinceLastProgressEvent = true;
 
   bool cancelable = false;
   if ((mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
-       mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) && !mDOMFile) {
+       mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) &&
+      !mDOMFile) {
     cancelable = CreateDOMFile(request);
     // The nsIStreamListener contract mandates us
     // to read from the stream before returning.
   }
 
   uint32_t totalRead;
   nsresult rv = inStr->ReadSegments(nsXMLHttpRequest::StreamReaderFunc,
                                     (void*)this, count, &totalRead);
@@ -1896,28 +1868,28 @@ nsXMLHttpRequest::OnDataAvailable(nsIReq
     mDOMFile->GetSize(&mLoadTransferred);
     ChangeState(XML_HTTP_REQUEST_LOADING);
     return request->Cancel(NS_OK);
   }
 
   mLoadTransferred += totalRead;
 
   ChangeState(XML_HTTP_REQUEST_LOADING);
-  
+
   MaybeDispatchProgressEvents(false);
 
   return NS_OK;
 }
 
 /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
 NS_IMETHODIMP
-nsXMLHttpRequest::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
+nsXMLHttpRequest::OnStartRequest(nsIRequest* request, nsISupports* ctxt)
 {
   PROFILER_LABEL("nsXMLHttpRequest", "OnStartRequest",
-    js::ProfileEntry::Category::NETWORK);
+                 js::ProfileEntry::Category::NETWORK);
 
   nsresult rv = NS_OK;
   if (!mFirstStartRequestSeen && mRequestObserver) {
     mFirstStartRequestSeen = true;
     mRequestObserver->OnStartRequest(request, ctxt);
   }
 
   if (request != mChannel) {
@@ -1972,34 +1944,35 @@ nsXMLHttpRequest::OnStartRequest(nsIRequ
     }
     if (mUploadTransferred < mUploadTotal) {
       mUploadTransferred = mUploadTotal;
       mProgressSinceLastProgressEvent = true;
       mUploadLengthComputable = true;
       MaybeDispatchProgressEvents(true);
     }
     mUploadComplete = true;
-    DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOAD_STR),
-                          true, mUploadTotal, mUploadTotal);
+    DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOAD_STR), true,
+                          mUploadTotal, mUploadTotal);
   }
 
   mContext = ctxt;
   mState |= XML_HTTP_REQUEST_PARSEBODY;
   ChangeState(XML_HTTP_REQUEST_HEADERS_RECEIVED);
 
   ResetResponse();
 
   if (!mOverrideMimeType.IsEmpty()) {
     channel->SetContentType(NS_ConvertUTF16toUTF8(mOverrideMimeType));
   }
 
   DetectCharset();
 
   // Set up arraybuffer
-  if (mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER && NS_SUCCEEDED(status)) {
+  if (mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
+      NS_SUCCEEDED(status)) {
     if (mIsMappedArrayBuffer) {
       nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(channel);
       if (jarChannel) {
         nsCOMPtr<nsIURI> uri;
         rv = channel->GetURI(getter_AddRefs(uri));
         if (NS_SUCCEEDED(rv)) {
           nsAutoCString file;
           nsAutoCString scheme;
@@ -2015,37 +1988,37 @@ nsXMLHttpRequest::OnStartRequest(nsIRequ
             }
           }
           nsCOMPtr<nsIFile> jarFile;
           jarChannel->GetJarFile(getter_AddRefs(jarFile));
           rv = mArrayBufferBuilder.mapToFileInPackage(file, jarFile);
           if (NS_WARN_IF(NS_FAILED(rv))) {
             mIsMappedArrayBuffer = false;
           } else {
-            channel->SetContentType(NS_LITERAL_CSTRING("application/mem-mapped"));
+            channel->SetContentType(
+              NS_LITERAL_CSTRING("application/mem-mapped"));
           }
         }
       }
     }
     // If memory mapping failed, mIsMappedArrayBuffer would be set to false,
     // and we want it fallback to the malloc way.
     if (!mIsMappedArrayBuffer) {
       int64_t contentLength;
       rv = channel->GetContentLength(&contentLength);
-      if (NS_SUCCEEDED(rv) &&
-          contentLength > 0 &&
+      if (NS_SUCCEEDED(rv) && contentLength > 0 &&
           contentLength < XML_HTTP_REQUEST_MAX_CONTENT_LENGTH_PREALLOCATE) {
         mArrayBufferBuilder.setCapacity(static_cast<int32_t>(contentLength));
       }
     }
   }
 
   // Set up responseXML
   bool parseBody = mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
-                     mResponseType == XML_HTTP_RESPONSE_TYPE_DOCUMENT;
+                   mResponseType == XML_HTTP_RESPONSE_TYPE_DOCUMENT;
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
   if (parseBody && httpChannel) {
     nsAutoCString method;
     httpChannel->GetRequestMethod(method);
     parseBody = !method.EqualsLiteral("HEAD");
   }
 
   mIsHtml = false;
@@ -2099,21 +2072,20 @@ nsXMLHttpRequest::OnStartRequest(nsIRequ
 
     // Create an empty document from it.  Here we have to cheat a little bit...
     // Setting the base URI to |baseURI| won't work if the document has a null
     // principal, so use mPrincipal when creating the document, then reset the
     // principal.
     const nsAString& emptyStr = EmptyString();
     nsCOMPtr<nsIDOMDocument> responseDoc;
     nsIGlobalObject* global = DOMEventTargetHelper::GetParentObject();
-    rv = NS_NewDOMDocument(getter_AddRefs(responseDoc),
-                           emptyStr, emptyStr, nullptr, docURI,
-                           baseURI, mPrincipal, true, global,
-                           mIsHtml ? DocumentFlavorHTML :
-                                     DocumentFlavorLegacyGuess);
+    rv = NS_NewDOMDocument(getter_AddRefs(responseDoc), emptyStr, emptyStr,
+                           nullptr, docURI, baseURI, mPrincipal, true, global,
+                           mIsHtml ? DocumentFlavorHTML
+                                   : DocumentFlavorLegacyGuess);
     NS_ENSURE_SUCCESS(rv, rv);
     mResponseXML = do_QueryInterface(responseDoc);
     mResponseXML->SetPrincipal(documentPrincipal);
     mResponseXML->SetChromeXHRDocURI(chromeXHRDocURI);
     mResponseXML->SetChromeXHRDocBaseURI(chromeXHRDocBaseURI);
 
     if (nsContentUtils::IsSystemPrincipal(mPrincipal)) {
       mResponseXML->ForceEnableXULXBL();
@@ -2125,43 +2097,44 @@ nsXMLHttpRequest::OnStartRequest(nsIRequ
         htmlDoc->DisableCookieAccess();
       }
     }
 
     nsCOMPtr<nsIStreamListener> listener;
     nsCOMPtr<nsILoadGroup> loadGroup;
     channel->GetLoadGroup(getter_AddRefs(loadGroup));
 
-    rv = mResponseXML->StartDocumentLoad(kLoadAsData, channel, loadGroup,
-                                         nullptr, getter_AddRefs(listener),
-                                         !(mState & XML_HTTP_REQUEST_USE_XSITE_AC));
+    rv = mResponseXML->StartDocumentLoad(
+      kLoadAsData, channel, loadGroup, nullptr, getter_AddRefs(listener),
+      !(mState & XML_HTTP_REQUEST_USE_XSITE_AC));
     NS_ENSURE_SUCCESS(rv, rv);
 
     mXMLParserStreamListener = listener;
     rv = mXMLParserStreamListener->OnStartRequest(request, ctxt);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // We won't get any progress events anyway if we didn't have progress
   // events when starting the request - so maybe no need to start timer here.
-  if (NS_SUCCEEDED(rv) &&
-      (mState & XML_HTTP_REQUEST_ASYNC) &&
+  if (NS_SUCCEEDED(rv) && (mState & XML_HTTP_REQUEST_ASYNC) &&
       HasListenersFor(nsGkAtoms::onprogress)) {
     StartProgressEventTimer();
   }
 
   return NS_OK;
 }
 
-/* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status, in wstring statusArg); */
+/* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult
+ * status, in wstring statusArg); */
 NS_IMETHODIMP
-nsXMLHttpRequest::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
+nsXMLHttpRequest::OnStopRequest(nsIRequest* request, nsISupports* ctxt,
+                                nsresult status)
 {
   PROFILER_LABEL("nsXMLHttpRequest", "OnStopRequest",
-    js::ProfileEntry::Category::NETWORK);
+                 js::ProfileEntry::Category::NETWORK);
 
   if (request != mChannel) {
     // Can this still happen?
     return NS_OK;
   }
 
   mWaitingForOnStopRequest = false;
 
@@ -2172,17 +2145,17 @@ nsXMLHttpRequest::OnStopRequest(nsIReque
   }
 
   // make sure to notify the listener if we were aborted
   // XXX in fact, why don't we do the cleanup below in this case??
   // XML_HTTP_REQUEST_UNSENT is for abort calls.  See OnStartRequest above.
   if ((mState & XML_HTTP_REQUEST_UNSENT) ||
       (mState & XML_HTTP_REQUEST_TIMED_OUT)) {
     if (mXMLParserStreamListener)
-      (void) mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
+      (void)mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
     return NS_OK;
   }
 
   // Is this good enough here?
   if (mState & XML_HTTP_REQUEST_PARSEBODY && mXMLParserStreamListener) {
     mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
   }
 
@@ -2248,31 +2221,29 @@ nsXMLHttpRequest::OnStopRequest(nsIReque
 
     mErrorLoad = true;
     mResponseXML = nullptr;
   }
 
   // If we're uninitialized at this point, we encountered an error
   // earlier and listeners have already been notified. Also we do
   // not want to do this if we already completed.
-  if (mState & (XML_HTTP_REQUEST_UNSENT |
-                XML_HTTP_REQUEST_DONE)) {
+  if (mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_DONE)) {
     return NS_OK;
   }
 
   if (!mResponseXML) {
     ChangeStateToDone();
     return NS_OK;
   }
   if (mIsHtml) {
     NS_ASSERTION(!(mState & XML_HTTP_REQUEST_SYNCLOOPING),
-      "We weren't supposed to support HTML parsing with XHR!");
+                 "We weren't supposed to support HTML parsing with XHR!");
     nsCOMPtr<EventTarget> eventTarget = do_QueryInterface(mResponseXML);
-    EventListenerManager* manager =
-      eventTarget->GetOrCreateListenerManager();
+    EventListenerManager* manager = eventTarget->GetOrCreateListenerManager();
     manager->AddEventListenerByType(new nsXHRParseEndListener(this),
                                     NS_LITERAL_STRING("DOMContentLoaded"),
                                     TrustedEventsAtSystemGroupBubble());
     return NS_OK;
   }
   // We might have been sent non-XML data. If that was the case,
   // we should null out the document member. The idea in this
   // check here is that if there is no document element it is not
@@ -2295,62 +2266,58 @@ nsXMLHttpRequest::ChangeStateToDone()
 
   ChangeState(XML_HTTP_REQUEST_DONE, true);
   if (mTimeoutTimer) {
     mTimeoutTimer->Cancel();
   }
 
   NS_NAMED_LITERAL_STRING(errorStr, ERROR_STR);
   NS_NAMED_LITERAL_STRING(loadStr, LOAD_STR);
-  DispatchProgressEvent(this,
-                        mErrorLoad ? errorStr : loadStr,
-                        !mErrorLoad,
-                        mLoadTransferred,
-                        mErrorLoad ? 0 : mLoadTransferred);
+  DispatchProgressEvent(this, mErrorLoad ? errorStr : loadStr, !mErrorLoad,
+                        mLoadTransferred, mErrorLoad ? 0 : mLoadTransferred);
   if (mErrorLoad && mUpload && !mUploadComplete) {
-    DispatchProgressEvent(mUpload, errorStr, true,
-                          mUploadTransferred, mUploadTotal);
+    DispatchProgressEvent(mUpload, errorStr, true, mUploadTransferred,
+                          mUploadTotal);
   }
 
   if (mErrorLoad) {
     // By nulling out channel here we make it so that Send() can test
     // for that and throw. Also calling the various status
     // methods/members will not throw.
     // This matches what IE does.
     mChannel = nullptr;
     mCORSPreflightChannel = nullptr;
   }
 }
 
 NS_IMETHODIMP
-nsXMLHttpRequest::SendAsBinary(const nsAString &aBody)
+nsXMLHttpRequest::SendAsBinary(const nsAString& aBody)
 {
   ErrorResult rv;
   SendAsBinary(aBody, rv);
   return rv.ErrorCode();
 }
 
 void
-nsXMLHttpRequest::SendAsBinary(const nsAString &aBody,
-                               ErrorResult& aRv)
+nsXMLHttpRequest::SendAsBinary(const nsAString& aBody, ErrorResult& aRv)
 {
-  char *data = static_cast<char*>(NS_Alloc(aBody.Length() + 1));
+  char* data = static_cast<char*>(NS_Alloc(aBody.Length() + 1));
   if (!data) {
     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
     return;
   }
 
   if (GetOwner() && GetOwner()->GetExtantDoc()) {
     GetOwner()->GetExtantDoc()->WarnOnceAbout(nsIDocument::eSendAsBinary);
   }
 
   nsAString::const_iterator iter, end;
   aBody.BeginReading(iter);
   aBody.EndReading(end);
-  char *p = data;
+  char* p = data;
   while (iter != end) {
     if (*iter & 0xFF00) {
       NS_Free(data);
       aRv.Throw(NS_ERROR_DOM_INVALID_CHARACTER_ERR);
       return;
     }
     *p++ = static_cast<char>(*iter++);
   }
@@ -2379,18 +2346,17 @@ GetRequestBody(nsIDOMDocument* aDoc, nsI
                uint64_t* aContentLength, nsACString& aContentType,
                nsACString& aCharset)
 {
   aContentType.AssignLiteral("application/xml");
   nsAutoString inputEncoding;
   aDoc->GetInputEncoding(inputEncoding);
   if (!DOMStringIsNull(inputEncoding)) {
     CopyUTF16toUTF8(inputEncoding, aCharset);
-  }
-  else {
+  } else {
     aCharset.AssignLiteral("UTF-8");
   }
 
   // Serialize to a stream so that the encoding used will
   // match the document's.
   nsresult rv;
   nsCOMPtr<nsIDOMSerializer> serializer =
     do_CreateInstance(NS_XMLSERIALIZER_CONTRACTID, &rv);
@@ -2443,20 +2409,22 @@ GetRequestBody(nsIInputStream* aStream, 
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ADDREF(*aResult = aStream);
 
   return NS_OK;
 }
 
 static nsresult
-GetRequestBody(nsIXHRSendable* aSendable, nsIInputStream** aResult, uint64_t* aContentLength,
-               nsACString& aContentType, nsACString& aCharset)
+GetRequestBody(nsIXHRSendable* aSendable, nsIInputStream** aResult,
+               uint64_t* aContentLength, nsACString& aContentType,
+               nsACString& aCharset)
 {
-  return aSendable->GetSendInfo(aResult, aContentLength, aContentType, aCharset);
+  return aSendable->GetSendInfo(aResult, aContentLength, aContentType,
+                                aCharset);
 }
 
 // Used for array buffers and array buffer views
 static nsresult
 GetRequestBody(const uint8_t* aData, uint32_t aDataLength,
                nsIInputStream** aResult, uint64_t* aContentLength,
                nsACString& aContentType, nsACString& aCharset)
 {
@@ -2472,168 +2440,168 @@ GetRequestBody(const uint8_t* aData, uin
   NS_ENSURE_SUCCESS(rv, rv);
 
   stream.forget(aResult);
 
   return NS_OK;
 }
 
 static nsresult
-GetRequestBody(nsIVariant* aBody, nsIInputStream** aResult, uint64_t* aContentLength,
-               nsACString& aContentType, nsACString& aCharset)
+GetRequestBody(nsIVariant* aBody, nsIInputStream** aResult,
+               uint64_t* aContentLength, nsACString& aContentType,
+               nsACString& aCharset)
 {
   *aResult = nullptr;
 
   uint16_t dataType;
   nsresult rv = aBody->GetDataType(&dataType);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (dataType == nsIDataType::VTYPE_INTERFACE ||
       dataType == nsIDataType::VTYPE_INTERFACE_IS) {
     nsCOMPtr<nsISupports> supports;
-    nsID *iid;
+    nsID* iid;
     rv = aBody->GetAsInterface(&iid, getter_AddRefs(supports));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsMemory::Free(iid);
 
     // document?
     nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(supports);
     if (doc) {
-      return GetRequestBody(doc, aResult, aContentLength, aContentType, aCharset);
+      return GetRequestBody(doc, aResult, aContentLength, aContentType,
+                            aCharset);
     }
 
     // nsISupportsString?
     nsCOMPtr<nsISupportsString> wstr = do_QueryInterface(supports);
     if (wstr) {
       nsAutoString string;
       wstr->GetData(string);
 
-      return GetRequestBody(string, aResult, aContentLength, aContentType, aCharset);
+      return GetRequestBody(string, aResult, aContentLength, aContentType,
+                            aCharset);
     }
 
     // nsIInputStream?
     nsCOMPtr<nsIInputStream> stream = do_QueryInterface(supports);
     if (stream) {
-      return GetRequestBody(stream, aResult, aContentLength, aContentType, aCharset);
+      return GetRequestBody(stream, aResult, aContentLength, aContentType,
+                            aCharset);
     }
 
     // nsIXHRSendable?
     nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(supports);
     if (sendable) {
-      return GetRequestBody(sendable, aResult, aContentLength, aContentType, aCharset);
+      return GetRequestBody(sendable, aResult, aContentLength, aContentType,
+                            aCharset);
     }
 
     // ArrayBuffer?
     AutoSafeJSContext cx;
     JS::Rooted<JS::Value> realVal(cx);
 
     nsresult rv = aBody->GetAsJSVal(&realVal);
     if (NS_SUCCEEDED(rv) && !realVal.isPrimitive()) {
       JS::Rooted<JSObject*> obj(cx, realVal.toObjectOrNull());
       if (JS_IsArrayBufferObject(obj)) {
-          ArrayBuffer buf(obj);
-          buf.ComputeLengthAndData();
-          return GetRequestBody(buf.Data(), buf.Length(), aResult,
-                                aContentLength, aContentType, aCharset);
+        ArrayBuffer buf(obj);
+        buf.ComputeLengthAndData();
+        return GetRequestBody(buf.Data(), buf.Length(), aResult, aContentLength,
+                              aContentType, aCharset);
       }
     }
-  }
-  else if (dataType == nsIDataType::VTYPE_VOID ||
-           dataType == nsIDataType::VTYPE_EMPTY) {
+  } else if (dataType == nsIDataType::VTYPE_VOID ||
+             dataType == nsIDataType::VTYPE_EMPTY) {
     // Makes us act as if !aBody, don't upload anything
     aContentType.AssignLiteral("text/plain");
     aCharset.AssignLiteral("UTF-8");
     *aContentLength = 0;
 
     return NS_OK;
   }
 
   char16_t* data = nullptr;
   uint32_t len = 0;
   rv = aBody->GetAsWStringWithSize(&len, &data);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsString string;
   string.Adopt(data, len);
 
-  return GetRequestBody(string, aResult, aContentLength, aContentType, aCharset);
+  return GetRequestBody(string, aResult, aContentLength, aContentType,
+                        aCharset);
 }
 
 /* static */
 nsresult
 nsXMLHttpRequest::GetRequestBody(nsIVariant* aVariant,
                                  const Nullable<RequestBody>& aBody,
                                  nsIInputStream** aResult,
                                  uint64_t* aContentLength,
                                  nsACString& aContentType, nsACString& aCharset)
 {
   if (aVariant) {
-    return ::GetRequestBody(aVariant, aResult, aContentLength, aContentType, aCharset);
+    return ::GetRequestBody(aVariant, aResult, aContentLength, aContentType,
+                            aCharset);
   }
 
   const RequestBody& body = aBody.Value();
   RequestBody::Value value = body.GetValue();
   switch (body.GetType()) {
-    case nsXMLHttpRequest::RequestBody::ArrayBuffer:
-    {
-      const ArrayBuffer* buffer = value.mArrayBuffer;
-      buffer->ComputeLengthAndData();
-      return ::GetRequestBody(buffer->Data(), buffer->Length(), aResult,
-                              aContentLength, aContentType, aCharset);
-    }
-    case nsXMLHttpRequest::RequestBody::ArrayBufferView:
-    {
-      const ArrayBufferView* view = value.mArrayBufferView;
-      view->ComputeLengthAndData();
-      return ::GetRequestBody(view->Data(), view->Length(), aResult,
-                              aContentLength, aContentType, aCharset);
-    }
-    case nsXMLHttpRequest::RequestBody::Blob:
-    {
-      nsresult rv;
-      nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mBlob, &rv);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      return ::GetRequestBody(sendable, aResult, aContentLength, aContentType, aCharset);
-    }
-    case nsXMLHttpRequest::RequestBody::Document:
-    {
-      nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(value.mDocument);
-      return ::GetRequestBody(document, aResult, aContentLength, aContentType, aCharset);
-    }
-    case nsXMLHttpRequest::RequestBody::DOMString:
-    {
-      return ::GetRequestBody(*value.mString, aResult, aContentLength,
-                              aContentType, aCharset);
-    }
-    case nsXMLHttpRequest::RequestBody::FormData:
-    {
-      MOZ_ASSERT(value.mFormData);
-      return ::GetRequestBody(value.mFormData, aResult, aContentLength,
-                              aContentType, aCharset);
-    }
-    case nsXMLHttpRequest::RequestBody::InputStream:
-    {
-      return ::GetRequestBody(value.mStream, aResult, aContentLength,
-                              aContentType, aCharset);
-    }
-    default:
-    {
-      return NS_ERROR_FAILURE;
-    }
+  case nsXMLHttpRequest::RequestBody::ArrayBuffer: {
+    const ArrayBuffer* buffer = value.mArrayBuffer;
+    buffer->ComputeLengthAndData();
+    return ::GetRequestBody(buffer->Data(), buffer->Length(), aResult,
+                            aContentLength, aContentType, aCharset);
+  }
+  case nsXMLHttpRequest::RequestBody::ArrayBufferView: {
+    const ArrayBufferView* view = value.mArrayBufferView;
+    view->ComputeLengthAndData();
+    return ::GetRequestBody(view->Data(), view->Length(), aResult,
+                            aContentLength, aContentType, aCharset);
+  }
+  case nsXMLHttpRequest::RequestBody::Blob: {
+    nsresult rv;
+    nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mBlob, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return ::GetRequestBody(sendable, aResult, aContentLength, aContentType,
+                            aCharset);
+  }
+  case nsXMLHttpRequest::RequestBody::Document: {
+    nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(value.mDocument);
+    return ::GetRequestBody(document, aResult, aContentLength, aContentType,
+                            aCharset);
+  }
+  case nsXMLHttpRequest::RequestBody::DOMString: {
+    return ::GetRequestBody(*value.mString, aResult, aContentLength,
+                            aContentType, aCharset);
+  }
+  case nsXMLHttpRequest::RequestBody::FormData: {
+    MOZ_ASSERT(value.mFormData);
+    return ::GetRequestBody(value.mFormData, aResult, aContentLength,
+                            aContentType, aCharset);
+  }
+  case nsXMLHttpRequest::RequestBody::InputStream: {
+    return ::GetRequestBody(value.mStream, aResult, aContentLength,
+                            aContentType, aCharset);
+  }
+  default: {
+    return NS_ERROR_FAILURE;
+  }
   }
 
   NS_NOTREACHED("Default cases exist for a reason");
   return NS_OK;
 }
 
 /* void send (in nsIVariant aBody); */
 NS_IMETHODIMP
-nsXMLHttpRequest::Send(nsIVariant *aBody)
+nsXMLHttpRequest::Send(nsIVariant* aBody)
 {
   return Send(aBody, Nullable<RequestBody>());
 }
 
 nsresult
 nsXMLHttpRequest::Send(nsIVariant* aVariant, const Nullable<RequestBody>& aBody)
 {
   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
@@ -2646,17 +2614,16 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
     return NS_ERROR_FAILURE;
   }
 
   // Make sure we've been opened
   if (!mChannel || !(XML_HTTP_REQUEST_OPENED & mState)) {
     return NS_ERROR_NOT_INITIALIZED;
   }
 
-
   // nsIRequest::LOAD_BACKGROUND prevents throbber from becoming active, which
   // in turn keeps STOP button from becoming active.  If the consumer passed in
   // a progress event handler we must load with nsIRequest::LOAD_NORMAL or
   // necko won't generate any progress notifications.
   if (HasListenersFor(nsGkAtoms::onprogress) ||
       (mUpload && mUpload->HasListenersFor(nsGkAtoms::onprogress))) {
     nsLoadFlags loadFlags;
     mChannel->GetLoadFlags(&loadFlags);
@@ -2670,17 +2637,18 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
   //     an asynchronous call.
 
   // Ignore argument if method is GET, there is no point in trying to
   // upload anything
   nsAutoCString method;
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 
   if (httpChannel) {
-    httpChannel->GetRequestMethod(method); // If GET, method name will be uppercase
+    httpChannel->GetRequestMethod(
+      method); // If GET, method name will be uppercase
 
     if (!IsSystemXHR()) {
       // Get the referrer for the request.
       //
       // If it weren't for history.push/replaceState, we could just use the
       // principal's URI here.  But since we want changes to the URI effected
       // by push/replaceState to be reflected in the XHR referrer, we have to
       // be more clever.
@@ -2723,25 +2691,27 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
 
     // Some extensions override the http protocol handler and provide their own
     // implementation. The channels returned from that implementation doesn't
     // seem to always implement the nsIUploadChannel2 interface, presumably
     // because it's a new interface.
     // Eventually we should remove this and simply require that http channels
     // implement the new interface.
     // See bug 529041
-    nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
-      do_QueryInterface(httpChannel);
+    nsCOMPtr<nsIUploadChannel2> uploadChannel2 = do_QueryInterface(httpChannel);
     if (!uploadChannel2) {
       nsCOMPtr<nsIConsoleService> consoleService =
         do_GetService(NS_CONSOLESERVICE_CONTRACTID);
       if (consoleService) {
-        consoleService->LogStringMessage(NS_LITERAL_STRING(
-          "Http channel implementation doesn't support nsIUploadChannel2. An extension has supplied a non-functional http protocol handler. This will break behavior and in future releases not work at all."
-                                                           ).get());
+        consoleService->LogStringMessage(
+          NS_LITERAL_STRING("Http channel implementation doesn't support "
+                            "nsIUploadChannel2. An extension has supplied a "
+                            "non-functional http protocol handler. This will "
+                            "break behavior and in future releases not work at "
+                            "all.").get());
       }
     }
   }
 
   mUploadTransferred = 0;
   mUploadTotal = 0;
   // By default we don't have any upload, so mark upload complete.
   mUploadComplete = true;
@@ -2759,19 +2729,18 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
     rv = GetRequestBody(aVariant, aBody, getter_AddRefs(postDataStream),
                         &mUploadTotal, defaultContentType, charset);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (postDataStream) {
       // If no content type header was set by the client, we set it to
       // application/xml.
       nsAutoCString contentType;
-      if (NS_FAILED(httpChannel->
-                      GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
-                                       contentType)) ||
+      if (NS_FAILED(httpChannel->GetRequestHeader(
+            NS_LITERAL_CSTRING("Content-Type"), contentType)) ||
           contentType.IsEmpty()) {
         contentType = defaultContentType;
       }
 
       // We don't want to set a charset for streams.
       if (!charset.IsEmpty()) {
         nsAutoCString specifiedCharset;
         bool haveCharset;
@@ -2781,18 +2750,18 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
                                               &charsetEnd);
         if (NS_SUCCEEDED(rv)) {
           // special case: the extracted charset is quoted with single quotes
           // -- for the purpose of preserving what was set we want to handle
           // them as delimiters (although they aren't really)
           if (specifiedCharset.Length() >= 2 &&
               specifiedCharset.First() == '\'' &&
               specifiedCharset.Last() == '\'') {
-            specifiedCharset = Substring(specifiedCharset, 1,
-                                         specifiedCharset.Length() - 2);
+            specifiedCharset =
+              Substring(specifiedCharset, 1, specifiedCharset.Length() - 2);
           }
 
           // If the content-type the page set already has a charset parameter,
           // and it's the same charset, up to case, as |charset|, just send the
           // page-set content-type header.  Apparently at least
           // google-web-toolkit is broken and relies on the exact case of its
           // charset parameter, which makes things break if we use |charset|
           // (which is always a fully resolved charset per our charset alias
@@ -2807,60 +2776,61 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
         }
       }
 
       // If necessary, wrap the stream in a buffered stream so as to guarantee
       // support for our upload when calling ExplicitSetUploadStream.
       if (!NS_InputStreamIsBuffered(postDataStream)) {
         nsCOMPtr<nsIInputStream> bufferedStream;
         rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream),
-                                       postDataStream, 
-                                       4096);
+                                       postDataStream, 4096);
         NS_ENSURE_SUCCESS(rv, rv);
 
         postDataStream = bufferedStream;
       }
 
       mUploadComplete = false;
 
       // We want to use a newer version of the upload channel that won't
       // ignore the necessary headers for an empty Content-Type.
-      nsCOMPtr<nsIUploadChannel2> uploadChannel2(do_QueryInterface(httpChannel));
+      nsCOMPtr<nsIUploadChannel2> uploadChannel2(
+        do_QueryInterface(httpChannel));
       // This assertion will fire if buggy extensions are installed
       NS_ASSERTION(uploadChannel2, "http must support nsIUploadChannel2");
       if (uploadChannel2) {
-          uploadChannel2->ExplicitSetUploadStream(postDataStream, contentType,
-                                                 mUploadTotal, method, false);
-      }
-      else {
+        uploadChannel2->ExplicitSetUploadStream(postDataStream, contentType,
+                                                mUploadTotal, method, false);
+      } else {
         // http channel doesn't support the new nsIUploadChannel2. Emulate
         // as best we can using nsIUploadChannel
         if (contentType.IsEmpty()) {
           contentType.AssignLiteral("application/octet-stream");
         }
         nsCOMPtr<nsIUploadChannel> uploadChannel =
           do_QueryInterface(httpChannel);
-        uploadChannel->SetUploadStream(postDataStream, contentType, mUploadTotal);
+        uploadChannel->SetUploadStream(postDataStream, contentType,
+                                       mUploadTotal);
         // Reset the method to its original value
         httpChannel->SetRequestMethod(method);
       }
     }
   }
 
   if (httpChannel) {
     nsAutoCString contentTypeHeader;
     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
                                        contentTypeHeader);
     if (NS_SUCCEEDED(rv)) {
       nsAutoCString contentType, charset;
       rv = NS_ParseContentType(contentTypeHeader, contentType, charset);
       NS_ENSURE_SUCCESS(rv, rv);
-  
+
       if (!contentType.LowerCaseEqualsLiteral("text/plain") &&
-          !contentType.LowerCaseEqualsLiteral("application/x-www-form-urlencoded") &&
+          !contentType.LowerCaseEqualsLiteral(
+             "application/x-www-form-urlencoded") &&
           !contentType.LowerCaseEqualsLiteral("multipart/form-data")) {
         mCORSUnsafeHeaders.AppendElement(NS_LITERAL_CSTRING("Content-Type"));
       }
     }
   }
 
   ResetResponse();
 
@@ -2872,18 +2842,18 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
   // Hook us up to listen to redirects and the like
   mChannel->GetNotificationCallbacks(getter_AddRefs(mNotificationCallbacks));
   mChannel->SetNotificationCallbacks(this);
 
   // Blocking gets are common enough out of XHR that we should mark
   // the channel slow by default for pipeline purposes
   AddLoadFlags(mChannel, nsIRequest::INHIBIT_PIPELINE);
 
-  nsCOMPtr<nsIHttpChannelInternal>
-    internalHttpChannel(do_QueryInterface(mChannel));
+  nsCOMPtr<nsIHttpChannelInternal> internalHttpChannel(
+    do_QueryInterface(mChannel));
   if (internalHttpChannel) {
     // we never let XHR be blocked by head CSS/JS loads to avoid
     // potential deadlock where server generation of CSS/JS requires
     // an XHR signal.
     internalHttpChannel->SetLoadUnblocked(true);
 
     // Disable Necko-internal response timeouts.
     internalHttpChannel->SetResponseTimeoutEnabled(false);
@@ -2893,78 +2863,72 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
   if (!IsSystemXHR()) {
     // Always create a nsCORSListenerProxy here even if it's
     // a same-origin request right now, since it could be redirected.
     nsRefPtr<nsCORSListenerProxy> corsListener =
       new nsCORSListenerProxy(listener, mPrincipal, withCredentials);
     rv = corsListener->Init(mChannel, true);
     NS_ENSURE_SUCCESS(rv, rv);
     listener = corsListener;
-  }
-  else {
+  } else {
     // Because of bug 682305, we can't let listener be the XHR object itself
     // because JS wouldn't be able to use it. So if we haven't otherwise
     // created a listener around 'this', do so now.
 
     listener = new nsStreamListenerWrapper(listener);
   }
 
   if (mIsAnon) {
     AddLoadFlags(mChannel, nsIRequest::LOAD_ANONYMOUS);
-  }
-  else {
+  } else {
     AddLoadFlags(mChannel, nsIChannel::LOAD_EXPLICIT_CREDENTIALS);
   }
 
   NS_ASSERTION(listener != this,
                "Using an object as a listener that can't be exposed to JS");
 
   // Bypass the network cache in cases where it makes no sense:
   // POST responses are always unique, and we provide no API that would
   // allow our consumers to specify a "cache key" to access old POST
   // responses, so they are not worth caching.
   if (method.EqualsLiteral("POST")) {
     AddLoadFlags(mChannel,
-        nsIRequest::LOAD_BYPASS_CACHE | nsIRequest::INHIBIT_CACHING);
+                 nsIRequest::LOAD_BYPASS_CACHE | nsIRequest::INHIBIT_CACHING);
   }
   // When we are sync loading, we need to bypass the local cache when it would
   // otherwise block us waiting for exclusive access to the cache.  If we don't
   // do this, then we could dead lock in some cases (see bug 309424).
   else if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
-    AddLoadFlags(mChannel,
-        nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY);
+    AddLoadFlags(mChannel, nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY);
   }
 
   // Since we expect XML data, set the type hint accordingly
   // if the channel doesn't know any content type.
   // This means that we always try to parse local files as XML
   // ignoring return value, as this is not critical
   nsAutoCString contentType;
   if (NS_FAILED(mChannel->GetContentType(contentType)) ||
-      contentType.IsEmpty() ||
-      contentType.Equals(UNKNOWN_CONTENT_TYPE)) {
+      contentType.IsEmpty() || contentType.Equals(UNKNOWN_CONTENT_TYPE)) {
     mChannel->SetContentType(NS_LITERAL_CSTRING("application/xml"));
   }
 
   // We're about to send the request.  Start our timeout.
   mRequestSentTime = PR_Now();
   StartTimeoutTimer();
 
   // Set up the preflight if needed
   if (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT) {
     // Check to see if this initial OPTIONS request has already been cached
     // in our special Access Control Cache.
 
-    rv = NS_StartCORSPreflight(mChannel, listener,
-                               mPrincipal, withCredentials,
+    rv = NS_StartCORSPreflight(mChannel, listener, mPrincipal, withCredentials,
                                mCORSUnsafeHeaders,
                                getter_AddRefs(mCORSPreflightChannel));
     NS_ENSURE_SUCCESS(rv, rv);
-  }
-  else {
+  } else {
     mIsMappedArrayBuffer = false;
     if (mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
         Preferences::GetBool("dom.mapped_arraybuffer.enabled", false)) {
       nsCOMPtr<nsIURI> uri;
       nsAutoCString scheme;
 
       rv = mChannel->GetURI(getter_AddRefs(uri));
       if (NS_SUCCEEDED(rv)) {
@@ -3012,17 +2976,17 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
     }
 
     ChangeState(XML_HTTP_REQUEST_SENT);
 
     {
       nsAutoSyncOperation sync(suspendedDoc);
       // Note, calling ChangeState may have cleared
       // XML_HTTP_REQUEST_SYNCLOOPING flag.
-      nsIThread *thread = NS_GetCurrentThread();
+      nsIThread* thread = NS_GetCurrentThread();
       while (mState & XML_HTTP_REQUEST_SYNCLOOPING) {
         if (!NS_ProcessNextEvent(thread)) {
           rv = NS_ERROR_UNEXPECTED;
           break;
         }
       }
     }
 
@@ -3030,29 +2994,29 @@ nsXMLHttpRequest::Send(nsIVariant* aVari
       suspendedDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents,
                                                          true);
     }
 
     if (resumeTimeoutRunnable) {
       NS_DispatchToCurrentThread(resumeTimeoutRunnable);
     }
   } else {
-    // Now that we've successfully opened the channel, we can change state.  Note
+    // Now that we've successfully opened the channel, we can change state. Note
     // that this needs to come after the AsyncOpen() and rv check, because this
     // can run script that would try to restart this request, and that could end
-    // up doing our AsyncOpen on a null channel if the reentered AsyncOpen fails.
+    // up doing our AsyncOpen on a null channel if the reentered AsyncOpen
+    // fails.
     ChangeState(XML_HTTP_REQUEST_SENT);
     if (mUpload && mUpload->HasListenersFor(nsGkAtoms::onprogress)) {
       StartProgressEventTimer();
     }
-    DispatchProgressEvent(this, NS_LITERAL_STRING(LOADSTART_STR), false,
-                          0, 0);
+    DispatchProgressEvent(this, NS_LITERAL_STRING(LOADSTART_STR), false, 0, 0);
     if (mUpload && !mUploadComplete) {
-      DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOADSTART_STR), true,
-                            0, mUploadTotal);
+      DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOADSTART_STR), true, 0,
+                            mUploadTotal);
     }
   }
 
   if (!mChannel) {
     return NS_ERROR_FAILURE;
   }
 
   return rv;
@@ -3078,17 +3042,17 @@ nsXMLHttpRequest::SetRequestHeader(const
 
   // Check that we haven't already opened the channel. We can't rely on
   // the channel throwing from mChannel->SetRequestHeader since we might
   // still be waiting for mCORSPreflightChannel to actually open mChannel
   if (mCORSPreflightChannel) {
     bool pending;
     nsresult rv = mCORSPreflightChannel->IsPending(&pending);
     NS_ENSURE_SUCCESS(rv, rv);
-    
+
     if (pending) {
       return NS_ERROR_IN_PROGRESS;
     }
   }
 
   if (!mChannel)             // open() initializes mChannel, and open()
     return NS_ERROR_FAILURE; // must be called before first setRequestHeader()
 
@@ -3102,22 +3066,28 @@ nsXMLHttpRequest::SetRequestHeader(const
   // or
   // 2 - we have not yet explicitly set that header; this allows web
   //     content to override default headers the first time they set them.
   bool mergeHeaders = true;
 
   // Prevent modification to certain HTTP headers (see bug 302263), unless
   // the executing script is privileged.
   bool isInvalidHeader = false;
-  static const char *kInvalidHeaders[] = {
-    "accept-charset", "accept-encoding", "access-control-request-headers",
-    "access-control-request-method", "connection", "content-length",
-    "cookie", "cookie2", "content-transfer-encoding", "date", "dnt",
-    "expect", "host", "keep-alive", "origin", "referer", "te", "trailer",
-    "transfer-encoding", "upgrade", "user-agent", "via"
+  static const char* kInvalidHeaders[] = {
+    "accept-charset",                 "accept-encoding",
+    "access-control-request-headers", "access-control-request-method",
+    "connection",                     "content-length",
+    "cookie",                         "cookie2",
+    "content-transfer-encoding",      "date",
+    "dnt",                            "expect",
+    "host",                           "keep-alive",
+    "origin",                         "referer",
+    "te",                             "trailer",
+    "transfer-encoding",              "upgrade",
+    "user-agent",                     "via"
   };
   uint32_t i;
   for (i = 0; i < ArrayLength(kInvalidHeaders); ++i) {
     if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
       isInvalidHeader = true;
       break;
     }
   }
@@ -3135,19 +3105,19 @@ nsXMLHttpRequest::SetRequestHeader(const
       NS_WARNING("refusing to set request header");
       return NS_OK;
     }
 
     // Check for dangerous cross-site headers
     bool safeHeader = IsSystemXHR();
     if (!safeHeader) {
       // Content-Type isn't always safe, but we'll deal with it in Send()
-      const char *kCrossOriginSafeHeaders[] = {
-        "accept", "accept-language", "content-language", "content-type",
-        "last-event-id"
+      const char* kCrossOriginSafeHeaders[] = {
+        "accept",       "accept-language", "content-language",
+        "content-type", "last-event-id"
       };
       for (i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
         if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
           safeHeader = true;
           break;
         }
       }
     }
@@ -3170,31 +3140,31 @@ nsXMLHttpRequest::SetRequestHeader(const
   }
 
   // Merge headers depending on what we decided above.
   nsresult rv = httpChannel->SetRequestHeader(header, value, mergeHeaders);
   if (rv == NS_ERROR_INVALID_ARG) {
     return NS_ERROR_DOM_SYNTAX_ERR;
   }
   if (NS_SUCCEEDED(rv)) {
-    // Remember that we've set this header, so subsequent set operations will merge values.
+    // Remember that we've set this header, so subsequent set operations will
+    // merge values.
     mAlreadySetHeaders.PutEntry(nsCString(header));
 
-    // We'll want to duplicate this header for any replacement channels (eg. on redirect)
-    RequestHeader reqHeader = {
-      nsCString(header), nsCString(value)
-    };
+    // We'll want to duplicate this header for any replacement channels (eg. on
+    // redirect)
+    RequestHeader reqHeader = { nsCString(header), nsCString(value) };
     mModifiedRequestHeaders.AppendElement(reqHeader);
   }
   return rv;
 }
 
 /* attribute unsigned long timeout; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetTimeout(uint32_t *aTimeout)
+nsXMLHttpRequest::GetTimeout(uint32_t* aTimeout)
 {
   *aTimeout = Timeout();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsXMLHttpRequest::SetTimeout(uint32_t aTimeout)
 {
@@ -3219,18 +3189,19 @@ nsXMLHttpRequest::SetTimeout(uint32_t aT
   if (mRequestSentTime) {
     StartTimeoutTimer();
   }
 }
 
 void
 nsXMLHttpRequest::StartTimeoutTimer()
 {
-  NS_ABORT_IF_FALSE(mRequestSentTime,
-                    "StartTimeoutTimer mustn't be called before the request was sent!");
+  NS_ABORT_IF_FALSE(
+    mRequestSentTime,
+    "StartTimeoutTimer mustn't be called before the request was sent!");
   if (mState & XML_HTTP_REQUEST_DONE) {
     // do nothing!
     return;
   }
 
   if (mTimeoutTimer) {
     mTimeoutTimer->Cancel();
   }
@@ -3240,25 +3211,23 @@ nsXMLHttpRequest::StartTimeoutTimer()
   }
 
   if (!mTimeoutTimer) {
     mTimeoutTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
   }
   uint32_t elapsed =
     (uint32_t)((PR_Now() - mRequestSentTime) / PR_USEC_PER_MSEC);
   mTimeoutTimer->InitWithCallback(
-    this,
-    mTimeoutMilliseconds > elapsed ? mTimeoutMilliseconds - elapsed : 0,
-    nsITimer::TYPE_ONE_SHOT
-  );
+    this, mTimeoutMilliseconds > elapsed ? mTimeoutMilliseconds - elapsed : 0,
+    nsITimer::TYPE_ONE_SHOT);
 }
 
 /* readonly attribute unsigned short readyState; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetReadyState(uint16_t *aState)
+nsXMLHttpRequest::GetReadyState(uint16_t* aState)
 {
   *aState = ReadyState();
   return NS_OK;
 }
 
 uint16_t
 nsXMLHttpRequest::ReadyState()
 {
@@ -3284,17 +3253,17 @@ NS_IMETHODIMP
 nsXMLHttpRequest::SlowOverrideMimeType(const nsAString& aMimeType)
 {
   OverrideMimeType(aMimeType);
   return NS_OK;
 }
 
 /* attribute boolean mozBackgroundRequest; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetMozBackgroundRequest(bool *_retval)
+nsXMLHttpRequest::GetMozBackgroundRequest(bool* _retval)
 {
   *_retval = MozBackgroundRequest();
   return NS_OK;
 }
 
 bool
 nsXMLHttpRequest::MozBackgroundRequest()
 {
@@ -3305,17 +3274,18 @@ NS_IMETHODIMP
 nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest)
 {
   nsresult rv = NS_OK;
   SetMozBackgroundRequest(aMozBackgroundRequest, rv);
   return rv;
 }
 
 void
-nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest, nsresult& aRv)
+nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest,
+                                          nsresult& aRv)
 {
   if (!IsSystemXHR()) {
     aRv = NS_ERROR_DOM_SECURITY_ERR;
     return;
   }
 
   if (!(mState & XML_HTTP_REQUEST_UNSENT)) {
     // Can't change this while we're in the middle of something.
@@ -3327,17 +3297,17 @@ nsXMLHttpRequest::SetMozBackgroundReques
     mState |= XML_HTTP_REQUEST_BACKGROUND;
   } else {
     mState &= ~XML_HTTP_REQUEST_BACKGROUND;
   }
 }
 
 /* attribute boolean withCredentials; */
 NS_IMETHODIMP
-nsXMLHttpRequest::GetWithCredentials(bool *_retval)
+nsXMLHttpRequest::GetWithCredentials(bool* _retval)
 {
   *_retval = WithCredentials();
   return NS_OK;
 }
 
 bool
 nsXMLHttpRequest::WithCredentials()
 {
@@ -3382,49 +3352,46 @@ nsXMLHttpRequest::ChangeState(uint32_t a
   // If we are setting one of the mutually exclusive states,
   // unset those state bits first.
   if (aState & XML_HTTP_REQUEST_LOADSTATES) {
     mState &= ~XML_HTTP_REQUEST_LOADSTATES;
   }
   mState |= aState;
   nsresult rv = NS_OK;
 
-  if (mProgressNotifier &&
-      !(aState & (XML_HTTP_REQUEST_HEADERS_RECEIVED | XML_HTTP_REQUEST_LOADING))) {
+  if (mProgressNotifier && !(aState & (XML_HTTP_REQUEST_HEADERS_RECEIVED |
+                                       XML_HTTP_REQUEST_LOADING))) {
     mProgressTimerIsActive = false;
     mProgressNotifier->Cancel();
   }
 
-  if ((aState & XML_HTTP_REQUEST_LOADSTATES) &&  // Broadcast load states only
-      aState != XML_HTTP_REQUEST_SENT && // And not internal ones
+  if ((aState & XML_HTTP_REQUEST_LOADSTATES) && // Broadcast load states only
+      aState != XML_HTTP_REQUEST_SENT &&        // And not internal ones
       aBroadcast &&
-      (mState & XML_HTTP_REQUEST_ASYNC ||
-       aState & XML_HTTP_REQUEST_OPENED ||
+      (mState & XML_HTTP_REQUEST_ASYNC || aState & XML_HTTP_REQUEST_OPENED ||
        aState & XML_HTTP_REQUEST_DONE)) {
     nsCOMPtr<nsIDOMEvent> event;
     rv = CreateReadystatechangeEvent(getter_AddRefs(event));
     NS_ENSURE_SUCCESS(rv, rv);
 
     DispatchDOMEvent(nullptr, event, nullptr, nullptr);
   }
 
   return rv;
 }
 
 /*
  * Simple helper class that just forwards the redirect callback back
  * to the nsXMLHttpRequest.
  */
-class AsyncVerifyRedirectCallbackForwarder MOZ_FINAL : public nsIAsyncVerifyRedirectCallback
+class AsyncVerifyRedirectCallbackForwarder MOZ_FINAL
+  : public nsIAsyncVerifyRedirectCallback
 {
 public:
-  AsyncVerifyRedirectCallbackForwarder(nsXMLHttpRequest *xhr)
-    : mXHR(xhr)
-  {
-  }
+  AsyncVerifyRedirectCallbackForwarder(nsXMLHttpRequest* xhr) : mXHR(xhr) {}
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackForwarder)
 
   // nsIAsyncVerifyRedirectCallback implementation
   NS_IMETHOD OnRedirectVerifyCallback(nsresult result)
   {
     mXHR->OnRedirectVerifyCallback(result);
@@ -3434,32 +3401,30 @@ public:
 
 private:
   nsRefPtr<nsXMLHttpRequest> mXHR;
 };
 
 NS_IMPL_CYCLE_COLLECTION(AsyncVerifyRedirectCallbackForwarder, mXHR)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AsyncVerifyRedirectCallbackForwarder)
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
-  NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
+NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(AsyncVerifyRedirectCallbackForwarder)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(AsyncVerifyRedirectCallbackForwarder)
 
-
 /////////////////////////////////////////////////////
 // nsIChannelEventSink methods:
 //
 NS_IMETHODIMP
-nsXMLHttpRequest::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
-                                         nsIChannel *aNewChannel,
-                                         uint32_t    aFlags,
-                                         nsIAsyncVerifyRedirectCallback *callback)
+nsXMLHttpRequest::AsyncOnChannelRedirect(
+  nsIChannel* aOldChannel, nsIChannel* aNewChannel, uint32_t aFlags,
+  nsIAsyncVerifyRedirectCallback* callback)
 {
   NS_PRECONDITION(aNewChannel, "Redirect without a channel?");
 
   nsresult rv;
 
   if (!NS_IsInternalSameURIRedirect(aOldChannel, aNewChannel, aFlags)) {
     rv = CheckChannelForCrossSiteRequest(aNewChannel);
     if (NS_FAILED(rv)) {
@@ -3467,34 +3432,33 @@ nsXMLHttpRequest::AsyncOnChannelRedirect
                  "CheckChannelForCrossSiteRequest returned failure");
       return rv;
     }
 
     // Disable redirects for preflighted cross-site requests entirely for now
     // Note, do this after the call to CheckChannelForCrossSiteRequest
     // to make sure that XML_HTTP_REQUEST_USE_XSITE_AC is up-to-date
     if ((mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT)) {
-       return NS_ERROR_DOM_BAD_URI;
+      return NS_ERROR_DOM_BAD_URI;
     }
   }
 
   // Prepare to receive callback
   mRedirectCallback = callback;
   mNewRedirectChannel = aNewChannel;
 
   if (mChannelEventSink) {
     nsRefPtr<AsyncVerifyRedirectCallbackForwarder> fwd =
       new AsyncVerifyRedirectCallbackForwarder(this);
 
-    rv = mChannelEventSink->AsyncOnChannelRedirect(aOldChannel,
-                                                   aNewChannel,
+    rv = mChannelEventSink->AsyncOnChannelRedirect(aOldChannel, aNewChannel,
                                                    aFlags, fwd);
     if (NS_FAILED(rv)) {
-        mRedirectCallback = nullptr;
-        mNewRedirectChannel = nullptr;
+      mRedirectCallback = nullptr;
+      mNewRedirectChannel = nullptr;
     }
     return rv;
   }
   OnRedirectVerifyCallback(NS_OK);
   return NS_OK;
 }
 
 void
@@ -3503,22 +3467,22 @@ nsXMLHttpRequest::OnRedirectVerifyCallba
   NS_ASSERTION(mRedirectCallback, "mRedirectCallback not set in callback");
   NS_ASSERTION(mNewRedirectChannel, "mNewRedirectChannel not set in callback");
 
   if (NS_SUCCEEDED(result)) {
     mChannel = mNewRedirectChannel;
 
     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
     if (httpChannel) {
-      // Ensure all original headers are duplicated for the new channel (bug #553888)
-      for (uint32_t i = mModifiedRequestHeaders.Length(); i > 0; ) {
+      // Ensure all original headers are duplicated for the new channel (bug
+      // #553888)
+      for (uint32_t i = mModifiedRequestHeaders.Length(); i > 0;) {
         --i;
         httpChannel->SetRequestHeader(mModifiedRequestHeaders[i].header,
-                                      mModifiedRequestHeaders[i].value,
-                                      false);
+                                      mModifiedRequestHeaders[i].value, false);
       }
     }
   } else {
     mErrorLoad = true;
   }
 
   mNewRedirectChannel = nullptr;
 
@@ -3533,20 +3497,18 @@ nsXMLHttpRequest::OnRedirectVerifyCallba
 void
 nsXMLHttpRequest::MaybeDispatchProgressEvents(bool aFinalProgress)
 {
   if (aFinalProgress && mProgressTimerIsActive) {
     mProgressTimerIsActive = false;
     mProgressNotifier->Cancel();
   }
 
-  if (mProgressTimerIsActive ||
-      !mProgressSinceLastProgressEvent ||
-      mErrorLoad ||
-      !(mState & XML_HTTP_REQUEST_ASYNC)) {
+  if (mProgressTimerIsActive || !mProgressSinceLastProgressEvent ||
+      mErrorLoad || !(mState & XML_HTTP_REQUEST_ASYNC)) {
     return;
   }
 
   if (!aFinalProgress) {
     StartProgressEventTimer();
   }
 
   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
@@ -3558,87 +3520,88 @@ nsXMLHttpRequest::MaybeDispatchProgressE
                             mUploadTotal);
     }
   } else {
     if (aFinalProgress) {
       mLoadTotal = mLoadTransferred;
     }
     mInLoadProgressEvent = true;
     DispatchProgressEvent(this, NS_LITERAL_STRING(PROGRESS_STR),
-                          mLoadLengthComputable, mLoadTransferred,
-                          mLoadTotal);
+                          mLoadLengthComputable, mLoadTransferred, mLoadTotal);
     mInLoadProgressEvent = false;
     if (mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT ||
         mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
       mResponseBody.Truncate();
       mResponseText.Truncate();
       mResultArrayBuffer = nullptr;
       mArrayBufferBuilder.reset();
     }
   }
 
   mProgressSinceLastProgressEvent = false;
 }
 
 NS_IMETHODIMP
-nsXMLHttpRequest::OnProgress(nsIRequest *aRequest, nsISupports *aContext, uint64_t aProgress, uint64_t aProgressMax)
+nsXMLHttpRequest::OnProgress(nsIRequest* aRequest, nsISupports* aContext,
+                             uint64_t aProgress, uint64_t aProgressMax)
 {
   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
   // XML_HTTP_REQUEST_SENT
   bool upload = !!((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState);
-  // When uploading, OnProgress reports also headers in aProgress and aProgressMax.
+  // When uploading, OnProgress reports also headers in aProgress and
+  // aProgressMax.
   // So, try to remove the headers, if possible.
   bool lengthComputable = (aProgressMax != UINT64_MAX);
   if (upload) {
     mUploadTransferred = aProgress;
     if (lengthComputable) {
       mUploadTransferred = aProgressMax - mUploadTotal;
     }
     mUploadLengthComputable = lengthComputable;
     mProgressSinceLastProgressEvent = true;
 
     MaybeDispatchProgressEvents(false);
   } else {
     mLoadLengthComputable = lengthComputable;
     mLoadTotal = lengthComputable ? aProgressMax : 0;
-    
+
     // Don't dispatch progress events here. OnDataAvailable will take care
     // of that.
   }
 
   if (mProgressEventSink) {
-    mProgressEventSink->OnProgress(aRequest, aContext, aProgress,
-                                   aProgressMax);
+    mProgressEventSink->OnProgress(aRequest, aContext, aProgress, aProgressMax);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsXMLHttpRequest::OnStatus(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatus, const char16_t *aStatusArg)
+nsXMLHttpRequest::OnStatus(nsIRequest* aRequest, nsISupports* aContext,
+                           nsresult aStatus, const char16_t* aStatusArg)
 {
   if (mProgressEventSink) {
     mProgressEventSink->OnStatus(aRequest, aContext, aStatus, aStatusArg);
   }
 
   return NS_OK;
 }
 
 bool
 nsXMLHttpRequest::AllowUploadProgress()
 {
   return !(mState & XML_HTTP_REQUEST_USE_XSITE_AC) ||
-    (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
+         (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
 }
 
 /////////////////////////////////////////////////////
 // nsIInterfaceRequestor methods:
 //
 NS_IMETHODIMP
-nsXMLHttpRequest::GetInterface(const nsIID & aIID, void **aResult)
+nsXMLHttpRequest::GetInterface(const nsIID& aIID, void** aResult)
 {
   nsresult rv;
 
   // Make sure to return ourselves for the channel event sink interface and
   // progress event sink interface, no matter what.  We can forward these to
   // mNotificationCallbacks if it wants to get notifications for them.  But we
   // need to see these notifications for proper functioning.
   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
@@ -3657,28 +3620,28 @@ nsXMLHttpRequest::GetInterface(const nsI
     rv = mNotificationCallbacks->GetInterface(aIID, aResult);
     if (NS_SUCCEEDED(rv)) {
       NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
       return rv;
     }
   }
 
   if (mState & XML_HTTP_REQUEST_BACKGROUND) {
-    nsCOMPtr<nsIInterfaceRequestor> badCertHandler(do_CreateInstance(NS_BADCERTHANDLER_CONTRACTID, &rv));
+    nsCOMPtr<nsIInterfaceRequestor> badCertHandler(
+      do_CreateInstance(NS_BADCERTHANDLER_CONTRACTID, &rv));
 
     // Ignore failure to get component, we may not have all its dependencies
     // available
     if (NS_SUCCEEDED(rv)) {
       rv = badCertHandler->GetInterface(aIID, aResult);
       if (NS_SUCCEEDED(rv))
         return rv;
     }
-  }
-  else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
-           aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
+  } else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
+             aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
 
     nsCOMPtr<nsIURI> uri;
     rv = mChannel->GetURI(getter_AddRefs(uri));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Verify that it's ok to prompt for credentials here, per spec
     // http://xhr.spec.whatwg.org/#the-send%28%29-method
     bool showPrompt = true;
@@ -3688,19 +3651,20 @@ nsXMLHttpRequest::GetInterface(const nsI
     /* Disabled - bug: 799540
     if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
       showPrompt = false;
     }
     */
 
     // ... Authorization is not in the list of author request headers, ...
     if (showPrompt) {
-      for (uint32_t i = 0, len = mModifiedRequestHeaders.Length(); i < len; ++i) {
-        if (mModifiedRequestHeaders[i].header.
-              LowerCaseEqualsLiteral("authorization")) {
+      for (uint32_t i = 0, len = mModifiedRequestHeaders.Length(); i < len;
+           ++i) {
+        if (mModifiedRequestHeaders[i]
+              .header.LowerCaseEqualsLiteral("authorization")) {
           showPrompt = false;
           break;
         }
       }
     }
 
     // ... request username is null, and request password is null,
     if (showPrompt) {
@@ -3713,19 +3677,21 @@ nsXMLHttpRequest::GetInterface(const nsI
       rv = uri->GetPassword(password);
       NS_ENSURE_SUCCESS(rv, rv);
 
       if (!username.IsEmpty() || !password.IsEmpty()) {
         showPrompt = false;
       }
     }
 
-    // ... user agents should prompt the end user for their username and password.
+    // ... user agents should prompt the end user for their username and
+    // password.
     if (!showPrompt) {
-      nsRefPtr<XMLHttpRequestAuthPrompt> prompt = new XMLHttpRequestAuthPrompt();
+      nsRefPtr<XMLHttpRequestAuthPrompt> prompt =
+        new XMLHttpRequestAuthPrompt();
       if (!prompt)
         return NS_ERROR_OUT_OF_MEMORY;
 
       return prompt->QueryInterface(aIID, aResult);
     }
 
     nsCOMPtr<nsIPromptFactory> wwatch =
       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
@@ -3734,31 +3700,28 @@ nsXMLHttpRequest::GetInterface(const nsI
     // Get the an auth prompter for our window so that the parenting
     // of the dialogs works as it should when using tabs.
 
     nsCOMPtr<nsIDOMWindow> window;
     if (GetOwner()) {
       window = GetOwner()->GetOuterWindow();
     }
 
-    return wwatch->GetPrompt(window, aIID,
-                             reinterpret_cast<void**>(aResult));
+    return wwatch->GetPrompt(window, aIID, reinterpret_cast<void**>(aResult));
   }
   // Now check for the various XHR non-DOM interfaces, except
   // nsIProgressEventSink and nsIChannelEventSink which we already
   // handled above.
   else if (aIID.Equals(NS_GET_IID(nsIStreamListener))) {
     *aResult = static_cast<nsIStreamListener*>(EnsureXPCOMifier().take());
     return NS_OK;
-  }
-  else if (aIID.Equals(NS_GET_IID(nsIRequestObserver))) {
+  } else if (aIID.Equals(NS_GET_IID(nsIRequestObserver))) {
     *aResult = static_cast<nsIRequestObserver*>(EnsureXPCOMifier().take());
     return NS_OK;
-  }
-  else if (aIID.Equals(NS_GET_IID(nsITimerCallback))) {
+  } else if (aIID.Equals(NS_GET_IID(nsITimerCallback))) {
     *aResult = static_cast<nsITimerCallback*>(EnsureXPCOMifier().take());
     return NS_OK;
   }
 
   return QueryInterface(aIID, aResult);
 }
 
 JS::Value
@@ -3809,17 +3772,18 @@ nsXMLHttpRequest::GetMozSystem(bool* aSy
   *aSystem = MozSystem();
   return NS_OK;
 }
 
 void
 nsXMLHttpRequest::HandleTimeoutCallback()
 {
   if (mState & XML_HTTP_REQUEST_DONE) {
-    NS_NOTREACHED("nsXMLHttpRequest::HandleTimeoutCallback with completed request");
+    NS_NOTREACHED(
+      "nsXMLHttpRequest::HandleTimeoutCallback with completed request");
     // do nothing!
     return;
   }
 
   CloseRequestWithError(NS_LITERAL_STRING(TIMEOUT_STR),
                         XML_HTTP_REQUEST_TIMED_OUT);
 }
 
@@ -3831,17 +3795,18 @@ nsXMLHttpRequest::Notify(nsITimer* aTime
     return NS_OK;
   }
 
   if (mTimeoutTimer == aTimer) {
     HandleTimeoutCallback();
     return NS_OK;
   }
 
-  // Just in case some JS user wants to QI to nsITimerCallback and play with us...
+  // Just in case some JS user wants to QI to nsITimerCallback and play with
+  // us...
   NS_WARNING("Unexpected timer!");
   return NS_ERROR_INVALID_POINTER;
 }
 
 void
 nsXMLHttpRequest::HandleProgressTimerCallback()
 {
   mProgressTimerIsActive = false;
@@ -3869,37 +3834,38 @@ nsXMLHttpRequest::EnsureXPCOMifier()
     mXPCOMifier = new nsXMLHttpRequestXPCOMifier(this);
   }
   nsRefPtr<nsXMLHttpRequestXPCOMifier> newRef(mXPCOMifier);
   return newRef.forget();
 }
 
 NS_IMPL_ISUPPORTS(nsXMLHttpRequest::nsHeaderVisitor, nsIHttpHeaderVisitor)
 
-NS_IMETHODIMP nsXMLHttpRequest::
-nsHeaderVisitor::VisitHeader(const nsACString &header, const nsACString &value)
+NS_IMETHODIMP
+nsXMLHttpRequest::nsHeaderVisitor::VisitHeader(const nsACString& header,
+                                               const nsACString& value)
 {
   if (mXHR->IsSafeHeader(header, mHttpChannel)) {
     mHeaders.Append(header);
     mHeaders.AppendLiteral(": ");
     mHeaders.Append(value);
     mHeaders.AppendLiteral("\r\n");
   }
   return NS_OK;
 }
 
 // nsXMLHttpRequestXPCOMifier implementation
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXMLHttpRequestXPCOMifier)
-  NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
-  NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
-  NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
-  NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
-  NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)
+NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
+NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
+NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
+NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
+NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
+NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXMLHttpRequestXPCOMifier)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXMLHttpRequestXPCOMifier)
 
 // Can't NS_IMPL_CYCLE_COLLECTION( because mXHR has ambiguous
 // inheritance from nsISupports.
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpRequestXPCOMifier)
@@ -3911,44 +3877,39 @@ if (tmp->mXHR) {
 NS_IMPL_CYCLE_COLLECTION_UNLINK(mXHR)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXMLHttpRequestXPCOMifier)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mXHR)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMETHODIMP
-nsXMLHttpRequestXPCOMifier::GetInterface(const nsIID & aIID, void **aResult)
+nsXMLHttpRequestXPCOMifier::GetInterface(const nsIID& aIID, void** aResult)
 {
   // Return ourselves for the things we implement (except
   // nsIInterfaceRequestor) and the XHR for the rest.
   if (!aIID.Equals(NS_GET_IID(nsIInterfaceRequestor))) {
     nsresult rv = QueryInterface(aIID, aResult);
     if (NS_SUCCEEDED(rv)) {
       return rv;
     }
   }
 
   return mXHR->GetInterface(aIID, aResult);
 }
 
-namespace mozilla {
+namespace mozilla
+{
 
 ArrayBufferBuilder::ArrayBufferBuilder()
-  : mDataPtr(nullptr),
-    mCapacity(0),
-    mLength(0),
-    mMapPtr(nullptr)
+  : mDataPtr(nullptr), mCapacity(0), mLength(0), mMapPtr(nullptr)
 {
 }
 
-ArrayBufferBuilder::~ArrayBufferBuilder()
-{
-  reset();
-}
+ArrayBufferBuilder::~ArrayBufferBuilder() { reset(); }
 
 void
 ArrayBufferBuilder::reset()
 {
   if (mDataPtr) {
     JS_free(nullptr, mDataPtr);
   }
 
@@ -3961,32 +3922,33 @@ ArrayBufferBuilder::reset()
   mCapacity = mLength = 0;
 }
 
 bool
 ArrayBufferBuilder::setCapacity(uint32_t aNewCap)
 {
   MOZ_ASSERT(!mMapPtr);
 
-  uint8_t *newdata = (uint8_t *) JS_ReallocateArrayBufferContents(nullptr, aNewCap, mDataPtr, mCapacity);
+  uint8_t* newdata = (uint8_t*)JS_ReallocateArrayBufferContents(
+    nullptr, aNewCap, mDataPtr, mCapacity);
   if (!newdata) {
     return false;
   }
 
   mDataPtr = newdata;
   mCapacity = aNewCap;
   if (mLength > aNewCap) {
     mLength = aNewCap;
   }
 
   return true;
 }
 
 bool
-ArrayBufferBuilder::append(const uint8_t *aNewData, uint32_t aDataLen,
+ArrayBufferBuilder::append(const uint8_t* aNewData, uint32_t aDataLen,
                            uint32_t aMaxGrowth)
 {
   MOZ_ASSERT(!mMapPtr);
 
   if (mLength + aDataLen > mCapacity) {
     uint32_t newcap;
     // Double while under aMaxGrowth or if not specified.
     if (!aMaxGrowth || mCapacity < aMaxGrowth) {
@@ -4006,18 +3968,18 @@ ArrayBufferBuilder::append(const uint8_t
     }
 
     if (!setCapacity(newcap)) {
       return false;
     }
   }
 
   // Assert that the region isn't overlapping so we can memcpy.
-  MOZ_ASSERT(!areOverlappingRegions(aNewData, aDataLen, mDataPtr + mLength,
-                                    aDataLen));
+  MOZ_ASSERT(
+    !areOverlappingRegions(aNewData, aDataLen, mDataPtr + mLength, aDataLen));
 
   memcpy(mDataPtr + mLength, aNewData, aDataLen);
   mLength += aDataLen;
 
   return true;
 }
 
 JSObject*
@@ -4102,14 +4064,14 @@ ArrayBufferBuilder::areOverlappingRegion
                                           uint32_t aLength1,
                                           const uint8_t* aStart2,
                                           uint32_t aLength2)
 {
   const uint8_t* end1 = aStart1 + aLength1;
   const uint8_t* end2 = aStart2 + aLength2;
 
   const uint8_t* max_start = aStart1 > aStart2 ? aStart1 : aStart2;
-  const uint8_t* min_end   = end1 < end2 ? end1 : end2;
+  const uint8_t* min_end = end1 < end2 ? end1 : end2;
 
   return max_start < min_end;
 }
 
 } // namespace mozilla
