# HG changeset patch
# Parent b390e72c5a543b600f8613650b0ceb0bfe747d96
# User Gregory Szorc <gps@mozilla.com>
Bug 862563 - Part 1: Remove strong requirement of policy tracking

diff --git a/modules/libpref/src/Makefile.in b/modules/libpref/src/Makefile.in
--- a/modules/libpref/src/Makefile.in
+++ b/modules/libpref/src/Makefile.in
@@ -36,20 +36,16 @@
 			mailnews.js editor.js \
 			aix.js unix.js winpref.js os2prefs.js)
 
 GARBAGE		+= greprefs.js
 
 # TODO bug 813259 external files should be defined near their location in the source tree.
 grepref_files = $(topsrcdir)/netwerk/base/public/security-prefs.js $(srcdir)/init/all.js
 
-ifdef MOZ_DATA_REPORTING
-grepref_files += $(topsrcdir)/services/datareporting/datareporting-prefs.js
-endif
-
 ifdef MOZ_SERVICES_HEALTHREPORT
 grepref_files += $(topsrcdir)/services/healthreport/healthreport-prefs.js
 endif
 
 # Optimizer bug with GCC 3.2.2 on OS/2
 ifeq ($(OS_ARCH), OS2)
 nsPrefService.$(OBJ_SUFFIX): nsPrefService.cpp
 	$(REPORT_BUILD)
diff --git a/services/datareporting/DataReportingService.js b/services/datareporting/DataReportingService.js
--- a/services/datareporting/DataReportingService.js
+++ b/services/datareporting/DataReportingService.js
@@ -79,20 +79,16 @@
   onRequestDataUpload: function (request) {
     if (!this.healthReporter) {
       return;
     }
 
     this.healthReporter.requestDataUpload(request);
   },
 
-  onNotifyDataPolicy: function (request) {
-    Observers.notify("datareporting:notify-data-policy:request", request);
-  },
-
   onRequestRemoteDelete: function (request) {
     if (!this.healthReporter) {
       return;
     }
 
     this.healthReporter.deleteRemoteData(request);
   },
 
diff --git a/services/datareporting/datareporting-prefs.js b/services/datareporting/datareporting-prefs.js
deleted file mode 100644
--- a/services/datareporting/datareporting-prefs.js
+++ /dev/null
@@ -1,12 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-pref("datareporting.policy.dataSubmissionEnabled", true);
-pref("datareporting.policy.dataSubmissionPolicyAccepted", false);
-pref("datareporting.policy.dataSubmissionPolicyBypassAcceptance", false);
-pref("datareporting.policy.dataSubmissionPolicyNotifiedTime", "0");
-pref("datareporting.policy.dataSubmissionPolicyResponseType", "");
-pref("datareporting.policy.dataSubmissionPolicyResponseTime", "0");
-pref("datareporting.policy.firstRunTime", "0");
-
diff --git a/services/datareporting/modules-testing/mocks.jsm b/services/datareporting/modules-testing/mocks.jsm
--- a/services/datareporting/modules-testing/mocks.jsm
+++ b/services/datareporting/modules-testing/mocks.jsm
@@ -15,33 +15,24 @@
   this._log = Log4Moz.repository.getLogger("Services.DataReporting.Testing.MockPolicyListener");
   this._log.level = Log4Moz.Level["Debug"];
 
   this.requestDataUploadCount = 0;
   this.lastDataRequest = null;
 
   this.requestRemoteDeleteCount = 0;
   this.lastRemoteDeleteRequest = null;
-
-  this.notifyUserCount = 0;
-  this.lastNotifyRequest = null;
 }
 
 MockPolicyListener.prototype = {
   onRequestDataUpload: function onRequestDataUpload(request) {
     this._log.info("onRequestDataUpload invoked.");
     this.requestDataUploadCount++;
     this.lastDataRequest = request;
   },
 
   onRequestRemoteDelete: function onRequestRemoteDelete(request) {
     this._log.info("onRequestRemoteDelete invoked.");
     this.requestRemoteDeleteCount++;
     this.lastRemoteDeleteRequest = request;
   },
-
-  onNotifyDataPolicy: function onNotifyDataPolicy(request) {
-    this._log.info("onNotifyUser invoked.");
-    this.notifyUserCount++;
-    this.lastNotifyRequest = request;
-  },
 };
 
diff --git a/services/datareporting/policy.jsm b/services/datareporting/policy.jsm
--- a/services/datareporting/policy.jsm
+++ b/services/datareporting/policy.jsm
@@ -1,21 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /**
- * This file is in transition. It was originally conceived to fulfill the
- * needs of only Firefox Health Report. It is slowly being morphed into
- * fulfilling the needs of all data reporting facilities in Gecko applications.
- * As a result, some things feel a bit weird.
- *
- * DataReportingPolicy is both a driver for data reporting notification
- * (a true policy) and the driver for FHR data submission. The latter should
- * eventually be split into its own type and module.
+ * This file is in transition. Most of its content needs to be moved under
+ * /services/healthreport.
  */
 
 "use strict";
 
 #ifndef MERGED_COMPARTMENT
 
 this.EXPORTED_SYMBOLS = [
   "DataSubmissionRequest", // For test use only.
@@ -32,100 +26,16 @@
 
 const MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;
 
 // Used as a sanity lower bound for dates stored in prefs. This module was
 // implemented in 2012, so any earlier dates indicate an incorrect clock.
 const OLDEST_ALLOWED_YEAR = 2012;
 
 /**
- * Represents a request to display data policy.
- *
- * Instances of this are created when the policy is requesting the user's
- * approval to agree to the data submission policy.
- *
- * Receivers of these instances are expected to call one or more of the on*
- * functions when events occur.
- *
- * When one of these requests is received, the first thing a callee should do
- * is present notification to the user of the data policy. When the notice
- * is displayed to the user, the callee should call `onUserNotifyComplete`.
- * This begins a countdown timer that upon completion will signal implicit
- * acceptance of the policy. If for whatever reason the callee could not
- * display a notice, it should call `onUserNotifyFailed`.
- *
- * Once the user is notified of the policy, the callee has the option of
- * signaling explicit user acceptance or rejection of the policy. They do this
- * by calling `onUserAccept` or `onUserReject`, respectively. These functions
- * are essentially proxies to
- * DataReportingPolicy.{recordUserAcceptance,recordUserRejection}.
- *
- * If the user never explicitly accepts or rejects the policy, it will be
- * implicitly accepted after a specified duration of time. The notice is
- * expected to remain displayed even after implicit acceptance (in case the
- * user is away from the device). So, no event signaling implicit acceptance
- * is exposed.
- *
- * Receivers of instances of this type should treat it as a black box with
- * the exception of the on* functions.
- *
- * @param policy
- *        (DataReportingPolicy) The policy instance this request came from.
- * @param promise
- *        (deferred) The promise that will be fulfilled when display occurs.
- */
-function NotifyPolicyRequest(policy, promise) {
-  this.policy = policy;
-  this.promise = promise;
-}
-NotifyPolicyRequest.prototype = {
-  /**
-   * Called when the user is notified of the policy.
-   *
-   * This starts a countdown timer that will eventually signify implicit
-   * acceptance of the data policy.
-   */
-  onUserNotifyComplete: function onUserNotified() {
-    this.promise.resolve();
-  },
-
-  /**
-   * Called when there was an error notifying the user about the policy.
-   *
-   * @param error
-   *        (Error) Explains what went wrong.
-   */
-  onUserNotifyFailed: function onUserNotifyFailed(error) {
-    this.promise.reject(error);
-  },
-
-  /**
-   * Called when the user agreed to the data policy.
-   *
-   * @param reason
-   *        (string) How the user agreed to the policy.
-   */
-  onUserAccept: function onUserAccept(reason) {
-    this.policy.recordUserAcceptance(reason);
-  },
-
-  /**
-   * Called when the user rejected the data policy.
-   *
-   * @param reason
-   *        (string) How the user rejected the policy.
-   */
-  onUserReject: function onUserReject(reason) {
-    this.policy.recordUserRejection(reason);
-  },
-};
-
-Object.freeze(NotifyPolicyRequest.prototype);
-
-/**
  * Represents a request to submit data.
  *
  * Instances of this are created when the policy requests data upload or
  * deletion.
  *
  * Receivers are expected to call one of the provided on* functions to signal
  * completion of the request.
  *
@@ -213,44 +123,32 @@
  * Manages scheduling of Firefox Health Report data submission.
  *
  * The rules of data submission are as follows:
  *
  *  1. Do not submit data more than once every 24 hours.
  *  2. Try to submit as close to 24 hours apart as possible.
  *  3. Do not submit too soon after application startup so as to not negatively
  *     impact performance at startup.
- *  4. Before first ever data submission, the user should be notified about
- *     data collection practices.
- *  5. User should have opportunity to react to this notification before
- *     data submission.
- *  6. Display of notification without any explicit user action constitutes
- *     implicit consent after a certain duration of time.
- *  7. If data submission fails, try at most 2 additional times before giving
+ *  4. If data submission fails, try at most 2 additional times before giving
  *     up on that day's submission.
  *
  * The listener passed into the instance must have the following properties
  * (which are callbacks that will be invoked at certain key events):
  *
  *   * onRequestDataUpload(request) - Called when the policy is requesting
  *     data to be submitted. The function is passed a `DataSubmissionRequest`.
  *     The listener should call one of the special resolving functions on that
  *     instance (see the documentation for that type).
  *
  *   * onRequestRemoteDelete(request) - Called when the policy is requesting
  *     deletion of remotely stored data. The function is passed a
  *     `DataSubmissionRequest`. The listener should call one of the special
  *     resolving functions on that instance (just like `onRequestDataUpload`).
  *
- *   * onNotifyDataPolicy(request) - Called when the policy is requesting the
- *     user to be notified that data submission will occur. The function
- *     receives a `NotifyPolicyRequest` instance. The callee should call one or
- *     more of the functions on that instance when specific events occur. See
- *     the documentation for that type for more.
- *
  * Note that the notification method is abstracted. Different applications
  * can have different mechanisms by which they notify the user of data
  * submission practices.
  *
  * @param policyPrefs
  *        (Preferences) Handle on preferences branch on which state will be
  *        queried and stored.
  * @param healthReportPrefs
@@ -269,21 +167,16 @@
                       handler);
     }
   }
 
   this._prefs = prefs;
   this._healthReportPrefs = healthReportPrefs;
   this._listener = listener;
 
-  // If we've never run before, record the current time.
-  if (!this.firstRunDate.getTime()) {
-    this.firstRunDate = this.now();
-  }
-
   // Install an observer so that we can act on changes from external
   // code (such as Android UI).
   // Use a function because this is the only place where the Preferences
   // abstraction is way less usable than nsIPrefBranch.
   //
   // Hang on to the observer here so that tests can reach it.
   this.uploadEnabledObserver = function onUploadEnabledChanged() {
     if (this.pendingDeleteRemoteData || this.healthReportUploadEnabled) {
@@ -297,41 +190,23 @@
 
   healthReportPrefs.observe("uploadEnabled", this.uploadEnabledObserver);
 
   // Ensure we are scheduled to submit.
   if (!this.nextDataSubmissionDate.getTime()) {
     this.nextDataSubmissionDate = this._futureDate(MILLISECONDS_PER_DAY);
   }
 
-  // Date at which we performed user notification of acceptance.
-  // This is an instance variable because implicit acceptance should only
-  // carry forward through a single application instance.
-  this._dataSubmissionPolicyNotifiedDate = null;
-
   // Record when we last requested for submitted data to be sent. This is
   // to avoid having multiple outstanding requests.
   this._inProgressSubmissionRequest = null;
 };
 
 DataReportingPolicy.prototype = Object.freeze({
   /**
-   * How long after first run we should notify about data submission.
-   */
-  SUBMISSION_NOTIFY_INTERVAL_MSEC: 12 * 60 * 60 * 1000,
-
-  /**
-   * Time that must elapse with no user action for implicit acceptance.
-   *
-   * THERE ARE POTENTIAL LEGAL IMPLICATIONS OF CHANGING THIS VALUE. Check with
-   * Privacy and/or Legal before modifying.
-   */
-  IMPLICIT_ACCEPTANCE_INTERVAL_MSEC: 8 * 60 * 60 * 1000,
-
-  /**
    *  How often to poll to see if we need to do something.
    *
    * The interval needs to be short enough such that short-lived applications
    * have an opportunity to submit data. But, it also needs to be long enough
    * to not negatively impact performance.
    *
    * The random bit is to ensure that other systems scheduling around the same
    * interval don't all get scheduled together.
@@ -361,173 +236,37 @@
    * we run out of values in this array, we give up on that day's submission
    * and schedule for a day out.
    */
   FAILURE_BACKOFF_INTERVALS: [
     15 * 60 * 1000,
     60 * 60 * 1000,
   ],
 
-  /**
-   * State of user notification of data submission.
-   */
-  STATE_NOTIFY_UNNOTIFIED: "not-notified",
-  STATE_NOTIFY_WAIT: "waiting",
-  STATE_NOTIFY_COMPLETE: "ok",
-
   REQUIRED_LISTENERS: [
     "onRequestDataUpload",
     "onRequestRemoteDelete",
-    "onNotifyDataPolicy",
   ],
 
   /**
-   * The first time the health report policy came into existence.
-   *
-   * This is used for scheduling of the initial submission.
-   */
-  get firstRunDate() {
-    return CommonUtils.getDatePref(this._prefs, "firstRunTime", 0, this._log,
-                                   OLDEST_ALLOWED_YEAR);
-  },
-
-  set firstRunDate(value) {
-    this._log.debug("Setting first-run date: " + value);
-    CommonUtils.setDatePref(this._prefs, "firstRunTime", value,
-                            OLDEST_ALLOWED_YEAR);
-  },
-
-  /**
-   * Short circuit policy checking and always assume acceptance.
-   *
-   * This shuld never be set by the user. Instead, it is a per-application or
-   * per-deployment default pref.
-   */
-  get dataSubmissionPolicyBypassAcceptance() {
-    return this._prefs.get("dataSubmissionPolicyBypassAcceptance", false);
-  },
-
-  /**
-   * When the user was notified that data submission could occur.
-   *
-   * This is used for logging purposes. this._dataSubmissionPolicyNotifiedDate
-   * is what's used internally.
-   */
-  get dataSubmissionPolicyNotifiedDate() {
-    return CommonUtils.getDatePref(this._prefs,
-                                   "dataSubmissionPolicyNotifiedTime", 0,
-                                   this._log, OLDEST_ALLOWED_YEAR);
-  },
-
-  set dataSubmissionPolicyNotifiedDate(value) {
-    this._log.debug("Setting user notified date: " + value);
-    CommonUtils.setDatePref(this._prefs, "dataSubmissionPolicyNotifiedTime",
-                            value, OLDEST_ALLOWED_YEAR);
-  },
-
-  /**
-   * When the user accepted or rejected the data submission policy.
-   *
-   * If there was implicit acceptance, this will be set to the time of that.
-   */
-  get dataSubmissionPolicyResponseDate() {
-    return CommonUtils.getDatePref(this._prefs,
-                                   "dataSubmissionPolicyResponseTime",
-                                   0, this._log, OLDEST_ALLOWED_YEAR);
-  },
-
-  set dataSubmissionPolicyResponseDate(value) {
-    this._log.debug("Setting user notified reaction date: " + value);
-    CommonUtils.setDatePref(this._prefs,
-                            "dataSubmissionPolicyResponseTime",
-                            value, OLDEST_ALLOWED_YEAR);
-  },
-
-  /**
-   * Records the result of user notification of data submission policy.
-   *
-   * This is used for logging and diagnostics purposes. It can answer the
-   * question "how was data submission agreed to on this profile?"
-   *
-   * Not all values are defined by this type and can come from other systems.
-   *
-   * The value must be a string and should be something machine readable. e.g.
-   * "accept-user-clicked-ok-button-in-info-bar"
-   */
-  get dataSubmissionPolicyResponseType() {
-    return this._prefs.get("dataSubmissionPolicyResponseType",
-                           "none-recorded");
-  },
-
-  set dataSubmissionPolicyResponseType(value) {
-    if (typeof(value) != "string") {
-      throw new Error("Value must be a string. Got " + typeof(value));
-    }
-
-    this._prefs.set("dataSubmissionPolicyResponseType", value);
-  },
-
-  /**
    * Whether submission of data is allowed.
    *
    * This is the master switch for remote server communication. If it is
    * false, we never request upload or deletion.
    */
   get dataSubmissionEnabled() {
     // Default is true because we are opt-out.
     return this._prefs.get("dataSubmissionEnabled", true);
   },
 
   set dataSubmissionEnabled(value) {
     this._prefs.set("dataSubmissionEnabled", !!value);
   },
 
   /**
-   * Whether the user has accepted that data submission can occur.
-   *
-   * This overrides dataSubmissionEnabled.
-   */
-  get dataSubmissionPolicyAccepted() {
-    // Be conservative and default to false.
-    return this._prefs.get("dataSubmissionPolicyAccepted", false);
-  },
-
-  set dataSubmissionPolicyAccepted(value) {
-    this._prefs.set("dataSubmissionPolicyAccepted", !!value);
-  },
-
-  set dataSubmissionPolicyAcceptedVersion(value) {
-    this._prefs.set("dataSubmissionPolicyAcceptedVersion", value);
-  },
-
-  /**
-   * The state of user notification of the data policy.
-   *
-   * This must be DataReportingPolicy.STATE_NOTIFY_COMPLETE before data
-   * submission can occur.
-   *
-   * @return DataReportingPolicy.STATE_NOTIFY_* constant.
-   */
-  get notifyState() {
-    if (this.dataSubmissionPolicyResponseDate.getTime()) {
-      return this.STATE_NOTIFY_COMPLETE;
-    }
-
-    // We get the local state - not the state from prefs - because we don't want
-    // a value from a previous application run to interfere. This prevents
-    // a scenario where notification occurs just before application shutdown and
-    // notification is displayed for shorter than the policy requires.
-    if (!this._dataSubmissionPolicyNotifiedDate) {
-      return this.STATE_NOTIFY_UNNOTIFIED;
-    }
-
-    return this.STATE_NOTIFY_WAIT;
-  },
-
-  /**
    * When this policy last requested data submission.
    *
    * This is used mainly for forensics purposes and should have no bearing
    * on scheduling or run-time behavior.
    */
   get lastDataSubmissionRequestedDate() {
     return CommonUtils.getDatePref(this._healthReportPrefs,
                                    "lastDataSubmissionRequestedTime", 0,
@@ -641,54 +380,16 @@
 
   // External callers should update this via `recordHealthReportUploadEnabled`
   // to ensure appropriate side-effects are performed.
   set healthReportUploadEnabled(value) {
     this._healthReportPrefs.set("uploadEnabled", !!value);
   },
 
   /**
-   * Record user acceptance of data submission policy.
-   *
-   * Data submission will not be allowed to occur until this is called.
-   *
-   * This is typically called through the `onUserAccept` property attached to
-   * the promise passed to `onUserNotify` in the policy listener. But, it can
-   * be called through other interfaces at any time and the call will have
-   * an impact on future data submissions.
-   *
-   * @param reason
-   *        (string) How the user accepted the data submission policy.
-   */
-  recordUserAcceptance: function recordUserAcceptance(reason="no-reason") {
-    this._log.info("User accepted data submission policy: " + reason);
-    this.dataSubmissionPolicyResponseDate = this.now();
-    this.dataSubmissionPolicyResponseType = "accepted-" + reason;
-    this.dataSubmissionPolicyAccepted = true;
-    this.dataSubmissionPolicyAcceptedVersion = 1;
-  },
-
-  /**
-   * Record user rejection of submission policy.
-   *
-   * Data submission will not be allowed to occur if this is called.
-   *
-   * This is typically called through the `onUserReject` property attached to
-   * the promise passed to `onUserNotify` in the policy listener. But, it can
-   * be called through other interfaces at any time and the call will have an
-   * impact on future data submissions.
-   */
-  recordUserRejection: function recordUserRejection(reason="no-reason") {
-    this._log.info("User rejected data submission policy: " + reason);
-    this.dataSubmissionPolicyResponseDate = this.now();
-    this.dataSubmissionPolicyResponseType = "rejected-" + reason;
-    this.dataSubmissionPolicyAccepted = false;
-  },
-
-  /**
    * Record the user's intent for whether FHR should upload data.
    *
    * This is the preferred way for XUL applications to record a user's
    * preference on whether Firefox Health Report should upload data to
    * a server.
    *
    * If upload is disabled through this API, a request for remote data
    * deletion is initiated automatically.
@@ -830,118 +531,27 @@
       return this._dispatchSubmissionRequest("onRequestRemoteDelete", true);
     }
 
     if (!this.healthReportUploadEnabled) {
       this._log.debug("Data upload is disabled. Doing nothing.");
       return;
     }
 
-    // If the user hasn't responded to the data policy, don't do anything.
-    if (!this.ensureNotifyResponse(now)) {
-      return;
-    }
-
-    // User has opted out of data submission.
-    if (!this.dataSubmissionPolicyAccepted && !this.dataSubmissionPolicyBypassAcceptance) {
-      this._log.debug("Data submission has been disabled per user request.");
-      return;
-    }
-
-    // User has responded to data policy and data submission is enabled. Now
-    // comes the scheduling part.
+    // Data submission is allowed to occur. Now comes the scheduling part.
 
     if (nowT < nextSubmissionDate.getTime()) {
       this._log.debug("Next data submission is scheduled in the future: " +
                      nextSubmissionDate);
       return;
     }
 
     return this._dispatchSubmissionRequest("onRequestDataUpload", false);
   },
 
-  /**
-   * Ensure user has responded to data submission policy.
-   *
-   * This must be called before data submission. If the policy has not been
-   * responded to, data submission must not occur.
-   *
-   * @return bool Whether user has responded to data policy.
-   */
-  ensureNotifyResponse: function ensureNotifyResponse(now) {
-    if (this.dataSubmissionPolicyBypassAcceptance) {
-      return true;
-    }
-
-    let notifyState = this.notifyState;
-
-    if (notifyState == this.STATE_NOTIFY_UNNOTIFIED) {
-      let notifyAt = new Date(this.firstRunDate.getTime() +
-                              this.SUBMISSION_NOTIFY_INTERVAL_MSEC);
-
-      if (now.getTime() < notifyAt.getTime()) {
-        this._log.debug("Don't have to notify about data submission yet.");
-        return false;
-      }
-
-      let onComplete = function onComplete() {
-        this._log.info("Data submission notification presented.");
-        let now = this.now();
-
-        this._dataSubmissionPolicyNotifiedDate = now;
-        this.dataSubmissionPolicyNotifiedDate = now;
-      }.bind(this);
-
-      let deferred = Promise.defer();
-
-      deferred.promise.then(onComplete, function onError(error) {
-        this._log.warn("Data policy notification presentation failed: " +
-                       CommonUtils.exceptionStr(error));
-      });
-
-      this._log.info("Requesting display of data policy.");
-      let request = new NotifyPolicyRequest(this, deferred);
-
-      try {
-        this._listener.onNotifyDataPolicy(request);
-      } catch (ex) {
-        this._log.warn("Exception when calling onNotifyDataPolicy: " +
-                       CommonUtils.exceptionStr(ex));
-      }
-      return false;
-    }
-
-    // We're waiting for user action or implicit acceptance after display.
-    if (notifyState == this.STATE_NOTIFY_WAIT) {
-      // Check for implicit acceptance.
-      let implicitAcceptance =
-        this._dataSubmissionPolicyNotifiedDate.getTime() +
-        this.IMPLICIT_ACCEPTANCE_INTERVAL_MSEC;
-
-      this._log.debug("Now: " + now.getTime());
-      this._log.debug("Will accept: " + implicitAcceptance);
-      if (now.getTime() < implicitAcceptance) {
-        this._log.debug("Still waiting for reaction or implicit acceptance. " +
-                        "Now: " + now.getTime() + " < " +
-                        "Accept: " + implicitAcceptance);
-        return false;
-      }
-
-      this.recordUserAcceptance("implicit-time-elapsed");
-      return true;
-    }
-
-    // If this happens, we have a coding error in this file.
-    if (notifyState != this.STATE_NOTIFY_COMPLETE) {
-      throw new Error("Unknown notification state: " + notifyState);
-    }
-
-    return true;
-  },
-
   _processInProgressSubmission: function _processInProgressSubmission() {
     if (!this._inProgressSubmissionRequest) {
       return false;
     }
 
     let now = this.now().getTime();
     if (this._inProgressSubmissionRequest.expiresDate.getTime() > now) {
       this._log.info("Waiting on in-progress submission request to finish.");
diff --git a/services/datareporting/tests/xpcshell/test_policy.js b/services/datareporting/tests/xpcshell/test_policy.js
--- a/services/datareporting/tests/xpcshell/test_policy.js
+++ b/services/datareporting/tests/xpcshell/test_policy.js
@@ -40,63 +40,35 @@
   let hrPrefs = new Preferences("foo.bar.healthreport.");
   let listener = {
     onRequestDataUpload: function() {},
     onRequestRemoteDelete: function() {},
     onNotifyDataPolicy: function() {},
   };
 
   let policy = new DataReportingPolicy(policyPrefs, hrPrefs, listener);
-  do_check_true(Date.now() - policy.firstRunDate.getTime() < 1000);
 
   let tomorrow = Date.now() + 24 * 60 * 60 * 1000;
   do_check_true(tomorrow - policy.nextDataSubmissionDate.getTime() < 1000);
 
   do_check_eq(policy.notifyState, policy.STATE_NOTIFY_UNNOTIFIED);
 
   run_next_test();
 });
 
 add_test(function test_prefs() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("prefs");
 
   let now = new Date();
   let nowT = now.getTime();
 
-  policy.firstRunDate = now;
-  do_check_eq(policyPrefs.get("firstRunTime"), nowT);
-  do_check_eq(policy.firstRunDate.getTime(), nowT);
-
-  policy.dataSubmissionPolicyNotifiedDate= now;
-  do_check_eq(policyPrefs.get("dataSubmissionPolicyNotifiedTime"), nowT);
-  do_check_eq(policy.dataSubmissionPolicyNotifiedDate.getTime(), nowT);
-
-  policy.dataSubmissionPolicyResponseDate = now;
-  do_check_eq(policyPrefs.get("dataSubmissionPolicyResponseTime"), nowT);
-  do_check_eq(policy.dataSubmissionPolicyResponseDate.getTime(), nowT);
-
-  policy.dataSubmissionPolicyResponseType = "type-1";
-  do_check_eq(policyPrefs.get("dataSubmissionPolicyResponseType"), "type-1");
-  do_check_eq(policy.dataSubmissionPolicyResponseType, "type-1");
-
   policy.dataSubmissionEnabled = false;
   do_check_false(policyPrefs.get("dataSubmissionEnabled", true));
   do_check_false(policy.dataSubmissionEnabled);
 
-  policy.dataSubmissionPolicyAccepted = false;
-  do_check_false(policyPrefs.get("dataSubmissionPolicyAccepted", true));
-  do_check_false(policy.dataSubmissionPolicyAccepted);
-
-  policy.dataSubmissionPolicyAcceptedVersion = 2;
-  do_check_eq(policyPrefs.get("dataSubmissionPolicyAcceptedVersion"), 2);
-
-  do_check_false(policy.dataSubmissionPolicyBypassAcceptance);
-  policyPrefs.set("dataSubmissionPolicyBypassAcceptance", true);
-  do_check_true(policy.dataSubmissionPolicyBypassAcceptance);
-
   policy.lastDataSubmissionRequestedDate = now;
   do_check_eq(hrPrefs.get("lastDataSubmissionRequestedTime"), nowT);
   do_check_eq(policy.lastDataSubmissionRequestedDate.getTime(), nowT);
 
   policy.lastDataSubmissionSuccessfulDate = now;
   do_check_eq(hrPrefs.get("lastDataSubmissionSuccessfulTime"), nowT);
   do_check_eq(policy.lastDataSubmissionSuccessfulDate.getTime(), nowT);
 
@@ -118,189 +90,35 @@
 
   policy.healthReportUploadEnabled = false;
   do_check_false(hrPrefs.get("uploadEnabled"));
   do_check_false(policy.healthReportUploadEnabled);
 
   run_next_test();
 });
 
-add_test(function test_notify_state_prefs() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("notify_state_prefs");
-
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_UNNOTIFIED);
-
-  policy._dataSubmissionPolicyNotifiedDate = new Date();
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_WAIT);
-
-  policy.dataSubmissionPolicyResponseDate = new Date();
-  policy._dataSubmissionPolicyNotifiedDate = null;
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_COMPLETE);
-
-  run_next_test();
-});
-
-add_test(function test_initial_submission_notification() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("initial_submission_notification");
-
-  do_check_eq(listener.notifyUserCount, 0);
-
-  // Fresh instances should not do anything initially.
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 0);
-
-  // We still shouldn't notify up to the millisecond before the barrier.
-  defineNow(policy, new Date(policy.firstRunDate.getTime() +
-                             policy.SUBMISSION_NOTIFY_INTERVAL_MSEC - 1));
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 0);
-  do_check_null(policy._dataSubmissionPolicyNotifiedDate);
-  do_check_eq(policy.dataSubmissionPolicyNotifiedDate.getTime(), 0);
-
-  // We have crossed the threshold. We should see notification.
-  defineNow(policy, new Date(policy.firstRunDate.getTime() +
-                             policy.SUBMISSION_NOTIFY_INTERVAL_MSEC));
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 1);
-  listener.lastNotifyRequest.onUserNotifyComplete();
-  do_check_true(policy._dataSubmissionPolicyNotifiedDate instanceof Date);
-  do_check_true(policy.dataSubmissionPolicyNotifiedDate.getTime() > 0);
-  do_check_eq(policy.dataSubmissionPolicyNotifiedDate.getTime(),
-              policy._dataSubmissionPolicyNotifiedDate.getTime());
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_WAIT);
-
-  run_next_test();
-});
-
-add_test(function test_bypass_acceptance() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("bypass_acceptance");
-
-  policyPrefs.set("dataSubmissionPolicyBypassAcceptance", true);
-  do_check_false(policy.dataSubmissionPolicyAccepted);
-  do_check_true(policy.dataSubmissionPolicyBypassAcceptance);
-  defineNow(policy, new Date(policy.nextDataSubmissionDate.getTime()));
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.requestDataUploadCount, 1);
-
-  run_next_test();
-});
-
-add_test(function test_notification_implicit_acceptance() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("notification_implicit_acceptance");
-
-  let now = new Date(policy.nextDataSubmissionDate.getTime() -
-                     policy.SUBMISSION_NOTIFY_INTERVAL_MSEC + 1);
-  defineNow(policy, now);
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 1);
-  listener.lastNotifyRequest.onUserNotifyComplete();
-  do_check_eq(policy.dataSubmissionPolicyResponseType, "none-recorded");
-
-  do_check_true(5000 < policy.IMPLICIT_ACCEPTANCE_INTERVAL_MSEC);
-  defineNow(policy, new Date(now.getTime() + 5000));
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 1);
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_WAIT);
-  do_check_eq(policy.dataSubmissionPolicyResponseDate.getTime(), 0);
-  do_check_eq(policy.dataSubmissionPolicyResponseType, "none-recorded");
-
-  defineNow(policy, new Date(now.getTime() + policy.IMPLICIT_ACCEPTANCE_INTERVAL_MSEC + 1));
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 1);
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_COMPLETE);
-  do_check_eq(policy.dataSubmissionPolicyResponseDate.getTime(), policy.now().getTime());
-  do_check_eq(policy.dataSubmissionPolicyResponseType, "accepted-implicit-time-elapsed");
-
-  run_next_test();
-});
-
-add_test(function test_notification_rejected() {
-  // User notification failed. We should not record it as being presented.
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("notification_failed");
-
-  let now = new Date(policy.nextDataSubmissionDate.getTime() -
-                     policy.SUBMISSION_NOTIFY_INTERVAL_MSEC + 1);
-  defineNow(policy, now);
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.notifyUserCount, 1);
-  listener.lastNotifyRequest.onUserNotifyFailed(new Error("testing failed."));
-  do_check_null(policy._dataSubmissionPolicyNotifiedDate);
-  do_check_eq(policy.dataSubmissionPolicyNotifiedDate.getTime(), 0);
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_UNNOTIFIED);
-
-  run_next_test();
-});
-
-add_test(function test_notification_accepted() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("notification_accepted");
-
-  let now = new Date(policy.nextDataSubmissionDate.getTime() -
-                     policy.SUBMISSION_NOTIFY_INTERVAL_MSEC + 1);
-  defineNow(policy, now);
-  policy.checkStateAndTrigger();
-  listener.lastNotifyRequest.onUserNotifyComplete();
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_WAIT);
-  do_check_false(policy.dataSubmissionPolicyAccepted);
-  listener.lastNotifyRequest.onUserNotifyComplete();
-  listener.lastNotifyRequest.onUserAccept("foo-bar");
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_COMPLETE);
-  do_check_eq(policy.dataSubmissionPolicyResponseType, "accepted-foo-bar");
-  do_check_true(policy.dataSubmissionPolicyAccepted);
-  do_check_eq(policy.dataSubmissionPolicyResponseDate.getTime(), now.getTime());
-
-  run_next_test();
-});
-
-add_test(function test_notification_rejected() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("notification_rejected");
-
-  let now = new Date(policy.nextDataSubmissionDate.getTime() -
-                     policy.SUBMISSION_NOTIFY_INTERVAL_MSEC + 1);
-  defineNow(policy, now);
-  policy.checkStateAndTrigger();
-  listener.lastNotifyRequest.onUserNotifyComplete();
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_WAIT);
-  do_check_false(policy.dataSubmissionPolicyAccepted);
-  listener.lastNotifyRequest.onUserReject();
-  do_check_eq(policy.notifyState, policy.STATE_NOTIFY_COMPLETE);
-  do_check_eq(policy.dataSubmissionPolicyResponseType, "rejected-no-reason");
-  do_check_false(policy.dataSubmissionPolicyAccepted);
-
-  // No requests for submission should occur if user has rejected.
-  defineNow(policy, new Date(policy.nextDataSubmissionDate.getTime() + 10000));
-  policy.checkStateAndTrigger();
-  do_check_eq(listener.requestDataUploadCount, 0);
-
-  run_next_test();
-});
-
 add_test(function test_submission_kill_switch() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("submission_kill_switch");
 
-  policy.firstRunDate = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
   policy.nextDataSubmissionDate = new Date(Date.now() - 24 * 60 * 60 * 1000);
-  policy.recordUserAcceptance("accept-old-ack");
-  do_check_eq(policyPrefs.get("dataSubmissionPolicyAcceptedVersion"), 1);
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestDataUploadCount, 1);
 
   defineNow(policy,
     new Date(Date.now() + policy.SUBMISSION_REQUEST_EXPIRE_INTERVAL_MSEC + 100));
   policy.dataSubmissionEnabled = false;
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestDataUploadCount, 1);
 
   run_next_test();
 });
 
 add_test(function test_upload_kill_switch() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("upload_kill_switch");
 
-  defineNow(policy, policy._futureDate(-24 * 60 * 60 * 1000));
-  policy.recordUserAcceptance();
   defineNow(policy, policy.nextDataSubmissionDate);
 
   // So that we don't trigger deletions, which cause uploads to be delayed.
   hrPrefs.ignore("uploadEnabled", policy.uploadEnabledObserver);
 
   policy.healthReportUploadEnabled = false;
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestDataUploadCount, 0);
@@ -354,17 +172,16 @@
   do_check_eq(listener.requestDataUploadCount, 1);
 
   run_next_test();
 });
 
 add_test(function test_data_submission_submit_try_again() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("data_submission_failure_soft");
 
-  policy.recordUserAcceptance();
   let nextDataSubmissionDate = policy.nextDataSubmissionDate;
   let now = new Date(policy.nextDataSubmissionDate.getTime());
   defineNow(policy, now);
   policy.checkStateAndTrigger();
   listener.lastDataRequest.onSubmissionFailureSoft();
   do_check_eq(policy.nextDataSubmissionDate.getTime(),
               nextDataSubmissionDate.getTime() + 15 * 60 * 1000);
 
@@ -409,21 +226,17 @@
     new Date(nextScheduled.getTime() + 24 * 60 * 60 * 1000 + 200).getTime());
 
   run_next_test();
 });
 
 add_test(function test_submission_far_future_scheduling() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("submission_far_future_scheduling");
 
-  let now = new Date(Date.now() - 24 * 60 * 60 * 1000);
-  defineNow(policy, now);
-  policy.recordUserAcceptance();
-  now = new Date();
-  defineNow(policy, now);
+  defineNow(policy, new Date());
 
   let nextDate = policy._futureDate(3 * 24 * 60 * 60 * 1000 - 1);
   policy.nextDataSubmissionDate = nextDate;
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestDataUploadCount, 0);
   do_check_eq(policy.nextDataSubmissionDate.getTime(), nextDate.getTime());
 
   policy.nextDataSubmissionDate = new Date(nextDate.getTime() + 1);
@@ -546,18 +359,16 @@
   run_next_test();
 });
 
 // Ensure that deletion requests take priority over regular data submission.
 add_test(function test_delete_remote_data_priority() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("delete_remote_data_priority");
 
   let now = new Date();
-  defineNow(policy, policy._futureDate(-24 * 60 * 60 * 1000));
-  policy.recordUserAcceptance();
   defineNow(policy, new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000));
 
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestDataUploadCount, 1);
   policy._inProgressSubmissionRequest = null;
 
   policy.deleteRemoteData();
   policy.checkStateAndTrigger();
@@ -567,18 +378,16 @@
 
   run_next_test();
 });
 
 add_test(function test_delete_remote_data_backoff() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("delete_remote_data_backoff");
 
   let now = new Date();
-  defineNow(policy, policy._futureDate(-24 * 60 * 60 * 1000));
-  policy.recordUserAcceptance();
   defineNow(policy, now);
   policy.nextDataSubmissionDate = now;
   policy.deleteRemoteData();
 
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestRemoteDeleteCount, 1);
   defineNow(policy, policy._futureDate(1000));
   policy.checkStateAndTrigger();
@@ -599,19 +408,16 @@
   run_next_test();
 });
 
 // If we request delete while an upload is in progress, delete should be
 // scheduled immediately after upload.
 add_test(function test_delete_remote_data_in_progress_upload() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("delete_remote_data_in_progress_upload");
 
-  let now = new Date();
-  defineNow(policy, policy._futureDate(-24 * 60 * 60 * 1000));
-  policy.recordUserAcceptance();
   defineNow(policy, policy.nextDataSubmissionDate);
 
   policy.checkStateAndTrigger();
   do_check_eq(listener.requestDataUploadCount, 1);
   defineNow(policy, policy._futureDate(50 * 1000));
 
   // If we request a delete during a pending request, nothing should be done.
   policy.deleteRemoteData();
@@ -652,17 +458,16 @@
 
       print("Polled at " + now + " after " + after + "ms, intended " + intended);
       do_check_true(after >= acceptable);
       DataReportingPolicy.prototype.checkStateAndTrigger.call(policy);
 
       if (count >= 2) {
         policy.stopPolling();
 
-        do_check_eq(listener.notifyUserCount, 0);
         do_check_eq(listener.requestDataUploadCount, 0);
 
         run_next_test();
       }
 
       // "Specified timer period will be at least the time between when
       // processing for last firing the callback completes and when the next
       // firing occurs."
@@ -670,88 +475,16 @@
       // That means we should set 'then' at the *end* of our handler, not
       // earlier.
       then = Date.now();
     }
   });
   policy.startPolling();
 });
 
-// Ensure that implicit acceptance of policy is resolved through polling.
-//
-// This is probably covered by other tests. But, it's best to have explicit
-// coverage from a higher-level.
-add_test(function test_polling_implicit_acceptance() {
-  let [policy, policyPrefs, hrPrefs, listener] = getPolicy("polling_implicit_acceptance");
-
-  // Redefine intervals with shorter, test-friendly values.
-  Object.defineProperty(policy, "POLL_INTERVAL_MSEC", {
-    value: 250,
-  });
-
-  Object.defineProperty(policy, "IMPLICIT_ACCEPTANCE_INTERVAL_MSEC", {
-    value: 750,
-  });
-
-  let count = 0;
-
-  // Track JS elapsed time, so we can decide if we've waited for enough ticks.
-  let start;
-  Object.defineProperty(policy, "checkStateAndTrigger", {
-    value: function CheckStateAndTriggerProxy() {
-      count++;
-      let now = Date.now();
-      let delta = now - start;
-      print("checkStateAndTrigger count: " + count + ", now " + now +
-            ", delta " + delta);
-
-      // Account for some slack.
-      DataReportingPolicy.prototype.checkStateAndTrigger.call(policy);
-
-      // What should happen on different invocations:
-      //
-      //   1) We are inside the prompt interval so user gets prompted.
-      //   2) still ~300ms away from implicit acceptance
-      //   3) still ~50ms away from implicit acceptance
-      //   4) Implicit acceptance recorded. Data submission requested.
-      //   5) Request still pending. No new submission requested.
-      //
-      // Note that, due to the inaccuracy of timers, 4 might not happen until 5
-      // firings have occurred. Yay. So we watch times, not just counts.
-
-      do_check_eq(listener.notifyUserCount, 1);
-
-      if (count == 1) {
-        listener.lastNotifyRequest.onUserNotifyComplete();
-      }
-
-      if (delta <= (750 + 250)) {
-        do_check_false(policy.dataSubmissionPolicyAccepted);
-        do_check_eq(listener.requestDataUploadCount, 0);
-      } else if (count > 3) {
-        do_check_true(policy.dataSubmissionPolicyAccepted);
-        do_check_eq(policy.dataSubmissionPolicyResponseType,
-                    "accepted-implicit-time-elapsed");
-        do_check_eq(listener.requestDataUploadCount, 1);
-      }
-
-      if ((count > 4) && policy.dataSubmissionPolicyAccepted) {
-        do_check_eq(listener.requestDataUploadCount, 1);
-        policy.stopPolling();
-        run_next_test();
-      }
-    }
-  });
-
-  policy.firstRunDate = new Date(Date.now() - 4 * 24 * 60 * 60 * 1000);
-  policy.nextDataSubmissionDate = new Date(Date.now());
-  start = Date.now();
-  policy.startPolling();
-});
-
 add_test(function test_record_health_report_upload_enabled() {
   let [policy, policyPrefs, hrPrefs, listener] = getPolicy("record_health_report_upload_enabled");
 
   // Preconditions.
   do_check_false(policy.pendingDeleteRemoteData);
   do_check_true(policy.healthReportUploadEnabled);
   do_check_eq(listener.requestRemoteDeleteCount, 0);
 
@@ -791,9 +524,9 @@
       do_check_false(policy.pendingDeleteRemoteData);     // Just called.
 
       run_next_test();
     },
   });
 
   hrPrefs.set("uploadEnabled", false);
 });
- 
+
