From: Ms2ger <ms2ger@gmail.com>

diff --git a/dom/base/Attr.cpp b/dom/base/Attr.cpp
--- a/dom/base/Attr.cpp
+++ b/dom/base/Attr.cpp
@@ -132,28 +132,28 @@
   }
   nsIContent* content = mAttrMap->GetContent();
   return content ? content->AsElement() : nullptr;
 }
 
 nsresult
 Attr::SetOwnerDocument(nsIDocument* aDocument)
 {
-  NS_ASSERTION(aDocument, "Missing document");
+  MOZ_ASSERT(aDocument, "Missing document");
 
   nsIDocument *doc = OwnerDoc();
-  NS_ASSERTION(doc != aDocument, "bad call to Attr::SetOwnerDocument");
+  MOZ_ASSERT(doc != aDocument, "bad call to Attr::SetOwnerDocument");
   doc->DeleteAllPropertiesFor(this);
 
   nsRefPtr<mozilla::dom::NodeInfo> newNodeInfo;
   newNodeInfo = aDocument->NodeInfoManager()->
     GetNodeInfo(mNodeInfo->NameAtom(), mNodeInfo->GetPrefixAtom(),
                 mNodeInfo->NamespaceID(),
                 nsIDOMNode::ATTRIBUTE_NODE);
-  NS_ASSERTION(newNodeInfo, "GetNodeInfo lies");
+  MOZ_ASSERT(newNodeInfo, "GetNodeInfo lies");
   mNodeInfo.swap(newNodeInfo);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 Attr::GetName(nsAString& aName)
 {
diff --git a/dom/base/Crypto.cpp b/dom/base/Crypto.cpp
--- a/dom/base/Crypto.cpp
+++ b/dom/base/Crypto.cpp
@@ -93,18 +93,18 @@
     InfallibleTArray<uint8_t> randomValues;
     // Tell the parent process to generate random values via PContent
     ContentChild* cc = ContentChild::GetSingleton();
     if (!cc->SendGetRandomValues(dataLen, &randomValues) ||
         randomValues.Length() == 0) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
-    NS_ASSERTION(dataLen == randomValues.Length(),
-                 "Invalid length returned from parent process!");
+    MOZ_ASSERT(dataLen == randomValues.Length(),
+               "Invalid length returned from parent process!");
     memcpy(data, randomValues.Elements(), dataLen);
   } else {
     uint8_t *buf = GetRandomValues(dataLen);
 
     if (!buf) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
diff --git a/dom/base/DOMParser.cpp b/dom/base/DOMParser.cpp
--- a/dom/base/DOMParser.cpp
+++ b/dom/base/DOMParser.cpp
@@ -467,18 +467,18 @@
     nsCOMPtr<nsIPrincipal> prin =
       do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = Init(prin, nullptr, nullptr, scriptHandlingObject);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  NS_ASSERTION(mPrincipal, "Must have principal by now");
-  NS_ASSERTION(mDocumentURI, "Must have document URI by now");
+  MOZ_ASSERT(mPrincipal, "Must have principal by now");
+  MOZ_ASSERT(mDocumentURI, "Must have document URI by now");
 
   // Here we have to cheat a little bit...  Setting the base URI won't
   // work if the document has a null principal, so use
   // mOriginalPrincipal when creating the document, then reset the
   // principal.
   return NS_NewDOMDocument(aResult, EmptyString(), EmptyString(), nullptr,
                            mDocumentURI, mBaseURI,
                            mOriginalPrincipal,
diff --git a/dom/base/DOMRect.h b/dom/base/DOMRect.h
--- a/dom/base/DOMRect.h
+++ b/dom/base/DOMRect.h
@@ -174,18 +174,18 @@
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMClientRectList> list_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
       // question doesn't use the nsIDOMClientRectList pointer as the nsISupports
       // pointer. That must be fixed, or we'll crash...
-      NS_ASSERTION(list_qi == static_cast<nsIDOMClientRectList*>(aSupports),
-                   "Uh, fix QI!");
+      MOZ_ASSERT(list_qi == static_cast<nsIDOMClientRectList*>(aSupports),
+                 "Uh, fix QI!");
     }
 #endif
 
     return static_cast<DOMRectList*>(aSupports);
   }
 
   uint32_t Length()
   {
diff --git a/dom/base/DOMRequest.cpp b/dom/base/DOMRequest.cpp
--- a/dom/base/DOMRequest.cpp
+++ b/dom/base/DOMRequest.cpp
@@ -104,19 +104,19 @@
 {
   NS_IF_ADDREF(*aError = GetError());
   return NS_OK;
 }
 
 void
 DOMRequest::FireSuccess(JS::Handle<JS::Value> aResult)
 {
-  NS_ASSERTION(!mDone, "mDone shouldn't have been set to true already!");
-  NS_ASSERTION(!mError, "mError shouldn't have been set!");
-  NS_ASSERTION(mResult.isUndefined(), "mResult shouldn't have been set!");
+  MOZ_ASSERT(!mDone, "mDone shouldn't have been set to true already!");
+  MOZ_ASSERT(!mError, "mError shouldn't have been set!");
+  MOZ_ASSERT(mResult.isUndefined(), "mResult shouldn't have been set!");
 
   mDone = true;
   if (aResult.isGCThing()) {
     RootResultVal();
   }
   mResult = aResult;
 
   FireEvent(NS_LITERAL_STRING("success"), false, false);
@@ -124,54 +124,54 @@
   if (mPromise) {
     mPromise->MaybeResolve(mResult);
   }
 }
 
 void
 DOMRequest::FireError(const nsAString& aError)
 {
-  NS_ASSERTION(!mDone, "mDone shouldn't have been set to true already!");
-  NS_ASSERTION(!mError, "mError shouldn't have been set!");
-  NS_ASSERTION(mResult.isUndefined(), "mResult shouldn't have been set!");
+  MOZ_ASSERT(!mDone, "mDone shouldn't have been set to true already!");
+  MOZ_ASSERT(!mError, "mError shouldn't have been set!");
+  MOZ_ASSERT(mResult.isUndefined(), "mResult shouldn't have been set!");
 
   mDone = true;
   mError = new DOMError(GetOwner(), aError);
 
   FireEvent(NS_LITERAL_STRING("error"), true, true);
 
   if (mPromise) {
     mPromise->MaybeRejectBrokenly(mError);
   }
 }
 
 void
 DOMRequest::FireError(nsresult aError)
 {
-  NS_ASSERTION(!mDone, "mDone shouldn't have been set to true already!");
-  NS_ASSERTION(!mError, "mError shouldn't have been set!");
-  NS_ASSERTION(mResult.isUndefined(), "mResult shouldn't have been set!");
+  MOZ_ASSERT(!mDone, "mDone shouldn't have been set to true already!");
+  MOZ_ASSERT(!mError, "mError shouldn't have been set!");
+  MOZ_ASSERT(mResult.isUndefined(), "mResult shouldn't have been set!");
 
   mDone = true;
   mError = new DOMError(GetOwner(), aError);
 
   FireEvent(NS_LITERAL_STRING("error"), true, true);
 
   if (mPromise) {
     mPromise->MaybeRejectBrokenly(mError);
   }
 }
 
 void
 DOMRequest::FireDetailedError(DOMError* aError)
 {
-  NS_ASSERTION(!mDone, "mDone shouldn't have been set to true already!");
-  NS_ASSERTION(!mError, "mError shouldn't have been set!");
-  NS_ASSERTION(mResult.isUndefined(), "mResult shouldn't have been set!");
-  NS_ASSERTION(aError, "No detailed error provided");
+  MOZ_ASSERT(!mDone, "mDone shouldn't have been set to true already!");
+  MOZ_ASSERT(!mError, "mError shouldn't have been set!");
+  MOZ_ASSERT(mResult.isUndefined(), "mResult shouldn't have been set!");
+  MOZ_ASSERT(aError, "No detailed error provided");
 
   mDone = true;
   mError = aError;
 
   FireEvent(NS_LITERAL_STRING("error"), true, true);
 
   if (mPromise) {
     mPromise->MaybeRejectBrokenly(mError);
@@ -301,17 +301,17 @@
 
   // Due to the fact that initialization can fail during shutdown (since we
   // can't fetch a js context), set up an initiatization function to make sure
   // we can return the failure appropriately
   static nsresult
   Dispatch(DOMRequest* aRequest,
            const JS::Value& aResult)
   {
-    NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+    MOZ_ASSERT(NS_IsMainThread(), "Wrong thread!");
     mozilla::ThreadsafeAutoSafeJSContext cx;
     nsRefPtr<FireSuccessAsyncTask> asyncTask = new FireSuccessAsyncTask(cx, aRequest, aResult);
     if (NS_FAILED(NS_DispatchToMainThread(asyncTask))) {
       NS_WARNING("Failed to dispatch to main thread!");
       return NS_ERROR_FAILURE;
     }
     return NS_OK;
   }
@@ -320,17 +320,17 @@
   Run()
   {
     mReq->FireSuccess(JS::Handle<JS::Value>::fromMarkedLocation(mResult.address()));
     return NS_OK;
   }
 
   ~FireSuccessAsyncTask()
   {
-    NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+    MOZ_ASSERT(NS_IsMainThread(), "Wrong thread!");
   }
 
 private:
   nsRefPtr<DOMRequest> mReq;
   JS::PersistentRooted<JS::Value> mResult;
 };
 
 class FireErrorAsyncTask : public nsRunnable
diff --git a/dom/base/DOMRequest.h b/dom/base/DOMRequest.h
--- a/dom/base/DOMRequest.h
+++ b/dom/base/DOMRequest.h
@@ -53,26 +53,25 @@
   DOMRequestReadyState ReadyState() const
   {
     return mDone ? DOMRequestReadyState::Done
                  : DOMRequestReadyState::Pending;
   }
 
   void GetResult(JSContext*, JS::MutableHandle<JS::Value> aRetval) const
   {
-    NS_ASSERTION(mDone || mResult.isUndefined(),
-                 "Result should be undefined when pending");
+    MOZ_ASSERT(mDone || mResult.isUndefined(),
+               "Result should be undefined when pending");
     JS::ExposeValueToActiveJS(mResult);
     aRetval.set(mResult);
   }
 
   DOMError* GetError() const
   {
-    NS_ASSERTION(mDone || !mError,
-                 "Error should be null when pending");
+    MOZ_ASSERT(mDone || !mError, "Error should be null when pending");
     return mError;
   }
 
   IMPL_EVENT_HANDLER(success)
   IMPL_EVENT_HANDLER(error)
 
   already_AddRefed<mozilla::dom::Promise>
   Then(JSContext* aCx, AnyCallback* aResolveCallback,
diff --git a/dom/base/DirectionalityUtils.cpp b/dom/base/DirectionalityUtils.cpp
--- a/dom/base/DirectionalityUtils.cpp
+++ b/dom/base/DirectionalityUtils.cpp
@@ -460,18 +460,18 @@
       mElements.Put(aElement);
       aElement->SetProperty(nsGkAtoms::dirAutoSetBy, aTextNode);
       aElement->SetHasDirAutoSet();
     }
   }
 
   void RemoveEntry(nsINode* aTextNode, Element* aElement)
   {
-    NS_ASSERTION(mElements.Contains(aElement),
-                 "element already removed from map");
+    MOZ_ASSERT(mElements.Contains(aElement),
+               "element already removed from map");
 
     mElements.Remove(aElement);
     aElement->ClearHasDirAutoSet();
     aElement->UnsetProperty(nsGkAtoms::dirAutoSetBy);
   }
 
 private:
   nsCheapSet<nsPtrHashKey<Element> > mElements;
diff --git a/dom/base/DocumentFragment.h b/dom/base/DocumentFragment.h
--- a/dom/base/DocumentFragment.h
+++ b/dom/base/DocumentFragment.h
@@ -97,23 +97,23 @@
   virtual bool IsNodeOfType(uint32_t aFlags) const MOZ_OVERRIDE;
 
   virtual nsIDOMNode* AsDOMNode() MOZ_OVERRIDE { return this; }
 
   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                               nsIContent* aBindingParent,
                               bool aCompileEventHandlers) MOZ_OVERRIDE
   {
-    NS_ASSERTION(false, "Trying to bind a fragment to a tree");
+    MOZ_ASSERT(false, "Trying to bind a fragment to a tree");
     return NS_ERROR_NOT_IMPLEMENTED;
   }
 
   virtual void UnbindFromTree(bool aDeep, bool aNullParent) MOZ_OVERRIDE
   {
-    NS_ASSERTION(false, "Trying to unbind a fragment from a tree");
+    MOZ_ASSERT(false, "Trying to unbind a fragment from a tree");
     return;
   }
 
   virtual Element* GetNameSpaceElement() MOZ_OVERRIDE
   {
     return nullptr;
   }
 
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -167,18 +167,17 @@
   }
 
   return AsElement()->GetParsedAttr(nsGkAtoms::_class);
 }
 
 NS_IMETHODIMP
 Element::QueryInterface(REFNSIID aIID, void** aInstancePtr)
 {
-  NS_ASSERTION(aInstancePtr,
-               "QueryInterface requires a non-NULL destination!");
+  MOZ_ASSERT(aInstancePtr, "QueryInterface requires a non-NULL destination!");
   nsresult rv = FragmentOrElement::QueryInterface(aIID, aInstancePtr);
   if (NS_SUCCEEDED(rv)) {
     return NS_OK;
   }
 
   // Give the binding manager a chance to get an interface for this element.
   return OwnerDoc()->BindingManager()->GetBindingImplementation(this, aIID,
                                                                 aInstancePtr);
@@ -228,17 +227,17 @@
     }
   }
 }
 
 void
 nsIContent::UpdateEditableState(bool aNotify)
 {
   // Guaranteed to be non-element content
-  NS_ASSERTION(!IsElement(), "What happened here?");
+  MOZ_ASSERT(!IsElement(), "What happened here?");
   nsIContent *parent = GetParent();
 
   // Skip over unknown native anonymous content to avoid setting a flag we
   // can't clear later
   bool isUnknownNativeAnon = false;
   if (IsInNativeAnonymousSubtree()) {
     isUnknownNativeAnon = true;
     nsCOMPtr<nsIContent> root = this;
@@ -912,17 +911,17 @@
 }
 
 
 //----------------------------------------------------------------------
 
 void
 Element::AddToIdTable(nsIAtom* aId)
 {
-  NS_ASSERTION(HasID(), "Node doesn't have an ID?");
+  MOZ_ASSERT(HasID(), "Node doesn't have an ID?");
   if (IsInShadowTree()) {
     ShadowRoot* containingShadow = GetContainingShadow();
     containingShadow->AddToIdTable(this, aId);
   } else {
     nsIDocument* doc = GetUncomposedDoc();
     if (doc && (!IsInAnonymousSubtree() || doc->IsXUL())) {
       doc->AddToIdTable(this, aId);
     }
@@ -1299,17 +1298,17 @@
     aError =
       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
                                                             nameSpaceId);
     if (aError.Failed()) {
       return nullptr;
     }
   }
 
-  NS_ASSERTION(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
+  MOZ_ASSERT(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
 
   return NS_GetContentList(this, nameSpaceId, aLocalName);
 }
 
 nsresult
 Element::GetElementsByTagNameNS(const nsAString& namespaceURI,
                                 const nsAString& localName,
                                 nsIDOMHTMLCollection** aResult)
@@ -1398,21 +1397,21 @@
 #endif
   {
     if (aBindingParent) {
       nsDOMSlots *slots = DOMSlots();
 
       slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
     }
   }
-  NS_ASSERTION(!aBindingParent || IsRootOfNativeAnonymousSubtree() ||
+  MOZ_ASSERT(!aBindingParent || IsRootOfNativeAnonymousSubtree() ||
                !HasFlag(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE) ||
                (aParent && aParent->IsInNativeAnonymousSubtree()),
-               "Trying to re-bind content from native anonymous subtree to "
-               "non-native anonymous parent!");
+             "Trying to re-bind content from native anonymous subtree to "
+             "non-native anonymous parent!");
   if (aParent) {
     if (aParent->IsInNativeAnonymousSubtree()) {
       SetFlags(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE);
     }
     if (aParent->HasFlag(NODE_CHROME_ONLY_ACCESS)) {
       SetFlags(NODE_CHROME_ONLY_ACCESS);
     }
     if (aParent->IsInShadowTree()) {
@@ -2111,18 +2110,18 @@
 nsresult
 Element::SetAttr(int32_t aNamespaceID, nsIAtom* aName,
                  nsIAtom* aPrefix, const nsAString& aValue,
                  bool aNotify)
 {
   // Keep this in sync with SetParsedAttr below
 
   NS_ENSURE_ARG_POINTER(aName);
-  NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
-               "Don't call SetAttr with unknown namespace");
+  MOZ_ASSERT(aNamespaceID != kNameSpaceID_Unknown,
+             "Don't call SetAttr with unknown namespace");
 
   if (!mAttrsAndChildren.CanFitMoreAttrs()) {
     return NS_ERROR_FAILURE;
   }
 
   uint8_t modType;
   bool hasListeners;
   nsAttrValueOrString value(aValue);
@@ -2157,18 +2156,18 @@
 nsresult
 Element::SetParsedAttr(int32_t aNamespaceID, nsIAtom* aName,
                        nsIAtom* aPrefix, nsAttrValue& aParsedValue,
                        bool aNotify)
 {
   // Keep this in sync with SetAttr above
 
   NS_ENSURE_ARG_POINTER(aName);
-  NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
-               "Don't call SetAttr with unknown namespace");
+  MOZ_ASSERT(aNamespaceID != kNameSpaceID_Unknown,
+             "Don't call SetAttr with unknown namespace");
 
   if (!mAttrsAndChildren.CanFitMoreAttrs()) {
     return NS_ERROR_FAILURE;
   }
 
 
   uint8_t modType;
   bool hasListeners;
@@ -2353,19 +2352,19 @@
 {
   *aDefer = true;
   return GetOrCreateListenerManager();
 }
 
 Element::nsAttrInfo
 Element::GetAttrInfo(int32_t aNamespaceID, nsIAtom* aName) const
 {
-  NS_ASSERTION(nullptr != aName, "must have attribute name");
-  NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
-               "must have a real namespace ID!");
+  MOZ_ASSERT(nullptr != aName, "must have attribute name");
+  MOZ_ASSERT(aNamespaceID != kNameSpaceID_Unknown,
+             "must have a real namespace ID!");
 
   int32_t index = mAttrsAndChildren.IndexOfAttr(aName, aNamespaceID);
   if (index >= 0) {
     return nsAttrInfo(mAttrsAndChildren.AttrNameAt(index),
                       mAttrsAndChildren.AttrAt(index));
   }
 
   return nsAttrInfo(nullptr, nullptr);
@@ -2383,37 +2382,37 @@
 }
 
 int32_t
 Element::FindAttrValueIn(int32_t aNameSpaceID,
                          nsIAtom* aName,
                          AttrValuesArray* aValues,
                          nsCaseTreatment aCaseSensitive) const
 {
-  NS_ASSERTION(aName, "Must have attr name");
-  NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
-  NS_ASSERTION(aValues, "Null value array");
-  
+  MOZ_ASSERT(aName, "Must have attr name");
+  MOZ_ASSERT(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
+  MOZ_ASSERT(aValues, "Null value array");
+
   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   if (val) {
     for (int32_t i = 0; aValues[i]; ++i) {
       if (val->Equals(*aValues[i], aCaseSensitive)) {
         return i;
       }
     }
     return ATTR_VALUE_NO_MATCH;
   }
   return ATTR_MISSING;
 }
 
 nsresult
 Element::UnsetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                    bool aNotify)
 {
-  NS_ASSERTION(nullptr != aName, "must have attribute name");
+  MOZ_ASSERT(nullptr != aName, "must have attribute name");
 
   int32_t index = mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID);
   if (index < 0) {
     return NS_OK;
   }
 
   nsresult rv = BeforeSetAttr(aNameSpaceID, aName, nullptr, aNotify);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -3201,17 +3200,18 @@
 
   if (OwnerDoc()->IsHTML()) {
     nsIAtom* localName;
     int32_t namespaceID;
     if (parent->IsElement()) {
       localName = static_cast<nsIContent*>(parent.get())->Tag();
       namespaceID = static_cast<nsIContent*>(parent.get())->GetNameSpaceID();
     } else {
-      NS_ASSERTION(parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
+      MOZ_ASSERT(
+        parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
         "How come the parent isn't a document, a fragment or an element?");
       localName = nsGkAtoms::body;
       namespaceID = kNameSpaceID_XHTML;
     }
     nsRefPtr<DocumentFragment> fragment =
       new DocumentFragment(OwnerDoc()->NodeInfoManager());
     nsContentUtils::ParseFragmentHTML(aOuterHTML,
                                       fragment,
@@ -3223,17 +3223,18 @@
     parent->ReplaceChild(*fragment, *this, aError);
     return;
   }
 
   nsCOMPtr<nsINode> context;
   if (parent->IsElement()) {
     context = parent;
   } else {
-    NS_ASSERTION(parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
+    MOZ_ASSERT(
+      parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
       "How come the parent isn't a document, a fragment or an element?");
     nsRefPtr<mozilla::dom::NodeInfo> info =
       OwnerDoc()->NodeInfoManager()->GetNodeInfo(nsGkAtoms::body,
                                                  nullptr,
                                                  kNameSpaceID_XHTML,
                                                  nsIDOMNode::ELEMENT_NODE);
     context = NS_NewHTMLBodyElement(info.forget(), FROM_PARSER_FRAGMENT);
   }
diff --git a/dom/base/Element.h b/dom/base/Element.h
--- a/dom/base/Element.h
+++ b/dom/base/Element.h
@@ -558,19 +558,19 @@
   FindAttributeDependence(const nsIAtom* aAttribute,
                           const MappedAttributeEntry* const aMaps[],
                           uint32_t aMapCount);
 
 protected:
   inline bool GetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                       DOMString& aResult) const
   {
-    NS_ASSERTION(nullptr != aName, "must have attribute name");
-    NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
-                 "must have a real namespace ID!");
+    MOZ_ASSERT(nullptr != aName, "must have attribute name");
+    MOZ_ASSERT(aNameSpaceID != kNameSpaceID_Unknown,
+               "must have a real namespace ID!");
     MOZ_ASSERT(aResult.HasStringBuffer() && aResult.StringBufferLength() == 0,
                "Should have empty string coming in");
     const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
     if (val) {
       val->ToString(aResult);
       return true;
     }
     // else DOMString comes pre-emptied.
@@ -1333,45 +1333,45 @@
   nsCOMArray<nsIContent> mDestinationPoints;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(Element, NS_ELEMENT_IID)
 
 inline bool
 Element::HasAttr(int32_t aNameSpaceID, nsIAtom* aName) const
 {
-  NS_ASSERTION(nullptr != aName, "must have attribute name");
-  NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
-               "must have a real namespace ID!");
+  MOZ_ASSERT(nullptr != aName, "must have attribute name");
+  MOZ_ASSERT(aNameSpaceID != kNameSpaceID_Unknown,
+             "must have a real namespace ID!");
 
   return mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID) >= 0;
 }
 
 inline bool
 Element::AttrValueIs(int32_t aNameSpaceID,
                      nsIAtom* aName,
                      const nsAString& aValue,
                      nsCaseTreatment aCaseSensitive) const
 {
-  NS_ASSERTION(aName, "Must have attr name");
-  NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
+  MOZ_ASSERT(aName, "Must have attr name");
+  MOZ_ASSERT(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
 
   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   return val && val->Equals(aValue, aCaseSensitive);
 }
 
 inline bool
 Element::AttrValueIs(int32_t aNameSpaceID,
                      nsIAtom* aName,
                      nsIAtom* aValue,
                      nsCaseTreatment aCaseSensitive) const
 {
-  NS_ASSERTION(aName, "Must have attr name");
-  NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
-  NS_ASSERTION(aValue, "Null value atom");
+  MOZ_ASSERT(aName, "Must have attr name");
+  MOZ_ASSERT(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
+  MOZ_ASSERT(aValue, "Null value atom");
 
   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   return val && val->Equals(aValue, aCaseSensitive);
 }
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/base/EventSource.cpp b/dom/base/EventSource.cpp
--- a/dom/base/EventSource.cpp
+++ b/dom/base/EventSource.cpp
@@ -306,20 +306,20 @@
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aSubject);
   if (!GetOwner() || window != GetOwner()) {
     return NS_OK;
   }
 
   DebugOnly<nsresult> rv;
   if (strcmp(aTopic, DOM_WINDOW_FROZEN_TOPIC) == 0) {
     rv = Freeze();
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Freeze() failed");
+    MOZ_ASSERT(NS_SUCCEEDED(rv), "Freeze() failed");
   } else if (strcmp(aTopic, DOM_WINDOW_THAWED_TOPIC) == 0) {
     rv = Thaw();
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Thaw() failed");
+    MOZ_ASSERT(NS_SUCCEEDED(rv), "Thaw() failed");
   } else if (strcmp(aTopic, DOM_WINDOW_DESTROYED_TOPIC) == 0) {
     Close();
   }
 
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
@@ -626,17 +626,17 @@
     return NS_OK;
   }
 
   // Now give mNotificationCallbacks (if non-null) a chance to return the
   // desired interface.
   if (mNotificationCallbacks) {
     nsresult rv = mNotificationCallbacks->GetInterface(aIID, aResult);
     if (NS_SUCCEEDED(rv)) {
-      NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
+      MOZ_ASSERT(*aResult, "Lying nsIInterfaceRequestor implementation!");
       return rv;
     }
   }
 
   if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
       aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
     nsresult rv = CheckInnerWindowCorrectness();
     NS_ENSURE_SUCCESS(rv, NS_ERROR_UNEXPECTED);
@@ -1155,17 +1155,17 @@
 
 nsresult
 EventSource::Thaw()
 {
   if (mReadyState == CLOSED || !mFrozen) {
     return NS_OK;
   }
 
-  NS_ASSERTION(!mHttpChannel, "the connection hasn't been closed!!!");
+  MOZ_ASSERT(!mHttpChannel, "the connection hasn't been closed!!!");
 
   mFrozen = false;
   nsresult rv;
   if (!mGoingToDispatchAllMessages && mMessagesToDispatch.GetSize() > 0) {
     nsCOMPtr<nsIRunnable> event =
       NS_NewRunnableMethod(this, &EventSource::DispatchAllMessageEvents);
     NS_ENSURE_STATE(event);
 
@@ -1183,17 +1183,17 @@
 
 nsresult
 EventSource::Freeze()
 {
   if (mReadyState == CLOSED || mFrozen) {
     return NS_OK;
   }
 
-  NS_ASSERTION(!mHttpChannel, "the connection hasn't been closed!!!");
+  MOZ_ASSERT(!mHttpChannel, "the connection hasn't been closed!!!");
   mFrozen = true;
   return NS_OK;
 }
 
 nsresult
 EventSource::DispatchCurrentMessageEvent()
 {
   nsAutoPtr<Message> message(new Message());
@@ -1201,18 +1201,18 @@
 
   ClearFields();
 
   if (message->mData.IsEmpty()) {
     return NS_OK;
   }
 
   // removes the trailing LF from mData
-  NS_ASSERTION(message->mData.CharAt(message->mData.Length() - 1) == LF_CHAR,
-               "Invalid trailing character! LF was expected instead.");
+  MOZ_ASSERT(message->mData.CharAt(message->mData.Length() - 1) == LF_CHAR,
+             "Invalid trailing character! LF was expected instead.");
   message->mData.SetLength(message->mData.Length() - 1);
 
   if (message->mEventName.IsEmpty()) {
     message->mEventName.AssignLiteral("message");
   }
 
   if (message->mLastEventID.IsEmpty() && !mLastEventID.IsEmpty()) {
     message->mLastEventID.Assign(mLastEventID);
diff --git a/dom/base/File.cpp b/dom/base/File.cpp
--- a/dom/base/File.cpp
+++ b/dom/base/File.cpp
@@ -76,17 +76,17 @@
   ~DataOwnerAdapter() {}
 
   DataOwnerAdapter(DataOwner* aDataOwner,
                    nsIInputStream* aStream)
     : mDataOwner(aDataOwner), mStream(aStream),
       mSeekableStream(do_QueryInterface(aStream)),
       mSerializableInputStream(do_QueryInterface(aStream))
   {
-    NS_ASSERTION(mSeekableStream, "Somebody gave us the wrong stream!");
+    MOZ_ASSERT(mSeekableStream, "Somebody gave us the wrong stream!");
   }
 
   nsRefPtr<DataOwner> mDataOwner;
   nsCOMPtr<nsIInputStream> mStream;
   nsCOMPtr<nsISeekableStream> mSeekableStream;
   nsCOMPtr<nsIIPCSerializableInputStream> mSerializableInputStream;
 };
 
@@ -102,17 +102,17 @@
 NS_INTERFACE_MAP_END
 
 nsresult DataOwnerAdapter::Create(DataOwner* aDataOwner,
                                   uint32_t aStart,
                                   uint32_t aLength,
                                   nsIInputStream** _retval)
 {
   nsresult rv;
-  NS_ASSERTION(aDataOwner, "Uh ...");
+  MOZ_ASSERT(aDataOwner, "Uh ...");
 
   nsCOMPtr<nsIInputStream> stream;
 
   rv = NS_NewByteInputStream(getter_AddRefs(stream),
                              static_cast<const char*>(aDataOwner->mData) +
                              aStart,
                              (int32_t)aLength,
                              NS_ASSIGNMENT_DEPEND);
@@ -722,32 +722,32 @@
 ////////////////////////////////////////////////////////////////////////////
 // FileImplFile implementation
 
 NS_IMPL_ISUPPORTS_INHERITED0(FileImplFile, FileImpl)
 
 void
 FileImplBase::GetName(nsAString& aName)
 {
-  NS_ASSERTION(mIsFile, "Should only be called on files");
+  MOZ_ASSERT(mIsFile, "Should only be called on files");
   aName = mName;
 }
 
 nsresult
 FileImplBase::GetPath(nsAString& aPath)
 {
-  NS_ASSERTION(mIsFile, "Should only be called on files");
+  MOZ_ASSERT(mIsFile, "Should only be called on files");
   aPath = mPath;
   return NS_OK;
 }
 
 void
 FileImplBase::GetMozFullPath(nsAString& aFileName, ErrorResult& aRv)
 {
-  NS_ASSERTION(mIsFile, "Should only be called on files");
+  MOZ_ASSERT(mIsFile, "Should only be called on files");
 
   aFileName.Truncate();
 
   if (NS_IsMainThread()) {
     if (nsContentUtils::IsCallerChrome()) {
       GetMozFullPathInternal(aFileName, aRv);
     }
 
@@ -778,17 +778,17 @@
 FileImplBase::GetType(nsAString& aType)
 {
   aType = mContentType;
 }
 
 int64_t
 FileImplBase::GetLastModified(ErrorResult& aRv)
 {
-  NS_ASSERTION(mIsFile, "Should only be called on files");
+  MOZ_ASSERT(mIsFile, "Should only be called on files");
   if (IsDateUnknown()) {
     mLastModificationDate = PR_Now();
   }
 
   return mLastModificationDate / PR_USEC_PER_MSEC;
 }
 
 int64_t
@@ -796,18 +796,18 @@
 {
   int64_t id = -1;
 
   if (IsStoredFile() && IsWholeFile() && !IsSnapshot()) {
     if (!indexedDB::IndexedDatabaseManager::IsClosed()) {
       indexedDB::IndexedDatabaseManager::FileMutex().Lock();
     }
 
-    NS_ASSERTION(!mFileInfos.IsEmpty(),
-                 "A stored file must have at least one file info!");
+    MOZ_ASSERT(!mFileInfos.IsEmpty(),
+               "A stored file must have at least one file info!");
 
     nsRefPtr<indexedDB::FileInfo>& fileInfo = mFileInfos.ElementAt(0);
     if (fileInfo) {
       id =  fileInfo->Id();
     }
 
     if (!indexedDB::IndexedDatabaseManager::IsClosed()) {
       indexedDB::IndexedDatabaseManager::FileMutex().Unlock();
@@ -824,18 +824,18 @@
     NS_ERROR("Shouldn't be called after shutdown!");
     return;
   }
 
   nsRefPtr<indexedDB::FileInfo> fileInfo = aFileInfo;
 
   MutexAutoLock lock(indexedDB::IndexedDatabaseManager::FileMutex());
 
-  NS_ASSERTION(!mFileInfos.Contains(aFileInfo),
-               "Adding the same file info agan?!");
+  MOZ_ASSERT(!mFileInfos.Contains(aFileInfo),
+             "Adding the same file info agan?!");
 
   nsRefPtr<indexedDB::FileInfo>* element = mFileInfos.AppendElement();
   element->swap(fileInfo);
 }
 
 indexedDB::FileInfo*
 FileImplBase::GetFileInfo(indexedDB::FileManager* aFileManager)
 {
@@ -938,26 +938,26 @@
   nsRefPtr<FileImpl> impl =
     new FileImplFile(this, aStart, aLength, aContentType);
   return impl.forget();
 }
 
 void
 FileImplFile::GetMozFullPathInternal(nsAString& aFilename, ErrorResult& aRv)
 {
-  NS_ASSERTION(mIsFile, "Should only be called on files");
+  MOZ_ASSERT(mIsFile, "Should only be called on files");
   aRv = mFile->GetPath(aFilename);
 }
 
 uint64_t
 FileImplFile::GetSize(ErrorResult& aRv)
 {
   if (IsSizeUnknown()) {
-    NS_ASSERTION(mWholeFile,
-                 "Should only use lazy size when using the whole file");
+    MOZ_ASSERT(mWholeFile,
+               "Should only use lazy size when using the whole file");
     int64_t fileSize;
     aRv = mFile->GetFileSize(&fileSize);
     if (NS_WARN_IF(aRv.Failed())) {
       return 0;
     }
 
     if (fileSize < 0) {
       aRv.Throw(NS_ERROR_FAILURE);
@@ -969,18 +969,18 @@
 
   return mLength;
 }
 
 void
 FileImplFile::GetType(nsAString& aType)
 {
   if (mContentType.IsVoid()) {
-    NS_ASSERTION(mWholeFile,
-                 "Should only use lazy ContentType when using the whole file");
+    MOZ_ASSERT(mWholeFile,
+               "Should only use lazy ContentType when using the whole file");
     nsresult rv;
     nsCOMPtr<nsIMIMEService> mimeService =
       do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aType.Truncate();
       return;
     }
 
@@ -995,17 +995,17 @@
   }
 
   aType = mContentType;
 }
 
 int64_t
 FileImplFile::GetLastModified(ErrorResult& aRv)
 {
-  NS_ASSERTION(mIsFile, "Should only be called on files");
+  MOZ_ASSERT(mIsFile, "Should only be called on files");
   if (IsDateUnknown()) {
     PRTime msecs;
     aRv = mFile->GetLastModifiedTime(&msecs);
     if (NS_WARN_IF(aRv.Failed())) {
       return 0;
     }
 
     mLastModificationDate = msecs;
diff --git a/dom/base/File.h b/dom/base/File.h
--- a/dom/base/File.h
+++ b/dom/base/File.h
@@ -345,18 +345,17 @@
                uint64_t aLength)
     : mIsFile(false)
     , mImmutable(false)
     , mContentType(aContentType)
     , mStart(aStart)
     , mLength(aLength)
     , mLastModificationDate(UINT64_MAX)
   {
-    NS_ASSERTION(aLength != UINT64_MAX,
-                 "Must know length when creating slice");
+    MOZ_ASSERT(aLength != UINT64_MAX, "Must know length when creating slice");
     // Ensure non-null mContentType by default
     mContentType.SetIsVoid(false);
   }
 
   virtual void GetName(nsAString& aName) MOZ_OVERRIDE;
 
   virtual nsresult GetPath(nsAString& aName) MOZ_OVERRIDE;
 
@@ -407,17 +406,17 @@
   virtual nsresult GetMutable(bool* aMutable) const MOZ_OVERRIDE;
 
   virtual nsresult SetMutable(bool aMutable) MOZ_OVERRIDE;
 
   virtual void
   SetLazyData(const nsAString& aName, const nsAString& aContentType,
               uint64_t aLength, uint64_t aLastModifiedDate) MOZ_OVERRIDE
   {
-    NS_ASSERTION(aLength, "must have length");
+    MOZ_ASSERT(aLength, "must have length");
 
     mName = aName;
     mContentType = aContentType;
     mLength = aLength;
     mLastModificationDate = aLastModifiedDate;
     mIsFile = !aName.IsVoid();
   }
 
@@ -457,18 +456,18 @@
     return mLength == UINT64_MAX;
   }
 
 protected:
   virtual ~FileImplBase() {}
 
   indexedDB::FileInfo* GetFileInfo() const
   {
-    NS_ASSERTION(IsStoredFile(), "Should only be called on stored files!");
-    NS_ASSERTION(!mFileInfos.IsEmpty(), "Must have at least one file info!");
+    MOZ_ASSERT(IsStoredFile(), "Should only be called on stored files!");
+    MOZ_ASSERT(!mFileInfos.IsEmpty(), "Must have at least one file info!");
 
     return mFileInfos.ElementAt(0);
   }
 
   bool mIsFile;
   bool mImmutable;
 
   nsString mContentType;
@@ -493,25 +492,25 @@
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   FileImplMemory(void* aMemoryBuffer, uint64_t aLength, const nsAString& aName,
                  const nsAString& aContentType, uint64_t aLastModifiedDate)
     : FileImplBase(aName, aContentType, aLength, aLastModifiedDate)
     , mDataOwner(new DataOwner(aMemoryBuffer, aLength))
   {
-    NS_ASSERTION(mDataOwner && mDataOwner->mData, "must have data");
+    MOZ_ASSERT(mDataOwner && mDataOwner->mData, "must have data");
   }
 
   FileImplMemory(void* aMemoryBuffer, uint64_t aLength,
                  const nsAString& aContentType)
     : FileImplBase(aContentType, aLength)
     , mDataOwner(new DataOwner(aMemoryBuffer, aLength))
   {
-    NS_ASSERTION(mDataOwner && mDataOwner->mData, "must have data");
+    MOZ_ASSERT(mDataOwner && mDataOwner->mData, "must have data");
   }
 
   virtual nsresult GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
 
   virtual already_AddRefed<FileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
               const nsAString& aContentType, ErrorResult& aRv) MOZ_OVERRIDE;
 
@@ -566,17 +565,17 @@
 
 private:
   // Create slice
   FileImplMemory(const FileImplMemory* aOther, uint64_t aStart,
                  uint64_t aLength, const nsAString& aContentType)
     : FileImplBase(aContentType, aOther->mStart + aStart, aLength)
     , mDataOwner(aOther->mDataOwner)
   {
-    NS_ASSERTION(mDataOwner && mDataOwner->mData, "must have data");
+    MOZ_ASSERT(mDataOwner && mDataOwner->mData, "must have data");
     mImmutable = aOther->mImmutable;
   }
 
   ~FileImplMemory() {}
 
   // Used when backed by a memory store
   nsRefPtr<DataOwner> mDataOwner;
 };
@@ -628,102 +627,102 @@
   // Create as a file
   explicit FileImplFile(nsIFile* aFile, bool aTemporary = false)
     : FileImplBase(EmptyString(), EmptyString(), UINT64_MAX, UINT64_MAX)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(false)
     , mIsTemporary(aTemporary)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
     // Lazily get the content type and size
     mContentType.SetIsVoid(true);
     mFile->GetLeafName(mName);
   }
 
   FileImplFile(nsIFile* aFile, indexedDB::FileInfo* aFileInfo)
     : FileImplBase(EmptyString(), EmptyString(), UINT64_MAX, UINT64_MAX)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(true)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
-    NS_ASSERTION(aFileInfo, "must have file info");
+    MOZ_ASSERT(mFile, "must have file");
+    MOZ_ASSERT(aFileInfo, "must have file info");
     // Lazily get the content type and size
     mContentType.SetIsVoid(true);
     mFile->GetLeafName(mName);
 
     mFileInfos.AppendElement(aFileInfo);
   }
 
   // Create as a file
   FileImplFile(const nsAString& aName, const nsAString& aContentType,
                uint64_t aLength, nsIFile* aFile)
     : FileImplBase(aName, aContentType, aLength, UINT64_MAX)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(false)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
   }
 
   FileImplFile(const nsAString& aName, const nsAString& aContentType,
                uint64_t aLength, nsIFile* aFile,
                uint64_t aLastModificationDate)
     : FileImplBase(aName, aContentType, aLength, aLastModificationDate)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(false)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
   }
 
   // Create as a file with custom name
   FileImplFile(nsIFile* aFile, const nsAString& aName,
                const nsAString& aContentType)
     : FileImplBase(aName, aContentType, UINT64_MAX, UINT64_MAX)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(false)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
     if (aContentType.IsEmpty()) {
       // Lazily get the content type and size
       mContentType.SetIsVoid(true);
     }
   }
 
   // Create as a stored file
   FileImplFile(const nsAString& aName, const nsAString& aContentType,
                uint64_t aLength, nsIFile* aFile,
                indexedDB::FileInfo* aFileInfo)
     : FileImplBase(aName, aContentType, aLength, UINT64_MAX)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(true)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
     mFileInfos.AppendElement(aFileInfo);
   }
 
   // Create as a stored blob
   FileImplFile(const nsAString& aContentType, uint64_t aLength,
                nsIFile* aFile, indexedDB::FileInfo* aFileInfo)
     : FileImplBase(aContentType, aLength)
     , mFile(aFile)
     , mWholeFile(true)
     , mStoredFile(true)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
     mFileInfos.AppendElement(aFileInfo);
   }
 
   // Create as a file to be later initialized
   FileImplFile()
     : FileImplBase(EmptyString(), EmptyString(), UINT64_MAX, UINT64_MAX)
     , mWholeFile(true)
     , mStoredFile(false)
@@ -763,17 +762,17 @@
   FileImplFile(const FileImplFile* aOther, uint64_t aStart,
                uint64_t aLength, const nsAString& aContentType)
     : FileImplBase(aContentType, aOther->mStart + aStart, aLength)
     , mFile(aOther->mFile)
     , mWholeFile(false)
     , mStoredFile(aOther->mStoredFile)
     , mIsTemporary(false)
   {
-    NS_ASSERTION(mFile, "must have file");
+    MOZ_ASSERT(mFile, "must have file");
     mImmutable = aOther->mImmutable;
 
     if (mStoredFile) {
       indexedDB::FileInfo* fileInfo;
 
       using indexedDB::IndexedDatabaseManager;
 
       if (IndexedDatabaseManager::IsClosed()) {
@@ -852,18 +851,18 @@
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMFileList> list_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
       // question doesn't use the nsIDOMFileList pointer as the nsISupports
       // pointer. That must be fixed, or we'll crash...
-      NS_ASSERTION(list_qi == static_cast<nsIDOMFileList*>(aSupports),
-                   "Uh, fix QI!");
+      MOZ_ASSERT(list_qi == static_cast<nsIDOMFileList*>(aSupports),
+                 "Uh, fix QI!");
     }
 #endif
 
     return static_cast<FileList*>(aSupports);
   }
 
   File* Item(uint32_t aIndex)
   {
diff --git a/dom/base/FragmentOrElement.cpp b/dom/base/FragmentOrElement.cpp
--- a/dom/base/FragmentOrElement.cpp
+++ b/dom/base/FragmentOrElement.cpp
@@ -468,18 +468,18 @@
 
 
 NS_IMPL_ISUPPORTS(nsNodeWeakReference,
                   nsIWeakReference)
 
 nsNodeWeakReference::~nsNodeWeakReference()
 {
   if (mNode) {
-    NS_ASSERTION(mNode->Slots()->mWeakReference == this,
-                 "Weak reference has wrong value");
+    MOZ_ASSERT(mNode->Slots()->mWeakReference == this,
+               "Weak reference has wrong value");
     mNode->Slots()->mWeakReference = nullptr;
   }
 }
 
 NS_IMETHODIMP
 nsNodeWeakReference::QueryReferent(const nsIID& aIID, void** aInstancePtr)
 {
   return mNode ? mNode->QueryInterface(aIID, aInstancePtr) :
@@ -861,36 +861,36 @@
 
   // Event may need to be retargeted if this is the root of a native
   // anonymous content subtree or event is dispatched somewhere inside XBL.
   if (isAnonForEvents) {
 #ifdef DEBUG
     // If a DOM event is explicitly dispatched using node.dispatchEvent(), then
     // all the events are allowed even in the native anonymous content..
     nsCOMPtr<nsIContent> t = do_QueryInterface(aVisitor.mEvent->originalTarget);
-    NS_ASSERTION(!t || !t->ChromeOnlyAccess() ||
+    MOZ_ASSERT(!t || !t->ChromeOnlyAccess() ||
                  aVisitor.mEvent->mClass != eMutationEventClass ||
                  aVisitor.mDOMEvent,
-                 "Mutation event dispatched in native anonymous content!?!");
+               "Mutation event dispatched in native anonymous content!?!");
 #endif
     aVisitor.mEventTargetAtParent = parent;
   } else if (parent && aVisitor.mOriginalTargetIsInAnon) {
     nsCOMPtr<nsIContent> content(do_QueryInterface(aVisitor.mEvent->target));
     if (content && content->GetBindingParent() == parent) {
       aVisitor.mEventTargetAtParent = parent;
     }
   }
 
   // check for an anonymous parent
   // XXX XBL2/sXBL issue
   if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
     nsIContent* insertionParent = GetXBLInsertionParent();
-    NS_ASSERTION(!(aVisitor.mEventTargetAtParent && insertionParent &&
-                   aVisitor.mEventTargetAtParent != insertionParent),
-                 "Retargeting and having insertion parent!");
+    MOZ_ASSERT(!(aVisitor.mEventTargetAtParent && insertionParent &&
+                 aVisitor.mEventTargetAtParent != insertionParent),
+               "Retargeting and having insertion parent!");
     if (insertionParent) {
       parent = insertionParent;
     }
   }
 
   if (parent) {
     aVisitor.mParentTarget = parent;
   } else {
@@ -1140,17 +1140,17 @@
 
   return doInsertChildAt(aKid, aIndex, aNotify, mAttrsAndChildren);
 }
 
 void
 FragmentOrElement::RemoveChildAt(uint32_t aIndex, bool aNotify)
 {
   nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
-  NS_ASSERTION(oldKid == GetChildAt(aIndex), "Unexpected child in RemoveChildAt");
+  MOZ_ASSERT(oldKid == GetChildAt(aIndex), "Unexpected child in RemoveChildAt");
 
   if (oldKid) {
     doRemoveChildAt(aIndex, aNotify, oldKid, mAttrsAndChildren);
   }
 }
 
 void
 FragmentOrElement::GetTextContentInternal(nsAString& aTextContent,
@@ -2937,16 +2937,16 @@
       n = n->GetNextNode(this);
     }
   }
 }
 
 void
 FragmentOrElement::SetIsElementInStyleScopeFlagOnShadowTree(bool aInStyleScope)
 {
-  NS_ASSERTION(IsElement(), "calling SetIsElementInStyleScopeFlagOnShadowTree "
-                            "on a non-Element is useless");
+  MOZ_ASSERT(IsElement(), "calling SetIsElementInStyleScopeFlagOnShadowTree "
+                          "on a non-Element is useless");
   ShadowRoot* shadowRoot = GetShadowRoot();
   while (shadowRoot) {
     shadowRoot->SetIsElementInStyleScopeFlagOnSubtree(aInStyleScope);
     shadowRoot = shadowRoot->GetOlderShadowRoot();
   }
 }
diff --git a/dom/base/Link.cpp b/dom/base/Link.cpp
--- a/dom/base/Link.cpp
+++ b/dom/base/Link.cpp
@@ -42,20 +42,18 @@
 {
   return ((!mElement->IsSVG() && mElement->HasAttr(kNameSpaceID_None, nsGkAtoms::href))
         || (!mElement->IsHTML() && mElement->HasAttr(kNameSpaceID_XLink, nsGkAtoms::href)));
 }
 
 void
 Link::SetLinkState(nsLinkState aState)
 {
-  NS_ASSERTION(mRegistered,
-               "Setting the link state of an unregistered Link!");
-  NS_ASSERTION(mLinkState != aState,
-               "Setting state to the currently set state!");
+  MOZ_ASSERT(mRegistered, "Setting the link state of an unregistered Link!");
+  MOZ_ASSERT(mLinkState != aState, "Setting state to the currently set state!");
 
   // Set our current state as appropriate.
   mLinkState = aState;
 
   // Per IHistory interface documentation, we are no longer registered.
   mRegistered = false;
 
   NS_ABORT_IF_FALSE(LinkState() == NS_EVENT_STATE_VISITED ||
@@ -507,22 +505,22 @@
 void
 Link::UnregisterFromHistory()
 {
   // If we are not registered, we have nothing to do.
   if (!mRegistered) {
     return;
   }
 
-  NS_ASSERTION(mCachedURI, "mRegistered is true, but we have no cached URI?!");
+  MOZ_ASSERT(mCachedURI, "mRegistered is true, but we have no cached URI?!");
 
   // And tell History to stop tracking us.
   if (mHistory) {
     nsresult rv = mHistory->UnregisterVisitedCallback(mCachedURI, this);
-    NS_ASSERTION(NS_SUCCEEDED(rv), "This should only fail if we misuse the API!");
+    MOZ_ASSERT(NS_SUCCEEDED(rv), "This should only fail if we misuse the API!");
     if (NS_SUCCEEDED(rv)) {
       mRegistered = false;
     }
   }
 }
 
 already_AddRefed<nsIURI>
 Link::GetURIToMutate()
@@ -534,17 +532,17 @@
   nsCOMPtr<nsIURI> clone;
   (void)uri->Clone(getter_AddRefs(clone));
   return clone.forget();
 }
 
 void
 Link::SetHrefAttribute(nsIURI *aURI)
 {
-  NS_ASSERTION(aURI, "Null URI is illegal!");
+  MOZ_ASSERT(aURI, "Null URI is illegal!");
 
   // if we change this code to not reserialize we need to do something smarter
   // in SetProtocol because changing the protocol of an URI can change the
   // "nature" of the nsIURL/nsIURI implementation.
   nsAutoCString href;
   (void)aURI->GetSpec(href);
   (void)mElement->SetAttr(kNameSpaceID_None, nsGkAtoms::href,
                           NS_ConvertUTF8toUTF16(href), true);
diff --git a/dom/base/MessagePort.cpp b/dom/base/MessagePort.cpp
--- a/dom/base/MessagePort.cpp
+++ b/dom/base/MessagePort.cpp
@@ -100,20 +100,20 @@
 static JSObject*
 PostMessageReadStructuredClone(JSContext* cx,
                                JSStructuredCloneReader* reader,
                                uint32_t tag,
                                uint32_t data,
                                void* closure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   if (tag == SCTAG_DOM_BLOB) {
-    NS_ASSERTION(!data, "Data should be empty");
+    MOZ_ASSERT(!data, "Data should be empty");
 
     // What we get back from the reader is a FileImpl.
     // From that we create a new File.
     FileImpl* blobImpl;
     if (JS_ReadBytes(reader, &blobImpl, sizeof(blobImpl))) {
       MOZ_ASSERT(blobImpl);
 
       // nsRefPtr<File> needs to go out of scope before toObjectOrNull() is
@@ -130,17 +130,17 @@
         }
       }
 
       return &val.toObject();
     }
   }
 
   if (tag == SCTAG_DOM_FILELIST) {
-    NS_ASSERTION(!data, "Data should be empty");
+    MOZ_ASSERT(!data, "Data should be empty");
 
     nsISupports* supports;
     if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
       JS::Rooted<JS::Value> val(cx);
       if (NS_SUCCEEDED(nsContentUtils::WrapNative(cx, supports, &val))) {
         return val.toObjectOrNull();
       }
     }
@@ -158,17 +158,17 @@
 
 static bool
 PostMessageWriteStructuredClone(JSContext* cx,
                                 JSStructuredCloneWriter* writer,
                                 JS::Handle<JSObject*> obj,
                                 void *closure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   // See if this is a File/Blob object.
   {
     File* blob = nullptr;
     if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, obj, blob))) {
       FileImpl* blobImpl = blob->Impl();
       if (JS_WriteUint32Pair(writer, SCTAG_DOM_BLOB, 0) &&
           JS_WriteBytes(writer, &blobImpl, sizeof(blobImpl))) {
@@ -211,17 +211,17 @@
 PostMessageReadTransferStructuredClone(JSContext* aCx,
                                        JSStructuredCloneReader* reader,
                                        uint32_t tag, void* data,
                                        uint64_t unused,
                                        void* aClosure,
                                        JS::MutableHandle<JSObject*> returnObject)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(aClosure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   if (tag == SCTAG_DOM_MAP_MESSAGEPORT) {
     MessagePort* port = static_cast<MessagePort*>(data);
     port->BindToOwner(scInfo->mPort->GetOwner());
     scInfo->mPorts.Put(port, nullptr);
 
     JS::Rooted<JSObject*> obj(aCx, port->WrapObject(aCx));
     if (!obj || !JS_WrapObject(aCx, &obj)) {
@@ -241,17 +241,17 @@
                                    JS::Handle<JSObject*> aObj,
                                    void* aClosure,
                                    uint32_t* aTag,
                                    JS::TransferableOwnership* aOwnership,
                                    void** aContent,
                                    uint64_t *aExtraData)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(aClosure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   MessagePortBase *port = nullptr;
   nsresult rv = UNWRAP_OBJECT(MessagePort, aObj, port);
   if (NS_SUCCEEDED(rv)) {
     nsRefPtr<MessagePortBase> newPort;
     if (scInfo->mPorts.Get(port, getter_AddRefs(newPort))) {
       // No duplicate.
       return false;
@@ -273,17 +273,17 @@
 
 static void
 PostMessageFreeTransferStructuredClone(uint32_t aTag, JS::TransferableOwnership aOwnership,
                                        void* aData,
                                        uint64_t aExtraData,
                                        void* aClosure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(aClosure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   if (aTag == SCTAG_DOM_MAP_MESSAGEPORT) {
     MOZ_ASSERT(aOwnership == JS::SCTAG_TMO_CUSTOM);
     nsRefPtr<MessagePort> port(static_cast<MessagePort*>(aData));
     scInfo->mPorts.Remove(port);
   }
 }
 
diff --git a/dom/base/MultipartFileImpl.cpp b/dom/base/MultipartFileImpl.cpp
--- a/dom/base/MultipartFileImpl.cpp
+++ b/dom/base/MultipartFileImpl.cpp
@@ -265,17 +265,17 @@
   return NS_OK;
 }
 
 void
 MultipartFileImpl::InitializeChromeFile(File& aBlob,
                                         const ChromeFilePropertyBag& aBag,
                                         ErrorResult& aRv)
 {
-  NS_ASSERTION(!mImmutable, "Something went wrong ...");
+  MOZ_ASSERT(!mImmutable, "Something went wrong ...");
 
   if (mImmutable) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return;
   }
 
   MOZ_ASSERT(nsContentUtils::IsCallerChrome());
 
@@ -298,17 +298,17 @@
 
 void
 MultipartFileImpl::InitializeChromeFile(nsPIDOMWindow* aWindow,
                                         nsIFile* aFile,
                                         const ChromeFilePropertyBag& aBag,
                                         bool aIsFromNsIFile,
                                         ErrorResult& aRv)
 {
-  NS_ASSERTION(!mImmutable, "Something went wrong ...");
+  MOZ_ASSERT(!mImmutable, "Something went wrong ...");
   if (mImmutable) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return;
   }
 
   MOZ_ASSERT(nsContentUtils::IsCallerChrome());
 
   mName = aBag.mName;
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -1954,18 +1954,18 @@
   // TODO: add SizeOfIncludingThis() to DesktopNotificationCenter, bug 674116.
 
   return n;
 }
 
 void
 Navigator::SetWindow(nsPIDOMWindow *aInnerWindow)
 {
-  NS_ASSERTION(aInnerWindow->IsInnerWindow(),
-               "Navigator must get an inner window!");
+  MOZ_ASSERT(aInnerWindow->IsInnerWindow(),
+             "Navigator must get an inner window!");
   mWindow = aInnerWindow;
 }
 
 void
 Navigator::OnNavigation()
 {
   if (!mWindow) {
     return;
@@ -2115,18 +2115,18 @@
     if (!JS_WrapObject(aCx, &domObject)) {
       return false;
     }
 
     FillPropertyDescriptor(aDesc, aObject, JS::ObjectValue(*domObject), false);
     return true;
   }
 
-  NS_ASSERTION(name_struct->mType == nsGlobalNameStruct::eTypeNavigatorProperty,
-               "unexpected type");
+  MOZ_ASSERT(name_struct->mType == nsGlobalNameStruct::eTypeNavigatorProperty,
+             "unexpected type");
 
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsISupports> native;
   bool hadCachedNative = mCachedResolveResults.Get(name, getter_AddRefs(native));
   bool okToUseNative;
   JS::Rooted<JS::Value> prop_val(aCx);
   if (hadCachedNative) {
diff --git a/dom/base/ShadowRoot.cpp b/dom/base/ShadowRoot.cpp
--- a/dom/base/ShadowRoot.cpp
+++ b/dom/base/ShadowRoot.cpp
@@ -196,17 +196,17 @@
 
   if (!aNamespaceURI.EqualsLiteral("*")) {
     nsresult rv =
       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
                                                             nameSpaceId);
     NS_ENSURE_SUCCESS(rv, nullptr);
   }
 
-  NS_ASSERTION(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
+  MOZ_ASSERT(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
 
   return NS_GetContentList(this, nameSpaceId, aLocalName);
 }
 
 void
 ShadowRoot::AddToIdTable(Element* aElement, nsIAtom* aId)
 {
   nsIdentifierMapEntry *entry =
diff --git a/dom/base/ThirdPartyUtil.cpp b/dom/base/ThirdPartyUtil.cpp
--- a/dom/base/ThirdPartyUtil.cpp
+++ b/dom/base/ThirdPartyUtil.cpp
@@ -88,17 +88,17 @@
 // for mozIThirdPartyUtil.
 NS_IMETHODIMP
 ThirdPartyUtil::IsThirdPartyURI(nsIURI* aFirstURI,
                                 nsIURI* aSecondURI,
                                 bool* aResult)
 {
   NS_ENSURE_ARG(aFirstURI);
   NS_ENSURE_ARG(aSecondURI);
-  NS_ASSERTION(aResult, "null outparam pointer");
+  MOZ_ASSERT(aResult, "null outparam pointer");
 
   nsCString firstHost;
   nsresult rv = GetBaseDomain(aFirstURI, firstHost);
   if (NS_FAILED(rv))
     return rv;
 
   return IsThirdPartyInternal(firstHost, aSecondURI, aResult);
 }
@@ -106,17 +106,17 @@
 // Determine if any URI of the window hierarchy of aWindow is foreign with
 // respect to aSecondURI. See docs for mozIThirdPartyUtil.
 NS_IMETHODIMP
 ThirdPartyUtil::IsThirdPartyWindow(nsIDOMWindow* aWindow,
                                    nsIURI* aURI,
                                    bool* aResult)
 {
   NS_ENSURE_ARG(aWindow);
-  NS_ASSERTION(aResult, "null outparam pointer");
+  MOZ_ASSERT(aResult, "null outparam pointer");
 
   bool result;
 
   // Get the URI of the window, and its base domain.
   nsresult rv;
   nsCOMPtr<nsIURI> currentURI;
   rv = GetURIFromWindow(aWindow, getter_AddRefs(currentURI));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -176,17 +176,17 @@
 // hierarchy associated with the channel is foreign with respect to aSecondURI.
 // See docs for mozIThirdPartyUtil.
 NS_IMETHODIMP 
 ThirdPartyUtil::IsThirdPartyChannel(nsIChannel* aChannel,
                                     nsIURI* aURI,
                                     bool* aResult)
 {
   NS_ENSURE_ARG(aChannel);
-  NS_ASSERTION(aResult, "null outparam pointer");
+  MOZ_ASSERT(aResult, "null outparam pointer");
 
   nsresult rv;
   bool doForce = false;
   bool checkWindowChain = true;
   bool parentIsThird = false;
   nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal =
     do_QueryInterface(aChannel);
   if (httpChannelInternal) {
diff --git a/dom/base/nsAttrAndChildArray.cpp b/dom/base/nsAttrAndChildArray.cpp
--- a/dom/base/nsAttrAndChildArray.cpp
+++ b/dom/base/nsAttrAndChildArray.cpp
@@ -125,18 +125,18 @@
   }
   
   return reinterpret_cast<nsIContent**>(mImpl->mBuffer + AttrSlotsSize());
 }
 
 nsresult
 nsAttrAndChildArray::InsertChildAt(nsIContent* aChild, uint32_t aPos)
 {
-  NS_ASSERTION(aChild, "nullchild");
-  NS_ASSERTION(aPos <= ChildCount(), "out-of-bounds");
+  MOZ_ASSERT(aChild, "nullchild");
+  MOZ_ASSERT(aPos <= ChildCount(), "out-of-bounds");
 
   uint32_t offset = AttrSlotsSize();
   uint32_t childCount = ChildCount();
 
   NS_ENSURE_TRUE(childCount < ATTRCHILD_ARRAY_MAX_CHILD_COUNT,
                  NS_ERROR_FAILURE);
 
   // First try to fit new child in existing childlist
@@ -191,17 +191,17 @@
   // Just store the return value of TakeChildAt in an nsCOMPtr to
   // trigger a release.
   nsCOMPtr<nsIContent> child = TakeChildAt(aPos);
 }
 
 already_AddRefed<nsIContent>
 nsAttrAndChildArray::TakeChildAt(uint32_t aPos)
 {
-  NS_ASSERTION(aPos < ChildCount(), "out-of-bounds");
+  MOZ_ASSERT(aPos < ChildCount(), "out-of-bounds");
 
   uint32_t childCount = ChildCount();
   void** pos = mImpl->mBuffer + AttrSlotsSize() + aPos;
   nsIContent* child = static_cast<nsIContent*>(*pos);
   if (child->mPreviousSibling) {
     child->mPreviousSibling->mNextSibling = child->mNextSibling;
   }
   if (child->mNextSibling) {
@@ -369,18 +369,17 @@
   }
 
   return nullptr;
 }
 
 const nsAttrValue*
 nsAttrAndChildArray::AttrAt(uint32_t aPos) const
 {
-  NS_ASSERTION(aPos < AttrCount(),
-               "out-of-bounds access in nsAttrAndChildArray");
+  MOZ_ASSERT(aPos < AttrCount(), "out-of-bounds access in nsAttrAndChildArray");
 
   uint32_t mapped = MappedAttrCount();
   if (aPos < mapped) {
     return mImpl->mMappedAttrs->AttrAt(aPos);
   }
 
   return &ATTRS(mImpl)[aPos - mapped].mValue;
 }
@@ -445,17 +444,17 @@
 
   return NS_OK;
 }
 
 
 nsresult
 nsAttrAndChildArray::RemoveAttrAt(uint32_t aPos, nsAttrValue& aValue)
 {
-  NS_ASSERTION(aPos < AttrCount(), "out-of-bounds");
+  MOZ_ASSERT(aPos < AttrCount(), "out-of-bounds");
 
   uint32_t mapped = MappedAttrCount();
   if (aPos < mapped) {
     if (mapped == 1) {
       // We're removing the last mapped attribute.  Can't swap in this
       // case; have to copy.
       aValue.SetTo(*mImpl->mMappedAttrs->AttrAt(0));
       NS_RELEASE(mImpl->mMappedAttrs);
@@ -482,18 +481,17 @@
   memset(&ATTRS(mImpl)[slotCount - 1], 0, sizeof(InternalAttr));
 
   return NS_OK;
 }
 
 const nsAttrName*
 nsAttrAndChildArray::AttrNameAt(uint32_t aPos) const
 {
-  NS_ASSERTION(aPos < AttrCount(),
-               "out-of-bounds access in nsAttrAndChildArray");
+  MOZ_ASSERT(aPos < AttrCount(), "out-of-bounds access in nsAttrAndChildArray");
 
   uint32_t mapped = MappedAttrCount();
   if (aPos < mapped) {
     return mImpl->mMappedAttrs->NameAt(aPos);
   }
 
   return &ATTRS(mImpl)[aPos - mapped].mName;
 }
@@ -635,17 +633,17 @@
   // Then resize or free buffer
   uint32_t newSize = attrCount * ATTRSIZE + childCount;
   if (!newSize && !mImpl->mMappedAttrs) {
     moz_free(mImpl);
     mImpl = nullptr;
   }
   else if (newSize < mImpl->mBufferSize) {
     mImpl = static_cast<Impl*>(moz_realloc(mImpl, (newSize + NS_IMPL_EXTRA_SIZE) * sizeof(nsIContent*)));
-    NS_ASSERTION(mImpl, "failed to reallocate to smaller buffer");
+    MOZ_ASSERT(mImpl, "failed to reallocate to smaller buffer");
 
     mImpl->mBufferSize = newSize;
   }
 }
 
 void
 nsAttrAndChildArray::Clear()
 {
@@ -722,17 +720,17 @@
   nsMapRuleToAttributesFunc mapRuleFunc =
     aContent->GetAttributeMappingFunction();
   return new nsMappedAttributes(aSheet, mapRuleFunc);
 }
 
 nsresult
 nsAttrAndChildArray::MakeMappedUnique(nsMappedAttributes* aAttributes)
 {
-  NS_ASSERTION(aAttributes, "missing attributes");
+  MOZ_ASSERT(aAttributes, "missing attributes");
 
   if (!mImpl && !GrowBy(1)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   if (!aAttributes->GetStyleSheet()) {
     // This doesn't currently happen, but it could if we do loading right
 
diff --git a/dom/base/nsAttrAndChildArray.h b/dom/base/nsAttrAndChildArray.h
--- a/dom/base/nsAttrAndChildArray.h
+++ b/dom/base/nsAttrAndChildArray.h
@@ -50,17 +50,18 @@
   ~nsAttrAndChildArray();
 
   uint32_t ChildCount() const
   {
     return mImpl ? (mImpl->mAttrAndChildCount >> ATTRCHILD_ARRAY_ATTR_SLOTS_BITS) : 0;
   }
   nsIContent* ChildAt(uint32_t aPos) const
   {
-    NS_ASSERTION(aPos < ChildCount(), "out-of-bounds access in nsAttrAndChildArray");
+    MOZ_ASSERT(aPos < ChildCount(),
+               "out-of-bounds access in nsAttrAndChildArray");
     return reinterpret_cast<nsIContent*>(mImpl->mBuffer[AttrSlotsSize() + aPos]);
   }
   nsIContent* GetSafeChildAt(uint32_t aPos) const;
   nsIContent * const * GetChildArray(uint32_t* aChildCount) const;
   nsresult AppendChild(nsIContent* aChild)
   {
     return InsertChildAt(aChild, ChildCount());
   }
diff --git a/dom/base/nsAttrName.h b/dom/base/nsAttrName.h
--- a/dom/base/nsAttrName.h
+++ b/dom/base/nsAttrName.h
@@ -24,23 +24,23 @@
     : mBits(aOther.mBits)
   {
     AddRefInternalName();
   }
 
   explicit nsAttrName(nsIAtom* aAtom)
     : mBits(reinterpret_cast<uintptr_t>(aAtom))
   {
-    NS_ASSERTION(aAtom, "null atom-name in nsAttrName");
+    MOZ_ASSERT(aAtom, "null atom-name in nsAttrName");
     NS_ADDREF(aAtom);
   }
 
   explicit nsAttrName(mozilla::dom::NodeInfo* aNodeInfo)
   {
-    NS_ASSERTION(aNodeInfo, "null nodeinfo-name in nsAttrName");
+    MOZ_ASSERT(aNodeInfo, "null nodeinfo-name in nsAttrName");
     if (aNodeInfo->NamespaceEquals(kNameSpaceID_None)) {
       mBits = reinterpret_cast<uintptr_t>(aNodeInfo->NameAtom());
       NS_ADDREF(aNodeInfo->NameAtom());
     }
     else {
       mBits = reinterpret_cast<uintptr_t>(aNodeInfo) |
               NS_ATTRNAME_NODEINFO_BIT;
       NS_ADDREF(aNodeInfo);
@@ -49,53 +49,53 @@
 
   ~nsAttrName()
   {
     ReleaseInternalName();
   }
 
   void SetTo(mozilla::dom::NodeInfo* aNodeInfo)
   {
-    NS_ASSERTION(aNodeInfo, "null nodeinfo-name in nsAttrName");
+    MOZ_ASSERT(aNodeInfo, "null nodeinfo-name in nsAttrName");
 
     ReleaseInternalName();
     if (aNodeInfo->NamespaceEquals(kNameSpaceID_None)) {
       mBits = reinterpret_cast<uintptr_t>(aNodeInfo->NameAtom());
       NS_ADDREF(aNodeInfo->NameAtom());
     }
     else {
       mBits = reinterpret_cast<uintptr_t>(aNodeInfo) |
               NS_ATTRNAME_NODEINFO_BIT;
       NS_ADDREF(aNodeInfo);
     }
   }
 
   void SetTo(nsIAtom* aAtom)
   {
-    NS_ASSERTION(aAtom, "null atom-name in nsAttrName");
+    MOZ_ASSERT(aAtom, "null atom-name in nsAttrName");
 
     ReleaseInternalName();
     mBits = reinterpret_cast<uintptr_t>(aAtom);
     NS_ADDREF(aAtom);
   }
 
   bool IsAtom() const
   {
     return !(mBits & NS_ATTRNAME_NODEINFO_BIT);
   }
 
   mozilla::dom::NodeInfo* NodeInfo() const
   {
-    NS_ASSERTION(!IsAtom(), "getting nodeinfo-value of atom-name");
+    MOZ_ASSERT(!IsAtom(), "getting nodeinfo-value of atom-name");
     return reinterpret_cast<mozilla::dom::NodeInfo*>(mBits & ~NS_ATTRNAME_NODEINFO_BIT);
   }
 
   nsIAtom* Atom() const
   {
-    NS_ASSERTION(IsAtom(), "getting atom-value of nodeinfo-name");
+    MOZ_ASSERT(IsAtom(), "getting atom-value of nodeinfo-name");
     return reinterpret_cast<nsIAtom*>(mBits);
   }
 
   bool Equals(const nsAttrName& aOther) const
   {
     return mBits == aOther.mBits;
   }
 
diff --git a/dom/base/nsAttrValue.cpp b/dom/base/nsAttrValue.cpp
--- a/dom/base/nsAttrValue.cpp
+++ b/dom/base/nsAttrValue.cpp
@@ -159,17 +159,17 @@
 {
   ResetIfSet();
 }
 
 /* static */
 nsresult
 nsAttrValue::Init()
 {
-  NS_ASSERTION(!sEnumTableArray, "nsAttrValue already initialized");
+  MOZ_ASSERT(!sEnumTableArray, "nsAttrValue already initialized");
 
   sEnumTableArray = new nsTArray<const EnumTable*>;
   NS_ENSURE_TRUE(sEnumTableArray, NS_ERROR_OUT_OF_MEMORY);
   
   return NS_OK;
 }
 
 /* static */
@@ -762,17 +762,17 @@
   return nsCheapString(static_cast<nsStringBuffer*>(GetPtr()));
 }
 
 bool
 nsAttrValue::GetColorValue(nscolor& aColor) const
 {
   if (Type() != eColor) {
     // Unparseable value, treat as unset.
-    NS_ASSERTION(Type() == eString, "unexpected type for color-valued attr");
+    MOZ_ASSERT(Type() == eString, "unexpected type for color-valued attr");
     return false;
   }
 
   aColor = GetMiscContainer()->mValue.mColor;
   return true;
 }
 
 void
@@ -822,18 +822,18 @@
 {
   NS_PRECONDITION(aIndex >= 0, "Index must not be negative");
   NS_PRECONDITION(GetAtomCount() > uint32_t(aIndex), "aIndex out of range");
   
   if (BaseType() == eAtomBase) {
     return GetAtomValue();
   }
 
-  NS_ASSERTION(Type() == eAtomArray, "GetAtomCount must be confused");
-  
+  MOZ_ASSERT(Type() == eAtomArray, "GetAtomCount must be confused");
+
   return GetAtomArrayValue()->ElementAt(aIndex);
 }
 
 uint32_t
 nsAttrValue::HashValue() const
 {
   switch(BaseType()) {
     case eStringBase:
@@ -1361,29 +1361,29 @@
       {
         NS_NOTREACHED("unknown integer type");
         break;
       }
     }
     cont->mType = aType;
     SetMiscAtomOrString(aStringValue);
   } else {
-    NS_ASSERTION(!mBits, "Reset before calling SetIntValueAndType!");
+    MOZ_ASSERT(!mBits, "Reset before calling SetIntValueAndType!");
     mBits = (aValue * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER) | aType;
   }
 }
 
 int16_t
 nsAttrValue::GetEnumTableIndex(const EnumTable* aTable)
 {
   int16_t index = sEnumTableArray->IndexOf(aTable);
   if (index < 0) {
     index = sEnumTableArray->Length();
-    NS_ASSERTION(index <= NS_ATTRVALUE_ENUMTABLEINDEX_MAXVALUE,
-        "too many enum tables");
+    MOZ_ASSERT(index <= NS_ATTRVALUE_ENUMTABLEINDEX_MAXVALUE,
+               "too many enum tables");
     sEnumTableArray->AppendElement(aTable);
   }
 
   return index;
 }
 
 int32_t
 nsAttrValue::EnumTableEntryToValue(const EnumTable* aEnumTable,
@@ -1414,18 +1414,18 @@
         nsAutoString tag;
         tag.AssignASCII(tableEntry->tag);
         nsContentUtils::ASCIIToUpper(tag);
         if ((equals = tag.Equals(aValue))) {
           value |= NS_ATTRVALUE_ENUMTABLE_VALUE_NEEDS_TO_UPPER;
         }
       }
       SetIntValueAndType(value, eEnum, equals ? nullptr : &aValue);
-      NS_ASSERTION(GetEnumValue() == tableEntry->value,
-                   "failed to store enum properly");
+      MOZ_ASSERT(GetEnumValue() == tableEntry->value,
+                 "failed to store enum properly");
 
       return true;
     }
     tableEntry++;
   }
 
   if (aDefaultValue) {
     NS_PRECONDITION(aTable <= aDefaultValue && aDefaultValue < tableEntry,
@@ -1627,24 +1627,24 @@
   cont->mType = eIntMarginValue;
   SetMiscAtomOrString(&aString);
   return true;
 }
 
 void
 nsAttrValue::LoadImage(nsIDocument* aDocument)
 {
-  NS_ASSERTION(Type() == eURL, "wrong type");
+  MOZ_ASSERT(Type() == eURL, "wrong type");
 
 #ifdef DEBUG
   {
     nsString val;
     ToString(val);
-    NS_ASSERTION(!val.IsEmpty(),
-                 "How did we end up with an empty string for eURL");
+    MOZ_ASSERT(!val.IsEmpty(),
+               "How did we end up with an empty string for eURL");
   }
 #endif
 
   MiscContainer* cont = GetMiscContainer();
   mozilla::css::URLValue* url = cont->mValue.mURL;
   mozilla::css::ImageValue* image = 
     new css::ImageValue(url->GetURI(), url->mString, url->mReferrer,
                         url->mOriginPrincipal, aDocument);
@@ -1659,18 +1659,18 @@
 nsAttrValue::ParseStyleAttribute(const nsAString& aString,
                                  nsStyledElementNotElementCSSInlineStyle* aElement)
 {
   nsIDocument* ownerDoc = aElement->OwnerDoc();
   nsHTMLCSSStyleSheet* sheet = ownerDoc->GetInlineStyleSheet();
   nsCOMPtr<nsIURI> baseURI = aElement->GetBaseURI();
   nsIURI* docURI = ownerDoc->GetDocumentURI();
 
-  NS_ASSERTION(aElement->NodePrincipal() == ownerDoc->NodePrincipal(),
-               "This is unexpected");
+  MOZ_ASSERT(aElement->NodePrincipal() == ownerDoc->NodePrincipal(),
+             "This is unexpected");
 
   // If the (immutable) document URI does not match the element's base URI
   // (the common case is that they do match) do not cache the rule.  This is
   // because the results of the CSS parser are dependent on these URIs, and we
   // do not want to have to account for the URIs in the hash lookup.
   bool cachingAllowed = sheet && baseURI == docURI;
   if (cachingAllowed) {
     MiscContainer* cont = sheet->LookupStyleAttr(aString);
@@ -1701,29 +1701,29 @@
   }
 
   return false;
 }
 
 void
 nsAttrValue::SetMiscAtomOrString(const nsAString* aValue)
 {
-  NS_ASSERTION(GetMiscContainer(), "Must have MiscContainer!");
-  NS_ASSERTION(!GetMiscContainer()->mStringBits,
-               "Trying to re-set atom or string!");
+  MOZ_ASSERT(GetMiscContainer(), "Must have MiscContainer!");
+  MOZ_ASSERT(!GetMiscContainer()->mStringBits,
+             "Trying to re-set atom or string!");
   if (aValue) {
     uint32_t len = aValue->Length();
     // * We're allowing eCSSStyleRule attributes to store empty strings as it
     //   can be beneficial to store an empty style attribute as a parsed rule.
     // * We're allowing enumerated values because sometimes the empty
     //   string corresponds to a particular enumerated value, especially
     //   for enumerated values that are not limited enumerated.
     // Add other types as needed.
-    NS_ASSERTION(len || Type() == eCSSStyleRule || Type() == eEnum,
-                 "Empty string?");
+    MOZ_ASSERT(len || Type() == eCSSStyleRule || Type() == eEnum,
+               "Empty string?");
     MiscContainer* cont = GetMiscContainer();
     if (len <= NS_ATTRVALUE_MAX_STRINGLENGTH_ATOM) {
       nsCOMPtr<nsIAtom> atom = NS_NewAtom(*aValue);
       if (atom) {
         cont->mStringBits =
           reinterpret_cast<uintptr_t>(atom.forget().take()) | eAtomBase;
       }
     } else {
diff --git a/dom/base/nsAttrValue.h b/dom/base/nsAttrValue.h
--- a/dom/base/nsAttrValue.h
+++ b/dom/base/nsAttrValue.h
@@ -453,18 +453,17 @@
 nsAttrValue::BaseType() const
 {
   return static_cast<ValueBaseType>(mBits & NS_ATTRVALUE_BASETYPE_MASK);
 }
 
 inline void*
 nsAttrValue::GetPtr() const
 {
-  NS_ASSERTION(BaseType() != eIntegerBase,
-               "getting pointer from non-pointer");
+  MOZ_ASSERT(BaseType() != eIntegerBase, "getting pointer from non-pointer");
   return reinterpret_cast<void*>(mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
 }
 
 inline bool
 nsAttrValue::IsEmptyString() const
 {
   return !mBits;
 }
diff --git a/dom/base/nsAttrValueInlines.h b/dom/base/nsAttrValueInlines.h
--- a/dom/base/nsAttrValueInlines.h
+++ b/dom/base/nsAttrValueInlines.h
@@ -189,41 +189,40 @@
 nsAttrValue::IsSVGType(ValueType aType) const
 {
   return aType >= eSVGTypesBegin && aType <= eSVGTypesEnd;
 }
 
 inline void
 nsAttrValue::SetPtrValueAndType(void* aValue, ValueBaseType aType)
 {
-  NS_ASSERTION(!(NS_PTR_TO_INT32(aValue) & ~NS_ATTRVALUE_POINTERVALUE_MASK),
-               "pointer not properly aligned, this will crash");
+  MOZ_ASSERT(!(NS_PTR_TO_INT32(aValue) & ~NS_ATTRVALUE_POINTERVALUE_MASK),
+             "pointer not properly aligned, this will crash");
   mBits = reinterpret_cast<intptr_t>(aValue) | aType;
 }
 
 inline void
 nsAttrValue::ResetIfSet()
 {
   if (mBits) {
     Reset();
   }
 }
 
 inline MiscContainer*
 nsAttrValue::GetMiscContainer() const
 {
-  NS_ASSERTION(BaseType() == eOtherBase, "wrong type");
+  MOZ_ASSERT(BaseType() == eOtherBase, "wrong type");
   return static_cast<MiscContainer*>(GetPtr());
 }
 
 inline int32_t
 nsAttrValue::GetIntInternal() const
 {
-  NS_ASSERTION(BaseType() == eIntegerBase,
-               "getting integer from non-integer");
+  MOZ_ASSERT(BaseType() == eIntegerBase, "getting integer from non-integer");
   // Make sure we get a signed value.
   // Lets hope the optimizer optimizes this into a shift. Unfortunatly signed
   // bitshift right is implementaion dependant.
   return static_cast<int32_t>(mBits & ~NS_ATTRVALUE_INTEGERTYPE_MASK) /
          NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER;
 }
 
 #endif
diff --git a/dom/base/nsCCUncollectableMarker.cpp b/dom/base/nsCCUncollectableMarker.cpp
--- a/dom/base/nsCCUncollectableMarker.cpp
+++ b/dom/base/nsCCUncollectableMarker.cpp
@@ -318,18 +318,19 @@
     obs->RemoveObserver(this, "cycle-collector-begin");
     obs->RemoveObserver(this, "cycle-collector-forget-skippable");
 
     sGeneration = 0;
 
     return NS_OK;
   }
 
-  NS_ASSERTION(!strcmp(aTopic, "cycle-collector-begin") ||
-               !strcmp(aTopic, "cycle-collector-forget-skippable"), "wrong topic");
+  MOZ_ASSERT(!strcmp(aTopic, "cycle-collector-begin") ||
+               !strcmp(aTopic, "cycle-collector-forget-skippable"),
+             "wrong topic");
 
   // JS cleanup can be slow. Do it only if there has been a GC.
   bool cleanupJS =
     nsJSContext::CleanupsSinceLastGC() == 0 &&
     !strcmp(aTopic, "cycle-collector-forget-skippable");
 
   bool prepareForCC = !strcmp(aTopic, "cycle-collector-begin");
   if (prepareForCC) {
diff --git a/dom/base/nsContentAreaDragDrop.cpp b/dom/base/nsContentAreaDragDrop.cpp
--- a/dom/base/nsContentAreaDragDrop.cpp
+++ b/dom/base/nsContentAreaDragDrop.cpp
@@ -357,18 +357,19 @@
 nsresult
 DragDataProducer::Produce(DataTransfer* aDataTransfer,
                           bool* aCanDrag,
                           nsISelection** aSelection,
                           nsIContent** aDragNode)
 {
   NS_PRECONDITION(aCanDrag && aSelection && aDataTransfer && aDragNode,
                   "null pointer passed to Produce");
-  NS_ASSERTION(mWindow, "window not set");
-  NS_ASSERTION(mSelectionTargetNode, "selection target node should have been set");
+  MOZ_ASSERT(mWindow, "window not set");
+  MOZ_ASSERT(mSelectionTargetNode,
+             "selection target node should have been set");
 
   *aDragNode = nullptr;
 
   nsresult rv;
   nsIContent* dragNode = nullptr;
   *aSelection = nullptr;
 
   // Find the selection to see what we could be dragging and if what we're
@@ -718,17 +719,17 @@
     aDataTransfer->SetDataWithPrincipal(aFlavor, variant, 0, aPrincipal);
   }
 }
 
 nsresult
 DragDataProducer::AddStringsToDataTransfer(nsIContent* aDragNode,
                                            DataTransfer* aDataTransfer)
 {
-  NS_ASSERTION(aDragNode, "adding strings for null node");
+  MOZ_ASSERT(aDragNode, "adding strings for null node");
 
   // set all of the data to have the principal of the node where the data came from
   nsIPrincipal* principal = aDragNode->NodePrincipal();
 
   // add a special flavor if we're an anchor to indicate that we have
   // a URL in the drag data
   if (!mUrlString.IsEmpty() && mIsAnchor) {
     nsAutoString dragData(mUrlString);
diff --git a/dom/base/nsContentIterator.cpp b/dom/base/nsContentIterator.cpp
--- a/dom/base/nsContentIterator.cpp
+++ b/dom/base/nsContentIterator.cpp
@@ -589,18 +589,18 @@
 
   nsINode* parent = aNode->GetParentNode();
   if (!parent) {
     return nullptr;
   }
 
   int32_t indx = 0;
 
-  NS_ASSERTION(!aIndexes || !aIndexes->IsEmpty(),
-               "ContentIterator stack underflow");
+  MOZ_ASSERT(!aIndexes || !aIndexes->IsEmpty(),
+             "ContentIterator stack underflow");
   if (aIndexes && !aIndexes->IsEmpty()) {
     // use the last entry on the Indexes array for the current index
     indx = (*aIndexes)[aIndexes->Length()-1];
   } else {
     indx = mCachedIndex;
   }
 
   // reverify that the index of the current node hasn't changed.
@@ -650,18 +650,18 @@
 
   nsINode* parent = aNode->GetParentNode();
   if (!parent) {
     return nullptr;
   }
 
   int32_t indx = 0;
 
-  NS_ASSERTION(!aIndexes || !aIndexes->IsEmpty(),
-               "ContentIterator stack underflow");
+  MOZ_ASSERT(!aIndexes || !aIndexes->IsEmpty(),
+             "ContentIterator stack underflow");
   if (aIndexes && !aIndexes->IsEmpty()) {
     // use the last entry on the Indexes array for the current index
     indx = (*aIndexes)[aIndexes->Length()-1];
   } else {
     indx = mCachedIndex;
   }
 
   // reverify that the index of the current node hasn't changed
@@ -718,18 +718,18 @@
   }
 
   // post-order
   nsINode* parent = node->GetParentNode();
   nsIContent* sibling = nullptr;
   int32_t indx = 0;
 
   // get the cached index
-  NS_ASSERTION(!aIndexes || !aIndexes->IsEmpty(),
-               "ContentIterator stack underflow");
+  MOZ_ASSERT(!aIndexes || !aIndexes->IsEmpty(),
+             "ContentIterator stack underflow");
   if (aIndexes && !aIndexes->IsEmpty()) {
     // use the last entry on the Indexes array for the current index
     indx = (*aIndexes)[aIndexes->Length()-1];
   } else {
     indx = mCachedIndex;
   }
 
   // reverify that the index of the current node hasn't changed.  not super
@@ -781,18 +781,18 @@
 
   // if we are a Pre-order iterator, use pre-order
   if (mPre) {
     nsINode* parent = node->GetParentNode();
     nsIContent* sibling = nullptr;
     int32_t indx = 0;
 
     // get the cached index
-    NS_ASSERTION(!aIndexes || !aIndexes->IsEmpty(),
-                 "ContentIterator stack underflow");
+    MOZ_ASSERT(!aIndexes || !aIndexes->IsEmpty(),
+               "ContentIterator stack underflow");
     if (aIndexes && !aIndexes->IsEmpty()) {
       // use the last entry on the Indexes array for the current index
       indx = (*aIndexes)[aIndexes->Length()-1];
     } else {
       indx = mCachedIndex;
     }
 
     // reverify that the index of the current node hasn't changed.  not super
@@ -863,35 +863,35 @@
 nsContentIterator::First()
 {
   if (mFirst) {
 #ifdef DEBUG
     nsresult rv =
 #endif
     PositionAt(mFirst);
 
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to position iterator!");
+    MOZ_ASSERT(NS_SUCCEEDED(rv), "Failed to position iterator!");
   }
 
   mIsDone = mFirst == nullptr;
 }
 
 
 void
 nsContentIterator::Last()
 {
-  NS_ASSERTION(mLast, "No last node!");
+  MOZ_ASSERT(mLast, "No last node!");
 
   if (mLast) {
 #ifdef DEBUG
     nsresult rv =
 #endif
     PositionAt(mLast);
 
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to position iterator!");
+    MOZ_ASSERT(NS_SUCCEEDED(rv), "Failed to position iterator!");
   }
 
   mIsDone = mLast == nullptr;
 }
 
 
 void
 nsContentIterator::Next()
@@ -1073,17 +1073,17 @@
 
 nsINode*
 nsContentIterator::GetCurrentNode()
 {
   if (mIsDone) {
     return nullptr;
   }
 
-  NS_ASSERTION(mCurNode, "Null current node in an iterator that's not done!");
+  MOZ_ASSERT(mCurNode, "Null current node in an iterator that's not done!");
 
   return mCurNode;
 }
 
 
 
 
 
@@ -1284,18 +1284,18 @@
   if (offset > numChildren) {
     // Can happen for text nodes
     offset = numChildren;
   }
   if (!offset || !numChildren) {
     node = endParent;
   } else {
     lastCandidate = endParent->GetChildAt(--offset);
-    NS_ASSERTION(lastCandidate,
-                 "tree traversal trouble in nsContentSubtreeIterator::Init");
+    MOZ_ASSERT(lastCandidate,
+               "tree traversal trouble in nsContentSubtreeIterator::Init");
   }
 
   if (!lastCandidate) {
     // then lastCandidate is prev node before node
     lastCandidate = GetPrevSibling(node);
   }
 
   if (!lastCandidate) {
@@ -1357,24 +1357,24 @@
   }
 
   if (mCurNode == mLast) {
     mIsDone = true;
     return;
   }
 
   nsINode* nextNode = GetNextSibling(mCurNode);
-  NS_ASSERTION(nextNode, "No next sibling!?! This could mean deadlock!");
+  MOZ_ASSERT(nextNode, "No next sibling!?! This could mean deadlock!");
 
   int32_t i = mEndNodes.IndexOf(nextNode);
   while (i != -1) {
     // as long as we are finding ancestors of the endpoint of the range,
     // dive down into their children
     nextNode = nextNode->GetFirstChild();
-    NS_ASSERTION(nextNode, "Iterator error, expected a child node!");
+    MOZ_ASSERT(nextNode, "Iterator error, expected a child node!");
 
     // should be impossible to get a null pointer.  If we went all the way
     // down the child chain to the bottom without finding an interior node,
     // then the previous node should have been the last, which was
     // was tested at top of routine.
     i = mEndNodes.IndexOf(nextNode);
   }
 
@@ -1439,18 +1439,18 @@
 
   // aNode has a parent, so it must be content.
   nsIContent* content = aNode->AsContent();
 
   // sanity check: aNode is itself in the range
   bool nodeBefore, nodeAfter;
   nsresult res = nsRange::CompareNodeToRange(aNode, mRange,
                                              &nodeBefore, &nodeAfter);
-  NS_ASSERTION(NS_SUCCEEDED(res) && !nodeBefore && !nodeAfter,
-               "aNode isn't in mRange, or something else weird happened");
+  MOZ_ASSERT(NS_SUCCEEDED(res) && !nodeBefore && !nodeAfter,
+             "aNode isn't in mRange, or something else weird happened");
   if (NS_FAILED(res) || nodeBefore || nodeAfter) {
     return nullptr;
   }
 
   while (content) {
     nsIContent* parent = content->GetParent();
     // content always has a parent.  If its parent is the root, however --
     // i.e., either it's not content, or it is content but its own parent is
diff --git a/dom/base/nsContentList.cpp b/dom/base/nsContentList.cpp
--- a/dom/base/nsContentList.cpp
+++ b/dom/base/nsContentList.cpp
@@ -190,17 +190,17 @@
   return list->MatchesKey(*ourKey);
 }
 
 already_AddRefed<nsContentList>
 NS_GetContentList(nsINode* aRootNode, 
                   int32_t  aMatchNameSpaceId,
                   const nsAString& aTagname)
 {
-  NS_ASSERTION(aRootNode, "content list has to have a root");
+  MOZ_ASSERT(aRootNode, "content list has to have a root");
 
   nsRefPtr<nsContentList> list;
   nsContentListKey hashKey(aRootNode, aMatchNameSpaceId, aTagname);
   uint32_t recentlyUsedCacheIndex = RecentlyUsedCacheIndex(hashKey);
   nsContentList* cachedList = sRecentlyUsedContentLists[recentlyUsedCacheIndex];
   if (cachedList && cachedList->MatchesKey(hashKey)) {
     list = cachedList;
     return list.forget();
@@ -307,17 +307,17 @@
 template<class ListType>
 already_AddRefed<nsContentList>
 GetFuncStringContentList(nsINode* aRootNode,
                          nsContentListMatchFunc aFunc,
                          nsContentListDestroyFunc aDestroyFunc,
                          nsFuncStringContentListDataAllocator aDataAllocator,
                          const nsAString& aString)
 {
-  NS_ASSERTION(aRootNode, "content list has to have a root");
+  MOZ_ASSERT(aRootNode, "content list has to have a root");
 
   nsRefPtr<nsCacheableFuncStringContentList> list;
 
   static const PLDHashTableOps hash_table_ops =
   {
     FuncStringContentListHashtableHashKey,
     FuncStringContentListHashtableMatchEntry,
     PL_DHashMoveEntryStub,
@@ -405,19 +405,20 @@
     mXMLMatchAtom(aXMLMatchAtom),
     mFunc(nullptr),
     mDestroyFunc(nullptr),
     mData(nullptr),
     mState(LIST_DIRTY),
     mDeep(aDeep),
     mFuncMayDependOnAttr(false)
 {
-  NS_ASSERTION(mRootNode, "Must have root");
+  MOZ_ASSERT(mRootNode, "Must have root");
   if (nsGkAtoms::_asterix == mHTMLMatchAtom) {
-    NS_ASSERTION(mXMLMatchAtom == nsGkAtoms::_asterix, "HTML atom and XML atom are not both asterix?");
+    MOZ_ASSERT(mXMLMatchAtom == nsGkAtoms::_asterix,
+               "HTML atom and XML atom are not both asterix?");
     mMatchAll = true;
   }
   else {
     mMatchAll = false;
   }
   mRootNode->AddMutationObserver(this);
 
   // We only need to flush if we're in an non-HTML document, since the
@@ -445,17 +446,17 @@
     mFunc(aFunc),
     mDestroyFunc(aDestroyFunc),
     mData(aData),
     mState(LIST_DIRTY),
     mMatchAll(false),
     mDeep(aDeep),
     mFuncMayDependOnAttr(aFuncMayDependOnAttr)
 {
-  NS_ASSERTION(mRootNode, "Must have root");
+  MOZ_ASSERT(mRootNode, "Must have root");
   mRootNode->AddMutationObserver(this);
 
   // We only need to flush if we're in an non-HTML document, since the
   // HTML5 parser doesn't need flushing.  Further, if we're not in a
   // document at all right now (in the GetUncomposedDoc() sense), we're
   // not parser-created and don't need to be flushing stuff under us
   // to get our kids right.
   nsIDocument* doc = mRootNode->GetUncomposedDoc();
@@ -504,18 +505,18 @@
       doc->FlushPendingNotifications(Flush_ContentAndNotify);
     }
   }
 
   if (mState != LIST_UP_TO_DATE)
     PopulateSelf(std::min(aIndex, UINT32_MAX - 1) + 1);
 
   ASSERT_IN_SYNC;
-  NS_ASSERTION(!mRootNode || mState != LIST_DIRTY,
-               "PopulateSelf left the list in a dirty (useless) state!");
+  MOZ_ASSERT(!mRootNode || mState != LIST_DIRTY,
+             "PopulateSelf left the list in a dirty (useless) state!");
 
   return mElements.SafeElementAt(aIndex);
 }
 
 Element*
 nsContentList::NamedItem(const nsAString& aName, bool aDoFlush)
 {
   if (aName.IsEmpty()) {
@@ -909,18 +910,18 @@
 {
   if (!mRootNode) {
     return;
   }
 
   ASSERT_IN_SYNC;
 
   uint32_t count = mElements.Length();
-  NS_ASSERTION(mState != LIST_DIRTY || count == 0,
-               "Reset() not called when setting state to LIST_DIRTY?");
+  MOZ_ASSERT(mState != LIST_DIRTY || count == 0,
+             "Reset() not called when setting state to LIST_DIRTY?");
 
   if (count >= aNeededLength) // We're all set
     return;
 
   uint32_t elementsToAppend = aNeededLength - count;
 #ifdef DEBUG
   uint32_t invariant = elementsToAppend + mElements.Length();
 #endif
@@ -946,18 +947,18 @@
     for ( ; cur && elementsToAppend; cur = cur->GetNextSibling()) {
       if (cur->IsElement() && Match(cur->AsElement())) {
         mElements.AppendElement(cur);
         --elementsToAppend;
       }
     }
   }
 
-  NS_ASSERTION(elementsToAppend + mElements.Length() == invariant,
-               "Something is awry!");
+  MOZ_ASSERT(elementsToAppend + mElements.Length() == invariant,
+             "Something is awry!");
 
   if (elementsToAppend != 0)
     mState = LIST_UP_TO_DATE;
   else
     mState = LIST_LAZY;
 
   ASSERT_IN_SYNC;
 }
@@ -998,18 +999,18 @@
       doc->FlushPendingNotifications(Flush_ContentAndNotify);
     }
   }
 
   if (mState != LIST_UP_TO_DATE)
     PopulateSelf(uint32_t(-1));
     
   ASSERT_IN_SYNC;
-  NS_ASSERTION(!mRootNode || mState == LIST_UP_TO_DATE,
-               "PopulateSelf dod not bring content list up to date!");
+  MOZ_ASSERT(!mRootNode || mState == LIST_UP_TO_DATE,
+             "PopulateSelf dod not bring content list up to date!");
 }
 
 nsCacheableFuncStringContentList::~nsCacheableFuncStringContentList()
 {
   RemoveFromFuncStringHashtable();
 }
 
 void
@@ -1031,18 +1032,18 @@
 void
 nsContentList::AssertInSync()
 {
   if (mState == LIST_DIRTY) {
     return;
   }
 
   if (!mRootNode) {
-    NS_ASSERTION(mElements.Length() == 0 && mState == LIST_DIRTY,
-                 "Empty iterator isn't quite empty?");
+    MOZ_ASSERT(mElements.Length() == 0 && mState == LIST_DIRTY,
+               "Empty iterator isn't quite empty?");
     return;
   }
 
   // XXX This code will need to change if nsContentLists can ever match
   // elements that are outside of the document element.
   nsIContent *root;
   if (mRootNode->IsNodeOfType(nsINode::eDOCUMENT)) {
     root = static_cast<nsIDocument*>(mRootNode)->GetRootElement();
@@ -1066,21 +1067,21 @@
 
     nsIContent *cur = mDeep ? iter->GetCurrentNode() :
                               mRootNode->GetChildAt(index++);
     if (!cur) {
       break;
     }
 
     if (cur->IsElement() && Match(cur->AsElement())) {
-      NS_ASSERTION(cnt < mElements.Length() && mElements[cnt] == cur,
-                   "Elements is out of sync");
+      MOZ_ASSERT(cnt < mElements.Length() && mElements[cnt] == cur,
+                 "Elements is out of sync");
       ++cnt;
     }
 
     if (mDeep) {
       iter->Next();
     }
   }
 
-  NS_ASSERTION(cnt == mElements.Length(), "Too few elements");
+  MOZ_ASSERT(cnt == mElements.Length(), "Too few elements");
 }
 #endif
diff --git a/dom/base/nsContentList.h b/dom/base/nsContentList.h
--- a/dom/base/nsContentList.h
+++ b/dom/base/nsContentList.h
@@ -67,17 +67,17 @@
   /**
    * Insert the element at a given index, shifting the objects at
    * the given index and later to make space.
    * @param aContent Element to insert, must not be null
    * @param aIndex Index to insert the element at.
    */
   void InsertElementAt(nsIContent* aContent, int32_t aIndex)
   {
-    NS_ASSERTION(aContent, "Element to insert must not be null");
+    MOZ_ASSERT(aContent, "Element to insert must not be null");
     mElements.InsertElementAt(aIndex, aContent);
   }
 
   void RemoveElement(nsIContent *aContent)
   {
     mElements.RemoveElement(aContent);
   }
 
@@ -302,17 +302,17 @@
     nsINodeList* list = static_cast<nsINodeList*>(aSupports);
 #ifdef DEBUG
     {
       nsCOMPtr<nsINodeList> list_qi = do_QueryInterface(aSupports);
 
       // If this assertion fires the QI implementation for the object in
       // question doesn't use the nsINodeList pointer as the nsISupports
       // pointer. That must be fixed, or we'll crash...
-      NS_ASSERTION(list_qi == list, "Uh, fix QI!");
+      MOZ_ASSERT(list_qi == list, "Uh, fix QI!");
     }
 #endif
     return static_cast<nsContentList*>(list);
   }
 
   bool MatchesKey(const nsContentListKey& aKey) const
   {
     // The root node is most commonly the same: the document.  And the
diff --git a/dom/base/nsContentPermissionHelper.cpp b/dom/base/nsContentPermissionHelper.cpp
--- a/dom/base/nsContentPermissionHelper.cpp
+++ b/dom/base/nsContentPermissionHelper.cpp
@@ -67,17 +67,17 @@
 {
   MOZ_COUNT_DTOR(ContentPermissionRequestParent);
 }
 
 bool
 ContentPermissionRequestParent::Recvprompt()
 {
   mProxy = new nsContentPermissionRequestProxy();
-  NS_ASSERTION(mProxy, "Alloc of request proxy failed");
+  MOZ_ASSERT(mProxy, "Alloc of request proxy failed");
   if (NS_FAILED(mProxy->Init(mRequests, this))) {
     mProxy->Cancel();
   }
   return true;
 }
 
 void
 ContentPermissionRequestParent::ActorDestroy(ActorDestroyReason why)
@@ -288,17 +288,17 @@
 {
   MOZ_COUNT_DTOR(nsContentPermissionRequestProxy);
 }
 
 nsresult
 nsContentPermissionRequestProxy::Init(const nsTArray<PermissionRequest>& requests,
                                       ContentPermissionRequestParent* parent)
 {
-  NS_ASSERTION(parent, "null parent");
+  MOZ_ASSERT(parent, "null parent");
   mParent = parent;
   mPermissionRequests = requests;
 
   nsCOMPtr<nsIContentPermissionPrompt> prompt = do_GetService(NS_CONTENT_PERMISSION_PROMPT_CONTRACTID);
   if (!prompt) {
     return NS_ERROR_FAILURE;
   }
 
@@ -455,24 +455,24 @@
   , mWindow(aWindow)
   , mIPCOpen(false)
 {
 }
 
 void
 RemotePermissionRequest::DoCancel()
 {
-  NS_ASSERTION(mRequest, "We need a request");
+  MOZ_ASSERT(mRequest, "We need a request");
   mRequest->Cancel();
 }
 
 void
 RemotePermissionRequest::DoAllow(JS::HandleValue aChoices)
 {
-  NS_ASSERTION(mRequest, "We need a request");
+  MOZ_ASSERT(mRequest, "We need a request");
   mRequest->Allow(aChoices);
 }
 
 // PContentPermissionRequestChild
 bool
 RemotePermissionRequest::Recv__delete__(const bool& aAllow,
                                         InfallibleTArray<PermissionChoice>&& aChoices)
 {
diff --git a/dom/base/nsContentPolicy.cpp b/dom/base/nsContentPolicy.cpp
--- a/dom/base/nsContentPolicy.cpp
+++ b/dom/base/nsContentPolicy.cpp
@@ -83,18 +83,18 @@
     NS_PRECONDITION(decision, "Null out pointer");
     WARN_IF_URI_UNINITIALIZED(contentLocation, "Request URI");
     WARN_IF_URI_UNINITIALIZED(requestingLocation, "Requesting URI");
 
 #ifdef DEBUG
     {
         nsCOMPtr<nsIDOMNode> node(do_QueryInterface(requestingContext));
         nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(requestingContext));
-        NS_ASSERTION(!requestingContext || node || window,
-                     "Context should be a DOM node or a DOM window!");
+        MOZ_ASSERT(!requestingContext || node || window,
+                   "Context should be a DOM node or a DOM window!");
     }
 #endif
 
     /*
      * There might not be a requestinglocation. This can happen for
      * iframes with an image as src. Get the uri from the dom node.
      * See bug 254510
      */
diff --git a/dom/base/nsContentSink.cpp b/dom/base/nsContentSink.cpp
--- a/dom/base/nsContentSink.cpp
+++ b/dom/base/nsContentSink.cpp
@@ -81,25 +81,25 @@
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mNodeInfoManager)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptLoader)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 
 nsContentSink::nsContentSink()
 {
   // We have a zeroing operator new
-  NS_ASSERTION(!mLayoutStarted, "What?");
-  NS_ASSERTION(!mDynamicLowerValue, "What?");
-  NS_ASSERTION(!mParsing, "What?");
-  NS_ASSERTION(mLastSampledUserEventTime == 0, "What?");
-  NS_ASSERTION(mDeflectedCount == 0, "What?");
-  NS_ASSERTION(!mDroppedTimer, "What?");
-  NS_ASSERTION(mInMonolithicContainer == 0, "What?");
-  NS_ASSERTION(mInNotification == 0, "What?");
-  NS_ASSERTION(!mDeferredLayoutStart, "What?");
+  MOZ_ASSERT(!mLayoutStarted, "What?");
+  MOZ_ASSERT(!mDynamicLowerValue, "What?");
+  MOZ_ASSERT(!mParsing, "What?");
+  MOZ_ASSERT(mLastSampledUserEventTime == 0, "What?");
+  MOZ_ASSERT(mDeflectedCount == 0, "What?");
+  MOZ_ASSERT(!mDroppedTimer, "What?");
+  MOZ_ASSERT(mInMonolithicContainer == 0, "What?");
+  MOZ_ASSERT(mInNotification == 0, "What?");
+  MOZ_ASSERT(!mDeferredLayoutStart, "What?");
 
 #ifdef DEBUG
   if (!gContentSinkLogModuleInfo) {
     gContentSinkLogModuleInfo = PR_NewLogModule("nscontentsink");
   }
 #endif
 }
 
@@ -206,19 +206,19 @@
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsContentSink::StyleSheetLoaded(CSSStyleSheet* aSheet,
                                 bool aWasAlternate,
                                 nsresult aStatus)
 {
-  NS_ASSERTION(!mRunsToCompletion, "How come a fragment parser observed sheets?");
+  MOZ_ASSERT(!mRunsToCompletion, "How come a fragment parser observed sheets?");
   if (!aWasAlternate) {
-    NS_ASSERTION(mPendingSheetCount > 0, "How'd that happen?");
+    MOZ_ASSERT(mPendingSheetCount > 0, "How'd that happen?");
     --mPendingSheetCount;
 
     if (mPendingSheetCount == 0 &&
         (mDeferredLayoutStart || mDeferredFlushTags)) {
       if (mDeferredFlushTags) {
         FlushTags();
       }
       if (mDeferredLayoutStart) {
@@ -256,18 +256,17 @@
   nsAutoCString linkHeader;
   
   nsresult rv = httpchannel->GetResponseHeader(NS_LITERAL_CSTRING("link"),
                                                linkHeader);
   if (NS_SUCCEEDED(rv) && !linkHeader.IsEmpty()) {
     mDocument->SetHeaderData(nsGkAtoms::link,
                              NS_ConvertASCIItoUTF16(linkHeader));
 
-    NS_ASSERTION(!mProcessLinkHeaderEvent.get(),
-                 "Already dispatched an event?");
+    MOZ_ASSERT(!mProcessLinkHeaderEvent.get(), "Already dispatched an event?");
 
     mProcessLinkHeaderEvent =
       NS_NewNonOwningRunnableMethod(this,
         &nsContentSink::DoProcessLinkHeader);
     rv = NS_DispatchToCurrentThread(mProcessLinkHeaderEvent.get());
     if (NS_FAILED(rv)) {
       mProcessLinkHeaderEvent.Forget();
     }
@@ -723,19 +722,19 @@
   nsresult rv = NS_NewURI(getter_AddRefs(url), aHref, nullptr,
                           mDocument->GetDocBaseURI());
   
   if (NS_FAILED(rv)) {
     // The URI is bad, move along, don't propagate the error (for now)
     return NS_OK;
   }
 
-  NS_ASSERTION(!aElement ||
+  MOZ_ASSERT(!aElement ||
                aElement->NodeType() == nsIDOMNode::PROCESSING_INSTRUCTION_NODE,
-               "We only expect processing instructions here");
+             "We only expect processing instructions here");
 
   // If this is a fragment parser, we don't want to observe.
   // We don't support CORS for processing instructions
   bool isAlternate;
   rv = mCSSLoader->LoadStyleLink(aElement, url, aTitle, aMedia, aAlternate,
                                  CORS_NONE, mDocument->GetReferrerPolicy(),
                                  mRunsToCompletion ? nullptr : this, &isAlternate);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -747,17 +746,17 @@
 
   return NS_OK;
 }
 
 
 nsresult
 nsContentSink::ProcessMETATag(nsIContent* aContent)
 {
-  NS_ASSERTION(aContent, "missing meta-element");
+  MOZ_ASSERT(aContent, "missing meta-element");
 
   nsresult rv = NS_OK;
 
   // set any HTTP-EQUIV data into document's header data as well as url
   nsAutoString header;
   aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::httpEquiv, header);
   if (!header.IsEmpty()) {
     nsAutoString result;
@@ -864,18 +863,18 @@
                                  CacheSelectionAction *aAction)
 {
   nsresult rv;
 
   *aAction = CACHE_SELECTION_NONE;
 
   nsCOMPtr<nsIApplicationCacheContainer> applicationCacheDocument =
     do_QueryInterface(mDocument);
-  NS_ASSERTION(applicationCacheDocument,
-               "mDocument must implement nsIApplicationCacheContainer.");
+  MOZ_ASSERT(applicationCacheDocument,
+             "mDocument must implement nsIApplicationCacheContainer.");
 
   if (aLoadApplicationCache) {
     nsCOMPtr<nsIURI> groupURI;
     rv = aLoadApplicationCache->GetManifestURI(getter_AddRefs(groupURI));
     NS_ENSURE_SUCCESS(rv, rv);
 
     bool equal = false;
     rv = groupURI->Equals(aManifestURI, &equal);
@@ -937,18 +936,18 @@
 
   nsresult rv;
 
   if (aLoadApplicationCache) {
     // The document was loaded from an application cache, use that
     // application cache as the document's application cache.
     nsCOMPtr<nsIApplicationCacheContainer> applicationCacheDocument =
       do_QueryInterface(mDocument);
-    NS_ASSERTION(applicationCacheDocument,
-                 "mDocument must implement nsIApplicationCacheContainer.");
+    MOZ_ASSERT(applicationCacheDocument,
+               "mDocument must implement nsIApplicationCacheContainer.");
 
 #ifdef DEBUG
     nsAutoCString docURISpec, clientID;
     mDocumentURI->GetAsciiSpec(docURISpec);
     aLoadApplicationCache->GetClientID(clientID);
     SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_CALLS,
         ("Selection, no manifest: assigning app cache %s to document %s", clientID.get(), docURISpec.get()));
 #endif
@@ -1113,18 +1112,18 @@
 
     nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(mDocShell);
 
     webNav->Stop(nsIWebNavigation::STOP_ALL);
     webNav->Reload(nsIWebNavigation::LOAD_FLAGS_NONE);
     break;
   }
   default:
-    NS_ASSERTION(false,
-          "Cache selection algorithm didn't decide on proper action");
+    MOZ_ASSERT(false,
+               "Cache selection algorithm didn't decide on proper action");
     break;
   }
 }
 
 void
 nsContentSink::ScrollToRef()
 {
   mDocument->ScrollToRef();
diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -363,17 +363,17 @@
 public:
   explicit EventListenerManagerMapEntry(const void* aKey)
     : mKey(aKey)
   {
   }
 
   ~EventListenerManagerMapEntry()
   {
-    NS_ASSERTION(!mListenerManager, "caller must release and disconnect ELM");
+    MOZ_ASSERT(!mListenerManager, "caller must release and disconnect ELM");
   }
 
 protected:          // declared protected to silence clang warnings
   const void *mKey; // must be first, to look like PLDHashEntryStub
 
 public:
   nsRefPtr<EventListenerManager> mListenerManager;
 };
@@ -593,18 +593,20 @@
   nsCOMPtr<nsIStringBundleService> bundleService =
     mozilla::services::GetStringBundleService();
   nsCOMPtr<nsIStringBundle> bundle;
   DebugOnly<nsresult> rv = NS_OK;
   if (bundleService) {
     rv = bundleService->CreateBundle( "chrome://global-platform/locale/platformKeys.properties",
                                       getter_AddRefs(bundle));
   }
-  
-  NS_ASSERTION(NS_SUCCEEDED(rv) && bundle, "chrome://global/locale/platformKeys.properties could not be loaded");
+
+  MOZ_ASSERT(
+    NS_SUCCEEDED(rv) && bundle,
+    "chrome://global/locale/platformKeys.properties could not be loaded");
   nsXPIDLString shiftModifier;
   nsXPIDLString metaModifier;
   nsXPIDLString osModifier;
   nsXPIDLString altModifier;
   nsXPIDLString controlModifier;
   nsXPIDLString modifierSeparator;
   if (bundle) {
     //macs use symbols for each modifier key, so fetch each from the bundle, which also covers i18n
@@ -621,18 +623,18 @@
   sOSText = new nsString(osModifier);
   sAltText = new nsString(altModifier);
   sControlText = new nsString(controlModifier);
   sModifierSeparator = new nsString(modifierSeparator);  
 }
 
 bool
 nsContentUtils::InitializeEventTable() {
-  NS_ASSERTION(!sAtomEventTable, "EventTable already initialized!");
-  NS_ASSERTION(!sStringEventTable, "EventTable already initialized!");
+  MOZ_ASSERT(!sAtomEventTable, "EventTable already initialized!");
+  MOZ_ASSERT(!sStringEventTable, "EventTable already initialized!");
 
   static const EventNameMapping eventArray[] = {
 #define EVENT(name_,  _id, _type, _class)          \
     { nsGkAtoms::on##name_, _id, _type, _class },
 #define WINDOW_ONLY_EVENT EVENT
 #define NON_IDL_EVENT EVENT
 #include "mozilla/EventNameList.h"
 #undef WINDOW_ONLY_EVENT
@@ -1757,36 +1759,35 @@
   delete sAtomEventTable;
   sAtomEventTable = nullptr;
   delete sStringEventTable;
   sStringEventTable = nullptr;
   delete sUserDefinedEvents;
   sUserDefinedEvents = nullptr;
 
   if (sEventListenerManagersHash.IsInitialized()) {
-    NS_ASSERTION(sEventListenerManagersHash.EntryCount() == 0,
-                 "Event listener manager hash not empty at shutdown!");
+    MOZ_ASSERT(sEventListenerManagersHash.EntryCount() == 0,
+               "Event listener manager hash not empty at shutdown!");
 
     // See comment above.
 
     // However, we have to handle this table differently.  If it still
     // has entries, we want to leak it too, so that we can keep it alive
     // in case any elements are destroyed.  Because if they are, we need
     // their event listener managers to be destroyed too, or otherwise
     // it could leave dangling references in DOMClassInfo's preserved
     // wrapper table.
 
     if (sEventListenerManagersHash.EntryCount() == 0) {
       PL_DHashTableFinish(&sEventListenerManagersHash);
     }
   }
 
-  NS_ASSERTION(!sBlockedScriptRunners ||
-               sBlockedScriptRunners->Length() == 0,
-               "How'd this happen?");
+  MOZ_ASSERT(!sBlockedScriptRunners || sBlockedScriptRunners->Length() == 0,
+             "How'd this happen?");
   delete sBlockedScriptRunners;
   sBlockedScriptRunners = nullptr;
 
   delete sShiftText;
   sShiftText = nullptr;
   delete sControlText;  
   sControlText = nullptr;
   delete sMetaText;  
@@ -2221,17 +2222,17 @@
   uint32_t pos1 = parents1.Length() - 1;
   uint32_t pos2 = parents2.Length() - 1;
   
   bool disconnected = parents1.ElementAt(pos1) != parents2.ElementAt(pos2);
   if (aDisconnected) {
     *aDisconnected = disconnected;
   }
   if (disconnected) {
-    NS_ASSERTION(aDisconnected, "unexpected disconnected nodes");
+    MOZ_ASSERT(aDisconnected, "unexpected disconnected nodes");
     return 1;
   }
 
   // Find where the parent chains differ
   nsINode* parent = parents1.ElementAt(pos1);
   uint32_t len;
   for (len = std::min(pos1, pos2); len > 0; --len) {
     nsINode* child1 = parents1.ElementAt(--pos1);
@@ -2241,18 +2242,18 @@
     }
     parent = child1;
   }
 
   
   // The parent chains never differed, so one of the nodes is an ancestor of
   // the other
 
-  NS_ASSERTION(!pos1 || !pos2,
-               "should have run out of parent chain for one of the nodes");
+  MOZ_ASSERT(!pos1 || !pos2,
+             "should have run out of parent chain for one of the nodes");
 
   if (!pos1) {
     nsINode* child2 = parents2.ElementAt(--pos2);
     return aOffset1 <= parent->IndexOf(child2) ? -1 : 1;
   }
 
   nsINode* child1 = parents1.ElementAt(--pos1);
   return parent->IndexOf(child1) < aOffset2 ? -1 : 1;
@@ -2982,18 +2983,18 @@
     // nothing we can do here
     return NS_OK;
   }
 
   nsCOMPtr<nsILoadGroup> loadGroup = aLoadingDocument->GetDocumentLoadGroup();
 
   nsIURI *documentURI = aLoadingDocument->GetDocumentURI();
 
-  NS_ASSERTION(loadGroup || IsFontTableURI(documentURI),
-               "Could not get loadgroup; onload may fire too early");
+  MOZ_ASSERT(loadGroup || IsFontTableURI(documentURI),
+             "Could not get loadgroup; onload may fire too early");
 
   // Make the URI immutable so people won't change it under us
   NS_TryToSetImmutable(aURI);
 
   // XXXbz using "documentURI" for the initialDocumentURI is not quite
   // right, but the best we can do here...
   return imgLoader->LoadImage(aURI,                 /* uri to load */
                               documentURI,          /* initialDocumentURI */
@@ -3284,19 +3285,19 @@
                                 const char *aMessageName,
                                 const char16_t **aParams,
                                 uint32_t aParamsLength,
                                 nsIURI* aURI,
                                 const nsAFlatString& aSourceLine,
                                 uint32_t aLineNumber,
                                 uint32_t aColumnNumber)
 {
-  NS_ASSERTION((aParams && aParamsLength) || (!aParams && !aParamsLength),
-               "Supply either both parameters and their number or no"
-               "parameters and 0.");
+  MOZ_ASSERT((aParams && aParamsLength) || (!aParams && !aParamsLength),
+             "Supply either both parameters and their number or no"
+             "parameters and 0.");
 
   nsresult rv;
   nsXPIDLString errorText;
   if (aParams) {
     rv = FormatLocalizedString(aFile, aMessageName, aParams, aParamsLength,
                                errorText);
   }
   else {
@@ -3645,17 +3646,17 @@
 
   nsCOMPtr<nsIDOMEvent> event;
   nsCOMPtr<EventTarget> target;
   nsresult rv = GetEventAndTarget(aDoc, aTarget, aEventName, aCanBubble,
                                   aCancelable, true, getter_AddRefs(event),
                                   getter_AddRefs(target));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  NS_ASSERTION(aDoc, "GetEventAndTarget lied?");
+  MOZ_ASSERT(aDoc, "GetEventAndTarget lied?");
   if (!aDoc->GetWindow())
     return NS_ERROR_INVALID_ARG;
 
   EventTarget* piTarget = aDoc->GetWindow()->GetParentTarget();
   if (!piTarget)
     return NS_ERROR_INVALID_ARG;
 
   nsEventStatus status = nsEventStatus_eIgnore;
@@ -4080,17 +4081,17 @@
   }
 
   // If we don't have a document here, we can't get the right security context
   // for compiling event handlers... so just bail out.
   nsCOMPtr<nsIDocument> document = aContextNode->OwnerDoc();
   bool isHTML = document->IsHTML();
 #ifdef DEBUG
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(document);
-  NS_ASSERTION(!isHTML || htmlDoc, "Should have HTMLDocument here!");
+  MOZ_ASSERT(!isHTML || htmlDoc, "Should have HTMLDocument here!");
 #endif
 
   if (isHTML) {
     nsRefPtr<DocumentFragment> frag =
       new DocumentFragment(document->NodeInfoManager());
     
     nsCOMPtr<nsIContent> contextAsContent = do_QueryInterface(aContextNode);
     if (contextAsContent && !contextAsContent->IsElement()) {
@@ -4685,17 +4686,17 @@
 
 /* static */
 void
 nsContentUtils::TriggerLink(nsIContent *aContent, nsPresContext *aPresContext,
                             nsIURI *aLinkURI, const nsString &aTargetSpec,
                             bool aClick, bool aIsUserTriggered,
                             bool aIsTrusted)
 {
-  NS_ASSERTION(aPresContext, "Need a nsPresContext");
+  MOZ_ASSERT(aPresContext, "Need a nsPresContext");
   NS_PRECONDITION(aLinkURI, "No link URI");
 
   if (aContent->IsEditable()) {
     return;
   }
 
   nsILinkHandler *handler = aPresContext->GetLinkHandler();
   if (!handler) {
@@ -4819,18 +4820,18 @@
   aDOMKeyEvent->GetType(eventType);
   // Don't process if aDOMKeyEvent is not a keypress event.
   if (!eventType.EqualsLiteral("keypress"))
     return;
 
   WidgetKeyboardEvent* nativeKeyEvent =
     aDOMKeyEvent->GetInternalNSEvent()->AsKeyboardEvent();
   if (nativeKeyEvent) {
-    NS_ASSERTION(nativeKeyEvent->mClass == eKeyboardEventClass,
-                 "wrong type of native event");
+    MOZ_ASSERT(nativeKeyEvent->mClass == eKeyboardEventClass,
+               "wrong type of native event");
     // nsShortcutCandidate::mCharCode is a candidate charCode.
     // nsShoftcutCandidate::mIgnoreShift means the mCharCode should be tried to
     // execute a command with/without shift key state. If this is TRUE, the
     // shifted key state should be ignored. Otherwise, don't ignore the state.
     // the priority of the charCodes are (shift key is not pressed):
     //   0: charCode/false,
     //   1: unshiftedCharCodes[0]/false, 2: unshiftedCharCodes[1]/false...
     // the priority of the charCodes are (shift key is pressed):
@@ -4982,47 +4983,45 @@
 #endif
 
 /* static */
 void
 nsContentUtils::RemoveScriptBlocker()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!sRemovingScriptBlockers);
-  NS_ASSERTION(sScriptBlockerCount != 0, "Negative script blockers");
+  MOZ_ASSERT(sScriptBlockerCount != 0, "Negative script blockers");
   --sScriptBlockerCount;
   if (sScriptBlockerCount) {
     return;
   }
 
   if (!sBlockedScriptRunners) {
     return;
   }
 
   uint32_t firstBlocker = sRunnersCountAtFirstBlocker;
   uint32_t lastBlocker = sBlockedScriptRunners->Length();
   uint32_t originalFirstBlocker = firstBlocker;
   uint32_t blockersCount = lastBlocker - firstBlocker;
   sRunnersCountAtFirstBlocker = 0;
-  NS_ASSERTION(firstBlocker <= lastBlocker,
-               "bad sRunnersCountAtFirstBlocker");
+  MOZ_ASSERT(firstBlocker <= lastBlocker, "bad sRunnersCountAtFirstBlocker");
 
   while (firstBlocker < lastBlocker) {
     nsCOMPtr<nsIRunnable> runnable;
     runnable.swap((*sBlockedScriptRunners)[firstBlocker]);
     ++firstBlocker;
 
     // Calling the runnable can reenter us
     runnable->Run();
     // So can dropping the reference to the runnable
     runnable = nullptr;
 
-    NS_ASSERTION(sRunnersCountAtFirstBlocker == 0,
-                 "Bad count");
-    NS_ASSERTION(!sScriptBlockerCount, "This is really bad");
+    MOZ_ASSERT(sRunnersCountAtFirstBlocker == 0, "Bad count");
+    MOZ_ASSERT(!sScriptBlockerCount, "This is really bad");
   }
 #ifdef DEBUG
   AutoRestore<bool> removingScriptBlockers(sRemovingScriptBlockers);
   sRemovingScriptBlockers = true;
 #endif
   sBlockedScriptRunners->RemoveElementsAt(originalFirstBlocker, blockersCount);
 }
 
@@ -5255,19 +5254,19 @@
 nsContentUtils::SetDataTransferInEvent(WidgetDragEvent* aDragEvent)
 {
   if (aDragEvent->dataTransfer || !aDragEvent->mFlags.mIsTrusted)
     return NS_OK;
 
   // For draggesture and dragstart events, the data transfer object is
   // created before the event fires, so it should already be set. For other
   // drag events, get the object from the drag session.
-  NS_ASSERTION(aDragEvent->message != NS_DRAGDROP_GESTURE &&
+  MOZ_ASSERT(aDragEvent->message != NS_DRAGDROP_GESTURE &&
                aDragEvent->message != NS_DRAGDROP_START,
-               "draggesture event created without a dataTransfer");
+             "draggesture event created without a dataTransfer");
 
   nsCOMPtr<nsIDragSession> dragSession = GetDragSession();
   NS_ENSURE_TRUE(dragSession, NS_OK); // no drag in progress
 
   nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
   nsCOMPtr<DataTransfer> initialDataTransfer;
   dragSession->GetDataTransfer(getter_AddRefs(dataTransfer));
   if (dataTransfer) {
@@ -5994,17 +5993,17 @@
 
   int32_t dataLen = aData.Length();
   *aResult = JS_NewArrayBuffer(aCx, dataLen);
   if (!*aResult) {
     return NS_ERROR_FAILURE;
   }
 
   if (dataLen > 0) {
-    NS_ASSERTION(JS_IsArrayBufferObject(*aResult), "What happened?");
+    MOZ_ASSERT(JS_IsArrayBufferObject(*aResult), "What happened?");
     JS::AutoCheckCannotGC nogc;
     memcpy(JS_GetArrayBufferData(*aResult, nogc), aData.BeginReading(), dataLen);
   }
 
   return NS_OK;
 }
 
 // Initial implementation: only stores to RAM, not file
@@ -6425,17 +6424,17 @@
   }
 
   return nullptr;
 }
 
 bool
 nsContentUtils::GetContentSecurityPolicy(nsIContentSecurityPolicy** aCSP)
 {
-  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
+  MOZ_ASSERT(NS_IsMainThread(), "Wrong thread!");
 
   nsCOMPtr<nsIContentSecurityPolicy> csp;
   nsresult rv = SubjectPrincipal()->GetCsp(getter_AddRefs(csp));
   if (NS_FAILED(rv)) {
     NS_ERROR("CSP: Failed to get CSP from principal.");
     return false;
   }
 
@@ -6443,17 +6442,17 @@
   return true;
 }
 
 // static
 bool
 nsContentUtils::IsPatternMatching(nsAString& aValue, nsAString& aPattern,
                                   nsIDocument* aDocument)
 {
-  NS_ASSERTION(aDocument, "aDocument should be a valid pointer (not null)");
+  MOZ_ASSERT(aDocument, "aDocument should be a valid pointer (not null)");
 
   AutoJSAPI jsapi;
   jsapi.Init();
   JSContext* cx = jsapi.cx();
   // We can use the junk scope here, because we're just using it for
   // regexp evaluation, not actual script execution.
   JSAutoCompartment ac(cx, xpc::UnprivilegedJunkScope());
 
@@ -6654,18 +6653,18 @@
                                                    nsIContent* aDest,
                                                    int32_t aOldChildCount)
 {
   // Fire mutation events. Optimize for the case when there are no listeners
   int32_t newChildCount = aDest->GetChildCount();
   if (newChildCount && nsContentUtils::
         HasMutationListeners(aDoc, NS_EVENT_BITS_MUTATION_NODEINSERTED)) {
     nsAutoTArray<nsCOMPtr<nsIContent>, 50> childNodes;
-    NS_ASSERTION(newChildCount - aOldChildCount >= 0,
-                 "What, some unexpected dom mutation has happened?");
+    MOZ_ASSERT(newChildCount - aOldChildCount >= 0,
+               "What, some unexpected dom mutation has happened?");
     childNodes.SetCapacity(newChildCount - aOldChildCount);
     for (nsIContent* child = aDest->GetFirstChild();
          child;
          child = child->GetNextSibling()) {
       childNodes.AppendElement(child);
     }
     FragmentOrElement::FireNodeInserted(aDoc, aDest, childNodes);
   }
@@ -6759,24 +6758,26 @@
 
   nsCOMPtr<nsINode> anchorNode = aSelection->GetAnchorNode();
   uint32_t anchorOffset = aSelection->AnchorOffset();
   nsCOMPtr<nsINode> focusNode = aSelection->GetFocusNode();
   uint32_t focusOffset = aSelection->FocusOffset();
 
   // We have at most two children, consisting of an optional text node followed
   // by an optional <br>.
-  NS_ASSERTION(aRoot->GetChildCount() <= 2, "Unexpected children");
+  MOZ_ASSERT(aRoot->GetChildCount() <= 2, "Unexpected children");
   nsCOMPtr<nsIContent> firstChild = aRoot->GetFirstChild();
 #ifdef DEBUG
   nsCOMPtr<nsIContent> lastChild = aRoot->GetLastChild();
-  NS_ASSERTION(anchorNode == aRoot || anchorNode == firstChild ||
-               anchorNode == lastChild, "Unexpected anchorNode");
-  NS_ASSERTION(focusNode == aRoot || focusNode == firstChild ||
-               focusNode == lastChild, "Unexpected focusNode");
+  MOZ_ASSERT(anchorNode == aRoot || anchorNode == firstChild ||
+               anchorNode == lastChild,
+             "Unexpected anchorNode");
+  MOZ_ASSERT(focusNode == aRoot || focusNode == firstChild ||
+               focusNode == lastChild,
+             "Unexpected focusNode");
 #endif
   if (!firstChild || !firstChild->IsNodeOfType(nsINode::eTEXT)) {
     // No text node, so everything is 0
     anchorOffset = focusOffset = 0;
   } else {
     // First child is text.  If the anchor/focus is already in the text node,
     // or the start of the root node, no change needed.  If it's in the root
     // node but not the start, or in the trailing <br>, we need to set the
diff --git a/dom/base/nsCopySupport.cpp b/dom/base/nsCopySupport.cpp
--- a/dom/base/nsCopySupport.cpp
+++ b/dom/base/nsCopySupport.cpp
@@ -95,17 +95,17 @@
   nsAutoString mimeType;
   mimeType.AssignLiteral(kUnicodeMime);
 
   // Do the first and potentially trial encoding as preformatted and raw.
   uint32_t flags = aFlags | nsIDocumentEncoder::OutputPreformatted
                           | nsIDocumentEncoder::OutputRaw;
 
   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aDoc);
-  NS_ASSERTION(domDoc, "Need a document");
+  MOZ_ASSERT(domDoc, "Need a document");
 
   rv = docEncoder->Init(domDoc, mimeType, flags);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = docEncoder->SetSelection(aSel);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // SetSelection set the mime type to text/plain if the selection is inside a
@@ -340,17 +340,17 @@
     if (NS_FAILED(rv)) break;
     override = do_QueryInterface(isupp);
     if (override)
     {
 #ifdef DEBUG
       nsresult hookResult =
 #endif
       override->OnCopyOrDrag(nullptr, aTrans, aDoPutOnClipboard);
-      NS_ASSERTION(NS_SUCCEEDED(hookResult), "OnCopyOrDrag hook failed");
+      MOZ_ASSERT(NS_SUCCEEDED(hookResult), "OnCopyOrDrag hook failed");
       if (!*aDoPutOnClipboard)
         break;
     }
   }
 
   return rv;
 }
 
@@ -370,17 +370,17 @@
   uint32_t flags = aFlags | nsIDocumentEncoder::SkipInvisibleContent;
   
   if (aMimeType.EqualsLiteral("text/plain"))
     flags |= nsIDocumentEncoder::OutputPreformatted;
 
   NS_ConvertASCIItoUTF16 unicodeMimeType(aMimeType);
 
   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aDoc);
-  NS_ASSERTION(domDoc, "Need a document");
+  MOZ_ASSERT(domDoc, "Need a document");
 
   rv = docEncoder->Init(domDoc, unicodeMimeType, flags);
   if (NS_FAILED(rv)) return rv;
   
   if (aSel)
   {
     rv = docEncoder->SetSelection(aSel);
     if (NS_FAILED(rv)) return rv;
@@ -579,18 +579,18 @@
   bool isCollapsed;
   sel->GetIsCollapsed(&isCollapsed);
   return !isCollapsed;
 }
 
 bool
 nsCopySupport::FireClipboardEvent(int32_t aType, int32_t aClipboardType, nsIPresShell* aPresShell, nsISelection* aSelection)
 {
-  NS_ASSERTION(aType == NS_CUT || aType == NS_COPY || aType == NS_PASTE,
-               "Invalid clipboard event type");
+  MOZ_ASSERT(aType == NS_CUT || aType == NS_COPY || aType == NS_PASTE,
+             "Invalid clipboard event type");
 
   nsCOMPtr<nsIPresShell> presShell = aPresShell;
   if (!presShell)
     return false;
 
   nsCOMPtr<nsIDocument> doc = presShell->GetDocument();
   if (!doc)
     return false;
diff --git a/dom/base/nsDOMAttributeMap.cpp b/dom/base/nsDOMAttributeMap.cpp
--- a/dom/base/nsDOMAttributeMap.cpp
+++ b/dom/base/nsDOMAttributeMap.cpp
@@ -163,17 +163,17 @@
       mAttributeCache->Remove(attr);
     }
   }
 }
 
 already_AddRefed<Attr>
 nsDOMAttributeMap::RemoveAttribute(mozilla::dom::NodeInfo* aNodeInfo)
 {
-  NS_ASSERTION(aNodeInfo, "RemoveAttribute() called with aNodeInfo == nullptr!");
+  MOZ_ASSERT(aNodeInfo, "RemoveAttribute() called with aNodeInfo == nullptr!");
 
   nsAttrKey attr(aNodeInfo->NamespaceID(), aNodeInfo->NameAtom());
 
   nsRefPtr<Attr> node;
   if (mAttributeCache && mAttributeCache->Get(attr, getter_AddRefs(node))) {
     // Break link to map
     node->SetMap(nullptr);
 
@@ -189,17 +189,17 @@
   }
 
   return node.forget();
 }
 
 Attr*
 nsDOMAttributeMap::GetAttribute(mozilla::dom::NodeInfo* aNodeInfo, bool aNsAware)
 {
-  NS_ASSERTION(aNodeInfo, "GetAttribute() called with aNodeInfo == nullptr!");
+  MOZ_ASSERT(aNodeInfo, "GetAttribute() called with aNodeInfo == nullptr!");
 
   nsAttrKey attr(aNodeInfo->NamespaceID(), aNodeInfo->NameAtom());
 
   EnsureAttributeCache();
   Attr* node = mAttributeCache->GetWeak(attr);
   if (!node) {
     nsRefPtr<mozilla::dom::NodeInfo> ni = aNodeInfo;
     nsRefPtr<Attr> newAttr =
@@ -307,17 +307,17 @@
   nsresult rv;
   if (mContent->OwnerDoc() != aAttr.OwnerDoc()) {
     nsCOMPtr<nsINode> adoptedNode =
       mContent->OwnerDoc()->AdoptNode(aAttr, aError);
     if (aError.Failed()) {
       return nullptr;
     }
 
-    NS_ASSERTION(adoptedNode == &aAttr, "Uh, adopt node changed nodes?");
+    MOZ_ASSERT(adoptedNode == &aAttr, "Uh, adopt node changed nodes?");
   }
 
   // Get nodeinfo and preexisting attribute (if it exists)
   nsRefPtr<NodeInfo> oldNi;
 
   if (!aWithNS) {
     nsAutoString name;
     aAttr.GetName(name);
@@ -346,17 +346,18 @@
     nsRefPtr<Attr> oldAttr = GetAttribute(oldNi, true);
 
     if (oldAttr == &aAttr) {
       return oldAttr.forget();
     }
 
     if (oldAttr) {
       attr = RemoveNamedItem(oldNi, aError);
-      NS_ASSERTION(attr->NodeInfo()->NameAndNamespaceEquals(oldNi),
+      MOZ_ASSERT(
+        attr->NodeInfo()->NameAndNamespaceEquals(oldNi),
         "RemoveNamedItem() called, attr->NodeInfo() should be equal to oldNi!");
     }
   }
 
   nsAutoString value;
   aAttr.GetValue(value);
 
   nsRefPtr<NodeInfo> ni = aAttr.NodeInfo();
diff --git a/dom/base/nsDOMCaretPosition.cpp b/dom/base/nsDOMCaretPosition.cpp
--- a/dom/base/nsDOMCaretPosition.cpp
+++ b/dom/base/nsDOMCaretPosition.cpp
@@ -43,17 +43,17 @@
 
   nsresult creationRv = nsRange::CreateRange(node, mOffset, node,
                                              mOffset,
                                              getter_AddRefs<nsRange>(domRange));
   if (!NS_SUCCEEDED(creationRv)) {
     return nullptr;
   }
 
-  NS_ASSERTION(domRange, "unable to retrieve valid dom range from CaretPosition");
+  MOZ_ASSERT(domRange, "unable to retrieve valid dom range from CaretPosition");
 
   rect = domRange->GetBoundingClientRect(false);
 
   return rect.forget();
 }
 
 JSObject*
 nsDOMCaretPosition::WrapObject(JSContext *aCx)
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -302,18 +302,17 @@
 static const JSClass *sObjectClass = nullptr;
 
 /**
  * Set our JSClass pointer for the Object class
  */
 static void
 FindObjectClass(JSContext* cx, JSObject* aGlobalObject)
 {
-  NS_ASSERTION(!sObjectClass,
-               "Double set of sObjectClass");
+  MOZ_ASSERT(!sObjectClass, "Double set of sObjectClass");
   JS::Rooted<JSObject*> obj(cx), proto(cx, aGlobalObject);
   do {
     obj = proto;
     js::GetObjectProto(cx, obj, &proto);
   } while (proto);
 
   sObjectClass = js::GetObjectJSClass(obj);
 }
@@ -1097,19 +1096,19 @@
 }
 
 static nsresult
 GetExternalClassInfo(nsScriptNameSpaceManager *aNameSpaceManager,
                      const nsAString &aName,
                      const nsGlobalNameStruct *aStruct,
                      const nsGlobalNameStruct **aResult)
 {
-  NS_ASSERTION(aStruct->mType ==
-                 nsGlobalNameStruct::eTypeExternalClassInfoCreator,
-               "Wrong type!");
+  MOZ_ASSERT(aStruct->mType ==
+               nsGlobalNameStruct::eTypeExternalClassInfoCreator,
+             "Wrong type!");
 
   nsresult rv;
   nsCOMPtr<nsIDOMCIExtension> creator(do_CreateInstance(aStruct->mCID, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDOMScriptObjectFactory> sof(do_GetService(kDOMSOF_CID));
   NS_ENSURE_TRUE(sof, NS_ERROR_FAILURE);
 
@@ -1145,43 +1144,43 @@
 {
   JS::Rooted<JSObject*> proto(cx, aProto);
 
   // This is called before any other location that requires
   // sObjectClass, so compute it here. We assume that nobody has had a
   // chance to monkey around with proto's prototype chain before this.
   if (!sObjectClass) {
     FindObjectClass(cx, proto);
-    NS_ASSERTION(sObjectClass && !strcmp(sObjectClass->name, "Object"),
-                 "Incorrect object class!");
+    MOZ_ASSERT(sObjectClass && !strcmp(sObjectClass->name, "Object"),
+               "Incorrect object class!");
   }
 
 #ifdef DEBUG
     JS::Rooted<JSObject*> proto2(cx);
     JS_GetPrototype(cx, proto, &proto2);
-    NS_ASSERTION(proto2 && JS_GetClass(proto2) == sObjectClass,
-                 "Hmm, somebody did something evil?");
+    MOZ_ASSERT(proto2 && JS_GetClass(proto2) == sObjectClass,
+               "Hmm, somebody did something evil?");
 #endif
 
 #ifdef DEBUG
   if (mData->mHasClassInterface && mData->mProtoChainInterface &&
       mData->mProtoChainInterface != &NS_GET_IID(nsISupports)) {
     nsCOMPtr<nsIInterfaceInfoManager>
       iim(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID));
 
     if (iim) {
       nsCOMPtr<nsIInterfaceInfo> if_info;
       iim->GetInfoForIID(mData->mProtoChainInterface,
                          getter_AddRefs(if_info));
 
       if (if_info) {
         nsXPIDLCString name;
         if_info->GetName(getter_Copies(name));
-        NS_ASSERTION(nsCRT::strcmp(CutPrefix(name), mData->mName) == 0,
-                     "Class name and proto chain interface name mismatch!");
+        MOZ_ASSERT(nsCRT::strcmp(CutPrefix(name), mData->mName) == 0,
+                   "Class name and proto chain interface name mismatch!");
       }
     }
   }
 #endif
 
   // Make prototype delegation work correctly. Consider if a site sets
   // HTMLElement.prototype.foopy = function () { ... } Now, calling
   // document.body.foopy() needs to ensure that looking up foopy on
@@ -1269,29 +1268,28 @@
     nsDOMClassInfoData& data = sClassInfoData[aID];
 
     data.mCachedClassInfo = data.u.mConstructorFptr(&data);
     NS_ENSURE_TRUE(data.mCachedClassInfo, nullptr);
 
     NS_ADDREF(data.mCachedClassInfo);
   }
 
-  NS_ASSERTION(!IS_EXTERNAL(sClassInfoData[aID].mCachedClassInfo),
-               "This is bad, internal class marked as external!");
+  MOZ_ASSERT(!IS_EXTERNAL(sClassInfoData[aID].mCachedClassInfo),
+             "This is bad, internal class marked as external!");
 
   return sClassInfoData[aID].mCachedClassInfo;
 }
 
 // static
 nsIClassInfo *
 nsDOMClassInfo::GetClassInfoInstance(nsDOMClassInfoData* aData)
 {
-  NS_ASSERTION(IS_EXTERNAL(aData->mCachedClassInfo)
-               || !aData->mCachedClassInfo,
-               "This is bad, external class marked as internal!");
+  MOZ_ASSERT(IS_EXTERNAL(aData->mCachedClassInfo) || !aData->mCachedClassInfo,
+             "This is bad, external class marked as internal!");
 
   if (!aData->mCachedClassInfo) {
     if (aData->u.mExternalConstructorFptr) {
       aData->mCachedClassInfo =
         aData->u.mExternalConstructorFptr(aData->mName);
     } else {
       aData->mCachedClassInfo = nsDOMGenericSH::doCreate(aData);
     }
@@ -1442,17 +1440,17 @@
     }
 
     const nsGlobalNameStruct *nameStruct;
 #ifdef DEBUG
     nsresult rv =
 #endif
       GetNameStruct(nsDependentString(mClassName), &nameStruct);
 
-    NS_ASSERTION(NS_FAILED(rv) || nameStruct, "Name isn't in hash.");
+    MOZ_ASSERT(NS_FAILED(rv) || nameStruct, "Name isn't in hash.");
 
     return nameStruct;
   }
 
   static nsresult GetNameStruct(const nsAString& aName,
                                 const nsGlobalNameStruct **aNameStruct)
   {
     *aNameStruct = nullptr;
@@ -1533,19 +1531,18 @@
 NS_IMPL_RELEASE(nsDOMConstructor)
 NS_INTERFACE_MAP_BEGIN(nsDOMConstructor)
   NS_INTERFACE_MAP_ENTRY(nsIDOMDOMConstructor)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   if (aIID.Equals(NS_GET_IID(nsIClassInfo))) {
 #ifdef DEBUG
     {
       const nsGlobalNameStruct *name_struct = GetNameStruct();
-      NS_ASSERTION(!name_struct ||
-                   mConstructable == IsConstructable(name_struct),
-                   "Can't change constructability dynamically!");
+      MOZ_ASSERT(!name_struct || mConstructable == IsConstructable(name_struct),
+                 "Can't change constructability dynamically!");
     }
 #endif
     foundInterface =
       NS_GetDOMClassInfoInstance(mConstructable ?
                                  eDOMClassInfo_DOMConstructor_id :
                                  eDOMClassInfo_DOMPrototype_id);
     if (!foundInterface) {
       *aInstancePtr = nullptr;
@@ -1593,17 +1590,17 @@
 {
   // No need to look these up in the hash.
   *bp = false;
   if (v.isPrimitive()) {
     return NS_OK;
   }
 
   JS::Rooted<JSObject*> dom_obj(cx, v.toObjectOrNull());
-  NS_ASSERTION(dom_obj, "nsDOMConstructor::HasInstance couldn't get object");
+  MOZ_ASSERT(dom_obj, "nsDOMConstructor::HasInstance couldn't get object");
 
   // This might not be the right object, if there are wrappers. Unwrap if we can.
   JSObject *wrapped_obj = js::CheckedUnwrap(dom_obj, /* stopAtOuter = */ false);
   if (wrapped_obj)
       dom_obj = wrapped_obj;
 
   const JSClass *dom_class = JS_GetClass(dom_obj);
   if (!dom_class) {
@@ -1660,17 +1657,17 @@
 
   if (name_struct == class_name_struct) {
     *bp = true;
 
     return NS_OK;
   }
 
   nsScriptNameSpaceManager *nameSpaceManager = GetNameSpaceManager();
-  NS_ASSERTION(nameSpaceManager, "Can't get namespace manager?");
+  MOZ_ASSERT(nameSpaceManager, "Can't get namespace manager?");
 
   const nsIID *class_iid;
   if (class_name_struct->mType == nsGlobalNameStruct::eTypeInterface ||
       class_name_struct->mType == nsGlobalNameStruct::eTypeClassProto) {
     class_iid = &class_name_struct->mIID;
   } else if (class_name_struct->mType == nsGlobalNameStruct::eTypeClassConstructor) {
     class_iid =
       sClassInfoData[class_name_struct->mDOMClassInfoID].mProtoChainInterface;
@@ -1702,19 +1699,19 @@
   if (name_struct->mType == nsGlobalNameStruct::eTypeExternalConstructorAlias) {
     name_struct = nameSpaceManager->GetConstructorProto(name_struct);
     if (!name_struct) {
       NS_ERROR("Couldn't get constructor prototype.");
       return NS_ERROR_UNEXPECTED;
     }
   }
 
-  NS_ASSERTION(name_struct->mType == nsGlobalNameStruct::eTypeClassConstructor ||
+  MOZ_ASSERT(name_struct->mType == nsGlobalNameStruct::eTypeClassConstructor ||
                name_struct->mType == nsGlobalNameStruct::eTypeExternalClassInfo,
-               "The constructor was set up with a struct of the wrong type.");
+             "The constructor was set up with a struct of the wrong type.");
 
   const nsDOMClassInfoData *ci_data = nullptr;
   if (name_struct->mType == nsGlobalNameStruct::eTypeClassConstructor &&
       name_struct->mDOMClassInfoID >= 0) {
     ci_data = &sClassInfoData[name_struct->mDOMClassInfoID];
   } else if (name_struct->mType == nsGlobalNameStruct::eTypeExternalClassInfo) {
     ci_data = name_struct->mData;
   }
@@ -1789,20 +1786,19 @@
 }
 
 
 static nsresult
 GetXPCProto(nsIXPConnect *aXPConnect, JSContext *cx, nsGlobalWindow *aWin,
             const nsGlobalNameStruct *aNameStruct,
             nsIXPConnectJSObjectHolder **aProto)
 {
-  NS_ASSERTION(aNameStruct->mType ==
-                 nsGlobalNameStruct::eTypeClassConstructor ||
+  MOZ_ASSERT(aNameStruct->mType == nsGlobalNameStruct::eTypeClassConstructor ||
                aNameStruct->mType == nsGlobalNameStruct::eTypeExternalClassInfo,
-               "Wrong type!");
+             "Wrong type!");
 
   nsCOMPtr<nsIClassInfo> ci;
   if (aNameStruct->mType == nsGlobalNameStruct::eTypeClassConstructor) {
     int32_t id = aNameStruct->mDOMClassInfoID;
     NS_ABORT_IF_FALSE(id >= 0, "Negative DOM classinfo?!?");
 
     nsDOMClassInfoID ci_id = (nsDOMClassInfoID)id;
 
@@ -1834,20 +1830,19 @@
                  JS::Handle<JSObject*> obj, const char16_t *name,
                  const nsDOMClassInfoData *ci_data,
                  const nsGlobalNameStruct *name_struct,
                  nsScriptNameSpaceManager *nameSpaceManager,
                  JSObject* aDot_prototype,
                  JS::MutableHandle<JSPropertyDescriptor> ctorDesc)
 {
   JS::Rooted<JSObject*> dot_prototype(cx, aDot_prototype);
-  NS_ASSERTION(ci_data ||
-               (name_struct &&
-                name_struct->mType == nsGlobalNameStruct::eTypeClassProto),
-               "Wrong type or missing ci_data!");
+  MOZ_ASSERT(ci_data || (name_struct && name_struct->mType ==
+                                          nsGlobalNameStruct::eTypeClassProto),
+             "Wrong type or missing ci_data!");
 
   nsRefPtr<nsDOMConstructor> constructor;
   nsresult rv = nsDOMConstructor::Create(name, ci_data, name_struct, aWin,
                                          getter_AddRefs(constructor));
   NS_ENSURE_SUCCESS(rv, rv);
 
   JS::Rooted<JS::Value> v(cx);
 
@@ -1912,17 +1907,17 @@
 
           if_info->GetNameShared(&class_parent_name);
         } else {
           // If the class does have a class interface (or there's no
           // real class for this name) then the parent of the
           // primary interface is what we want on
           // constructor.prototype.__proto__.
 
-          NS_ASSERTION(parent, "Whoa, this is bad, null parent here!");
+          MOZ_ASSERT(parent, "Whoa, this is bad, null parent here!");
 
           parent->GetNameShared(&class_parent_name);
         }
       }
     }
   }
 
   {
@@ -2331,17 +2326,17 @@
     NS_ENSURE_SUCCESS(rv, rv);
 
     JS::Rooted<JS::Value> val(cx);
     js::AssertSameCompartment(cx, obj);
     rv = WrapNative(cx, constructor, &NS_GET_IID(nsIDOMDOMConstructor),
                     true, &val);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    NS_ASSERTION(val.isObject(), "Why didn't we get a JSObject?");
+    MOZ_ASSERT(val.isObject(), "Why didn't we get a JSObject?");
 
     FillPropertyDescriptor(desc, obj, 0, val);
 
     return NS_OK;
   }
 
   if (name_struct->mType == nsGlobalNameStruct::eTypeProperty) {
     if (!OldBindingConstructorEnabled(name_struct, aWin, cx))
@@ -2539,17 +2534,17 @@
 {
   JS::Rooted<JSObject*> globalObj(cx, aGlobalObj);
   nsDOMConstructor *wrapped = static_cast<nsDOMConstructor *>(nativeObj);
 
 #ifdef DEBUG
   {
     nsCOMPtr<nsIDOMDOMConstructor> is_constructor =
       do_QueryInterface(nativeObj);
-    NS_ASSERTION(is_constructor, "How did we not get a constructor?");
+    MOZ_ASSERT(is_constructor, "How did we not get a constructor?");
   }
 #endif
 
   return wrapped->PreCreate(cx, globalObj, parentObj);
 }
 
 NS_IMETHODIMP
 nsDOMConstructorSH::Resolve(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
@@ -2597,17 +2592,17 @@
 
   nsDOMConstructor *wrapped =
     static_cast<nsDOMConstructor *>(wrapper->Native());
 
 #ifdef DEBUG
   {
     nsCOMPtr<nsIDOMDOMConstructor> is_constructor =
       do_QueryWrappedNative(wrapper);
-    NS_ASSERTION(is_constructor, "How did we not get a constructor?");
+    MOZ_ASSERT(is_constructor, "How did we not get a constructor?");
   }
 #endif
 
   return wrapped->Construct(wrapper, cx, obj, args, _retval);
 }
 
 NS_IMETHODIMP
 nsDOMConstructorSH::Construct(nsIXPConnectWrappedNative *wrapper, JSContext *cx,
@@ -2618,17 +2613,17 @@
 
   nsDOMConstructor *wrapped =
     static_cast<nsDOMConstructor *>(wrapper->Native());
 
 #ifdef DEBUG
   {
     nsCOMPtr<nsIDOMDOMConstructor> is_constructor =
       do_QueryWrappedNative(wrapper);
-    NS_ASSERTION(is_constructor, "How did we not get a constructor?");
+    MOZ_ASSERT(is_constructor, "How did we not get a constructor?");
   }
 #endif
 
   return wrapped->Construct(wrapper, cx, obj, args, _retval);
 }
 
 NS_IMETHODIMP
 nsDOMConstructorSH::HasInstance(nsIXPConnectWrappedNative *wrapper,
@@ -2638,17 +2633,17 @@
   JS::Rooted<JSObject*> obj(cx, aObj);
   nsDOMConstructor *wrapped =
     static_cast<nsDOMConstructor *>(wrapper->Native());
 
 #ifdef DEBUG
   {
     nsCOMPtr<nsIDOMDOMConstructor> is_constructor =
       do_QueryWrappedNative(wrapper);
-    NS_ASSERTION(is_constructor, "How did we not get a constructor?");
+    MOZ_ASSERT(is_constructor, "How did we not get a constructor?");
   }
 #endif
 
   return wrapped->HasInstance(wrapper, cx, obj, val, bp, _retval);
 }
 
 NS_IMETHODIMP
 nsNonDOMObjectSH::GetFlags(uint32_t *aFlags)
diff --git a/dom/base/nsDOMFileReader.cpp b/dom/base/nsDOMFileReader.cpp
--- a/dom/base/nsDOMFileReader.cpp
+++ b/dom/base/nsDOMFileReader.cpp
@@ -338,43 +338,42 @@
 nsresult
 nsDOMFileReader::DoReadData(nsIAsyncInputStream* aStream, uint64_t aCount)
 {
   MOZ_ASSERT(aStream);
 
   if (mDataFormat == FILE_AS_BINARY) {
     //Continuously update our binary string as data comes in
     uint32_t oldLen = mResult.Length();
-    NS_ASSERTION(mResult.Length() == mDataLen,
-                 "unexpected mResult length");
+    MOZ_ASSERT(mResult.Length() == mDataLen, "unexpected mResult length");
     if (uint64_t(oldLen) + aCount > UINT32_MAX)
       return NS_ERROR_OUT_OF_MEMORY;
     char16_t *buf = nullptr;
     mResult.GetMutableData(&buf, oldLen + aCount, fallible_t());
     NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
 
     uint32_t bytesRead = 0;
     aStream->ReadSegments(ReadFuncBinaryString, buf + oldLen, aCount,
                           &bytesRead);
-    NS_ASSERTION(bytesRead == aCount, "failed to read data");
+    MOZ_ASSERT(bytesRead == aCount, "failed to read data");
   }
   else {
     //Update memory buffer to reflect the contents of the file
     if (mDataLen + aCount > UINT32_MAX) {
       // PR_Realloc doesn't support over 4GB memory size even if 64-bit OS
       return NS_ERROR_OUT_OF_MEMORY;
     }
     if (mDataFormat != FILE_AS_ARRAYBUFFER) {
       mFileData = (char *) moz_realloc(mFileData, mDataLen + aCount);
       NS_ENSURE_TRUE(mFileData, NS_ERROR_OUT_OF_MEMORY);
     }
 
     uint32_t bytesRead = 0;
     aStream->Read(mFileData + mDataLen, aCount, &bytesRead);
-    NS_ASSERTION(bytesRead == aCount, "failed to read data");
+    MOZ_ASSERT(bytesRead == aCount, "failed to read data");
   }
 
   mDataLen += aCount;
   return NS_OK;
 }
 
 // Helper methods
 
diff --git a/dom/base/nsDOMMutationObserver.cpp b/dom/base/nsDOMMutationObserver.cpp
--- a/dom/base/nsDOMMutationObserver.cpp
+++ b/dom/base/nsDOMMutationObserver.cpp
@@ -110,20 +110,18 @@
       !ObservesAttr(aElement, aNameSpaceID, aAttribute) ||
       aElement->ChromeOnlyAccess()) {
     return;
   }
 
   nsDOMMutationRecord* m =
     Observer()->CurrentRecord(nsGkAtoms::attributes);
 
-  NS_ASSERTION(!m->mTarget || m->mTarget == aElement,
-               "Wrong target!");
-  NS_ASSERTION(!m->mAttrName || m->mAttrName == aAttribute,
-               "Wrong attribute!");
+  MOZ_ASSERT(!m->mTarget || m->mTarget == aElement, "Wrong target!");
+  MOZ_ASSERT(!m->mAttrName || m->mAttrName == aAttribute, "Wrong attribute!");
   if (!m->mTarget) {
     m->mTarget = aElement;
     m->mAttrName = aAttribute;
     if (aNameSpaceID == kNameSpaceID_None) {
       m->mAttrNamespace.SetIsVoid(true);
     } else {
       nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID,
                                                           m->mAttrNamespace);
@@ -145,19 +143,18 @@
   if (nsAutoMutationBatch::IsBatching() ||
       !CharacterData() || !(Subtree() || aContent == Target()) ||
       aContent->ChromeOnlyAccess()) {
     return;
   }
   
   nsDOMMutationRecord* m =
     Observer()->CurrentRecord(nsGkAtoms::characterData);
- 
-  NS_ASSERTION(!m->mTarget || m->mTarget == aContent,
-               "Wrong target!");
+
+  MOZ_ASSERT(!m->mTarget || m->mTarget == aContent, "Wrong target!");
 
   if (!m->mTarget) {
     m->mTarget = aContent;
   }
   if (CharacterDataOldValue() && m->mPrevValue.IsVoid()) { 
     aContent->GetText()->AppendTo(m->mPrevValue);
   }
 }
@@ -178,18 +175,17 @@
     if (parent == nsAutoMutationBatch::GetBatchTarget()) {
       nsAutoMutationBatch::UpdateObserver(Observer(), wantsChildList);
     }
     return;
   }
 
   nsDOMMutationRecord* m =
     Observer()->CurrentRecord(nsGkAtoms::childList);
-  NS_ASSERTION(!m->mTarget || m->mTarget == parent,
-               "Wrong target!");
+  MOZ_ASSERT(!m->mTarget || m->mTarget == parent, "Wrong target!");
   if (m->mTarget) {
     // Already handled case.
     return;
   }
   m->mTarget = parent;
   m->mAddedNodes = new nsSimpleContentList(parent);
 
   nsINode* n = aFirstNewContent;
@@ -305,17 +301,17 @@
   }
   // We need to schedule always, so that after microtask mTransientReceivers
   // can be cleared correctly.
   Observer()->ScheduleForRun();
 }
 
 void nsMutationReceiver::NodeWillBeDestroyed(const nsINode *aNode)
 {
-  NS_ASSERTION(!mParent, "Shouldn't have mParent here!");
+  MOZ_ASSERT(!mParent, "Shouldn't have mParent here!");
   Disconnect(true);
 }
 
 // Observer
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMMutationObserver)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
@@ -610,19 +606,18 @@
   nsRefPtr<nsDOMMutationObserver> observer =
     new nsDOMMutationObserver(window.forget(), aCb);
   return observer.forget();
 }
 
 void
 nsDOMMutationObserver::HandleMutation()
 {
-  NS_ASSERTION(nsContentUtils::IsSafeToRunScript(), "Whaat!");
-  NS_ASSERTION(mCurrentMutations.IsEmpty(),
-               "Still generating MutationRecords?");
+  MOZ_ASSERT(nsContentUtils::IsSafeToRunScript(), "Whaat!");
+  MOZ_ASSERT(mCurrentMutations.IsEmpty(), "Still generating MutationRecords?");
 
   mWaitingForRun = false;
 
   for (int32_t i = 0; i < mReceivers.Count(); ++i) {
     mReceivers[i]->RemoveClones();
   }
   mTransientReceivers.Clear();
 
@@ -712,32 +707,32 @@
     suppressedObservers = nullptr;
   }
   sCurrentObserver = nullptr;
 }
 
 nsDOMMutationRecord*
 nsDOMMutationObserver::CurrentRecord(nsIAtom* aType)
 {
-  NS_ASSERTION(sMutationLevel > 0, "Unexpected mutation level!");
+  MOZ_ASSERT(sMutationLevel > 0, "Unexpected mutation level!");
 
   while (mCurrentMutations.Length() < sMutationLevel) {
     mCurrentMutations.AppendElement(static_cast<nsDOMMutationRecord*>(nullptr));
   }
 
   uint32_t last = sMutationLevel - 1;
   if (!mCurrentMutations[last]) {
     nsRefPtr<nsDOMMutationRecord> r = new nsDOMMutationRecord(aType, GetParentObject());
     mCurrentMutations[last] = r;
     AppendMutationRecord(r.forget());
     ScheduleForRun();
   }
 
-  NS_ASSERTION(mCurrentMutations[last]->mType == aType,
-               "Unexpected MutationRecord type!");
+  MOZ_ASSERT(mCurrentMutations[last]->mType == aType,
+             "Unexpected MutationRecord type!");
 
   return mCurrentMutations[last];
 }
 
 nsDOMMutationObserver::~nsDOMMutationObserver()
 {
   for (int32_t i = 0; i < mReceivers.Count(); ++i) {
     mReceivers[i]->RemoveClones();
@@ -772,17 +767,17 @@
     sCurrentlyHandlingObservers->RemoveElementAt(sMutationLevel - 1);
   }
   --sMutationLevel;
 }
 
 void
 nsDOMMutationObserver::AddCurrentlyHandlingObserver(nsDOMMutationObserver* aObserver)
 {
-  NS_ASSERTION(sMutationLevel > 0, "Unexpected mutation level!");
+  MOZ_ASSERT(sMutationLevel > 0, "Unexpected mutation level!");
 
   if (!sCurrentlyHandlingObservers) {
     sCurrentlyHandlingObservers =
       new nsAutoTArray<nsAutoTArray<nsRefPtr<nsDOMMutationObserver>, 4>, 4>;
   }
 
   while (sCurrentlyHandlingObservers->Length() < sMutationLevel) {
     sCurrentlyHandlingObservers->InsertElementAt(
diff --git a/dom/base/nsDOMMutationObserver.h b/dom/base/nsDOMMutationObserver.h
--- a/dom/base/nsDOMMutationObserver.h
+++ b/dom/base/nsDOMMutationObserver.h
@@ -114,79 +114,79 @@
 
   nsDOMMutationObserver* Observer();
   nsINode* Target() { return mParent ? mParent->Target() : mTarget; }
   nsINode* RegisterTarget() { return mRegisterTarget; }
 
   bool Subtree() { return mParent ? mParent->Subtree() : mSubtree; }
   void SetSubtree(bool aSubtree)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mSubtree = aSubtree;
   }
 
   bool ChildList() { return mParent ? mParent->ChildList() : mChildList; }
   void SetChildList(bool aChildList)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mChildList = aChildList;
   }
 
   bool CharacterData()
   {
     return mParent ? mParent->CharacterData() : mCharacterData;
   }
   void SetCharacterData(bool aCharacterData)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mCharacterData = aCharacterData;
   }
 
   bool CharacterDataOldValue()
   {
     return mParent ? mParent->CharacterDataOldValue() : mCharacterDataOldValue;
   }
   void SetCharacterDataOldValue(bool aOldValue)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mCharacterDataOldValue = aOldValue;
   }
 
   bool Attributes() { return mParent ? mParent->Attributes() : mAttributes; }
   void SetAttributes(bool aAttributes)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mAttributes = aAttributes;
   }
 
   bool AllAttributes()
   {
     return mParent ? mParent->AllAttributes()
                    : mAllAttributes;
   }
   void SetAllAttributes(bool aAll)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mAllAttributes = aAll;
   }
 
   bool AttributeOldValue() {
     return mParent ? mParent->AttributeOldValue()
                    : mAttributeOldValue;
   }
   void SetAttributeOldValue(bool aOldValue)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mAttributeOldValue = aOldValue;
   }
 
   nsCOMArray<nsIAtom>& AttributeFilter() { return mAttributeFilter; }
   void SetAttributeFilter(nsCOMArray<nsIAtom>& aFilter)
   {
-    NS_ASSERTION(!mParent, "Shouldn't have parent");
+    MOZ_ASSERT(!mParent, "Shouldn't have parent");
     mAttributeFilter.Clear();
     mAttributeFilter.AppendObjects(aFilter);
   }
 
   void AddClone(nsMutationReceiverBase* aClone)
   {
     mTransientReceivers.AppendObject(aClone);
   }
@@ -205,17 +205,17 @@
     mRegisterTarget->OwnerDoc()->SetMayHaveDOMMutationObservers();
   }
 
   nsMutationReceiverBase(nsINode* aRegisterTarget,
                          nsMutationReceiverBase* aParent)
   : mTarget(nullptr), mObserver(nullptr), mParent(aParent),
     mRegisterTarget(aRegisterTarget), mKungFuDeathGrip(aParent->Target())
   {
-    NS_ASSERTION(mParent->Subtree(), "Should clone a non-subtree observer!");
+    MOZ_ASSERT(mParent->Subtree(), "Should clone a non-subtree observer!");
     mRegisterTarget->AddMutationObserver(this);
     mRegisterTarget->SetMayHaveDOMMutationObserver();
     mRegisterTarget->OwnerDoc()->SetMayHaveDOMMutationObservers();
   }
 
   bool ObservesAttr(mozilla::dom::Element* aElement,
                     int32_t aNameSpaceID,
                     nsIAtom* aAttr)
@@ -273,18 +273,18 @@
   virtual ~nsMutationReceiver() { Disconnect(false); }
 
 public:
   nsMutationReceiver(nsINode* aTarget, nsDOMMutationObserver* aObserver);
 
   nsMutationReceiver(nsINode* aRegisterTarget, nsMutationReceiverBase* aParent)
   : nsMutationReceiverBase(aRegisterTarget, aParent)
   {
-    NS_ASSERTION(!static_cast<nsMutationReceiver*>(aParent)->GetParent(),
-                 "Shouldn't create deep observer hierarchies!");
+    MOZ_ASSERT(!static_cast<nsMutationReceiver*>(aParent)->GetParent(),
+               "Shouldn't create deep observer hierarchies!");
     aParent->AddClone(this);
   }
 
   nsMutationReceiver* GetParent()
   {
     return static_cast<nsMutationReceiver*>(mParent.get());
   }
 
@@ -301,18 +301,18 @@
   void DisconnectTransientReceiver()
   {
     if (mRegisterTarget) {
       mRegisterTarget->RemoveMutationObserver(this);
       mRegisterTarget = nullptr;
     }
 
     mParent = nullptr;
-    NS_ASSERTION(!mTarget, "Should not have mTarget");
-    NS_ASSERTION(!mObserver, "Should not have mObserver");
+    MOZ_ASSERT(!mTarget, "Should not have mTarget");
+    MOZ_ASSERT(!mObserver, "Should not have mObserver");
   }
 
   void Disconnect(bool aRemoveFromObserver);
 
   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
diff --git a/dom/base/nsDOMScriptObjectFactory.cpp b/dom/base/nsDOMScriptObjectFactory.cpp
--- a/dom/base/nsDOMScriptObjectFactory.cpp
+++ b/dom/base/nsDOMScriptObjectFactory.cpp
@@ -72,18 +72,19 @@
       NS_ENSURE_SUCCESS(rv, nullptr);
 
       rv = creator->RegisterDOMCI(NS_ConvertUTF16toUTF8(aName).get(), this);
       NS_ENSURE_SUCCESS(rv, nullptr);
 
       globalStruct = nameSpaceManager->LookupName(aName);
       NS_ENSURE_TRUE(globalStruct, nullptr);
 
-      NS_ASSERTION(globalStruct->mType == nsGlobalNameStruct::eTypeExternalClassInfo,
-                   "The classinfo data for this class didn't get registered.");
+      MOZ_ASSERT(globalStruct->mType ==
+                   nsGlobalNameStruct::eTypeExternalClassInfo,
+                 "The classinfo data for this class didn't get registered.");
     }
     if (globalStruct->mType == nsGlobalNameStruct::eTypeExternalClassInfo) {
       return nsDOMClassInfo::GetClassInfoInstance(globalStruct->mData);
     }
   }
   return nullptr;
 }
 
diff --git a/dom/base/nsDOMSerializer.cpp b/dom/base/nsDOMSerializer.cpp
--- a/dom/base/nsDOMSerializer.cpp
+++ b/dom/base/nsDOMSerializer.cpp
@@ -64,17 +64,17 @@
                      nsIDocumentEncoder::OutputDontRewriteEncodingDeclaration);
 
   if (NS_FAILED(rv))
     return rv;
 
   nsAutoCString charset(aCharset);
   if (charset.IsEmpty()) {
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
-    NS_ASSERTION(doc, "Need a document");
+    MOZ_ASSERT(doc, "Need a document");
     charset = doc->GetDocumentCharacterSet();
   }
   rv = encoder->SetCharset(charset);
   if (NS_FAILED(rv))
     return rv;
 
   // If we are working on the entire document we do not need to
   // specify which part to serialize
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -118,17 +118,17 @@
 
 NS_IMPL_ADDREF(nsDOMWindowUtils)
 NS_IMPL_RELEASE(nsDOMWindowUtils)
 
 nsDOMWindowUtils::nsDOMWindowUtils(nsGlobalWindow *aWindow)
 {
   nsCOMPtr<nsISupports> supports = do_QueryObject(aWindow);
   mWindow = do_GetWeakReference(supports);
-  NS_ASSERTION(aWindow->IsOuterWindow(), "How did that happen?");
+  MOZ_ASSERT(aWindow->IsOuterWindow(), "How did that happen?");
 }
 
 nsDOMWindowUtils::~nsDOMWindowUtils()
 {
 }
 
 nsIPresShell*
 nsDOMWindowUtils::GetPresShell()
@@ -2483,30 +2483,30 @@
 NS_IMETHODIMP
 nsDOMWindowUtils::GetOuterWindowID(uint64_t *aWindowID)
 {
   MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
 
   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
   NS_ENSURE_STATE(window);
 
-  NS_ASSERTION(window->IsOuterWindow(), "How did that happen?");
+  MOZ_ASSERT(window->IsOuterWindow(), "How did that happen?");
   *aWindowID = window->WindowID();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMWindowUtils::GetCurrentInnerWindowID(uint64_t *aWindowID)
 {
   MOZ_RELEASE_ASSERT(nsContentUtils::IsCallerChrome());
 
   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
   NS_ENSURE_TRUE(window, NS_ERROR_NOT_AVAILABLE);
 
-  NS_ASSERTION(window->IsOuterWindow(), "How did that happen?");
+  MOZ_ASSERT(window->IsOuterWindow(), "How did that happen?");
   nsGlobalWindow* inner =
     static_cast<nsGlobalWindow*>(window.get())->GetCurrentInnerWindowInternal();
   if (!inner) {
     return NS_ERROR_NOT_AVAILABLE;
   }
   *aWindowID = inner->WindowID();
   return NS_OK;
 }
@@ -3503,17 +3503,17 @@
   switch(aSheetType) {
     case nsDOMWindowUtils::AGENT_SHEET:
       return nsIDocument::eAgentSheet;
     case nsDOMWindowUtils::USER_SHEET:
       return nsIDocument::eUserSheet;
     case nsDOMWindowUtils::AUTHOR_SHEET:
       return nsIDocument::eAuthorSheet;
     default:
-      NS_ASSERTION(false, "wrong type");
+      MOZ_ASSERT(false, "wrong type");
       // we must return something although this should never happen
       return nsIDocument::SheetTypeCount;
   }
 }
 
 NS_IMETHODIMP
 nsDOMWindowUtils::LoadSheet(nsIURI *aSheetURI, uint32_t aSheetType)
 {
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -595,17 +595,17 @@
   Element* currentElement =
     static_cast<Element*>(mIdContentList.SafeElementAt(0));
 #endif
 
   // Common case
   if (mIdContentList.Count() == 0) {
     if (!mIdContentList.AppendElement(aElement))
       return false;
-    NS_ASSERTION(currentElement == nullptr, "How did that happen?");
+    MOZ_ASSERT(currentElement == nullptr, "How did that happen?");
     FireChangeCallbacks(nullptr, aElement);
     return true;
   }
 
   // We seem to have multiple content nodes for the same id, or XUL is messing
   // with us.  Search for the right place to insert the content.
 
   size_t idx;
@@ -618,36 +618,36 @@
   }
 
   if (!mIdContentList.InsertElementAt(aElement, idx))
     return false;
 
   if (idx == 0) {
     Element* oldElement =
       static_cast<Element*>(mIdContentList.SafeElementAt(1));
-    NS_ASSERTION(currentElement == oldElement, "How did that happen?");
+    MOZ_ASSERT(currentElement == oldElement, "How did that happen?");
     FireChangeCallbacks(oldElement, aElement);
   }
   return true;
 }
 
 void
 nsIdentifierMapEntry::RemoveIdElement(Element* aElement)
 {
   NS_PRECONDITION(aElement, "Missing element");
 
   // This should only be called while the document is in an update.
   // Assertions near the call to this method guarantee this.
 
   // This could fire in OOM situations
   // Only assert this in HTML documents for now as XUL does all sorts of weird
   // crap.
-  NS_ASSERTION(!aElement->OwnerDoc()->IsHTML() ||
+  MOZ_ASSERT(!aElement->OwnerDoc()->IsHTML() ||
                mIdContentList.IndexOf(aElement) >= 0,
-               "Removing id entry that doesn't exist");
+             "Removing id entry that doesn't exist");
 
   // XXXbz should this ever Compact() I guess when all the content is gone
   // we'll just get cleaned up in the natural order of things...
   Element* currentElement =
     static_cast<Element*>(mIdContentList.SafeElementAt(0));
   mIdContentList.RemoveElement(aElement);
   if (currentElement == aElement) {
     FireChangeCallbacks(currentElement,
@@ -773,34 +773,34 @@
   if (-1 == mLength) {
     mLength = mDocument->GetNumberOfStyleSheets();
 
 #ifdef DEBUG
     int32_t i;
     for (i = 0; i < mLength; i++) {
       nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(i);
       nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(sheet));
-      NS_ASSERTION(domss, "All \"normal\" sheets implement nsIDOMStyleSheet");
+      MOZ_ASSERT(domss, "All \"normal\" sheets implement nsIDOMStyleSheet");
     }
 #endif
   }
   return mLength;
 }
 
 CSSStyleSheet*
 nsDOMStyleSheetList::IndexedGetter(uint32_t aIndex, bool& aFound)
 {
   if (!mDocument || aIndex >= (uint32_t)mDocument->GetNumberOfStyleSheets()) {
     aFound = false;
     return nullptr;
   }
 
   aFound = true;
   nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(aIndex);
-  NS_ASSERTION(sheet, "Must have a sheet");
+  MOZ_ASSERT(sheet, "Must have a sheet");
 
   return static_cast<CSSStyleSheet*>(sheet);
 }
 
 void
 nsDOMStyleSheetList::NodeWillBeDestroyed(const nsINode *aNode)
 {
   mDocument = nullptr;
@@ -1104,17 +1104,17 @@
   mPendingLoads.Get(aURI, getter_AddRefs(load));
   mPendingLoads.Remove(aURI);
 
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIDocument> doc;
   if (aViewer) {
     doc = aViewer->GetDocument();
-    NS_ASSERTION(doc, "Must have a document");
+    MOZ_ASSERT(doc, "Must have a document");
 
     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(doc);
     if (xulDoc) {
       // We don't handle XUL stuff here yet.
       rv = NS_ERROR_NOT_AVAILABLE;
     } else {
       doc->SetDisplayDocument(aDisplayDocument);
 
@@ -1442,17 +1442,17 @@
 protected:
   nsIDocument* mDocument;  // Our document; weak ref.  It'll let us know if it
                            // dies.
 };
 
 nsDOMStyleSheetSetList::nsDOMStyleSheetSetList(nsIDocument* aDocument)
   : mDocument(aDocument)
 {
-  NS_ASSERTION(mDocument, "Must have document!");
+  MOZ_ASSERT(mDocument, "Must have document!");
 }
 
 void
 nsDOMStyleSheetSetList::EnsureFresh()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   mNames.Clear();
@@ -1461,17 +1461,17 @@
     return; // Spec says "no exceptions", and we have no style sets if we have
             // no document, for sure
   }
 
   int32_t count = mDocument->GetNumberOfStyleSheets();
   nsAutoString title;
   for (int32_t index = 0; index < count; index++) {
     nsIStyleSheet* sheet = mDocument->GetStyleSheetAt(index);
-    NS_ASSERTION(sheet, "Null sheet in sheet list!");
+    MOZ_ASSERT(sheet, "Null sheet in sheet list!");
     sheet->GetTitle(title);
     if (!title.IsEmpty() && !mNames.Contains(title) && !Add(title)) {
       return;
     }
   }
 }
 
 // ==================================================================
@@ -1635,23 +1635,23 @@
 nsDocument::~nsDocument()
 {
 #ifdef PR_LOGGING
   if (gDocumentLeakPRLog)
     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
            ("DOCUMENT %p destroyed", this));
 #endif
 
-  NS_ASSERTION(!mIsShowing, "Destroying a currently-showing document");
+  MOZ_ASSERT(!mIsShowing, "Destroying a currently-showing document");
 
   // Note: This assert is only non-fatal because mochitest-bc triggers
   // it... as well as the preceding assert about !mIsShowing.
-  NS_ASSERTION(!mObservingAppThemeChanged,
-               "Document leaked to shutdown, then the observer service dropped "
-               "its ref to us so we were able to go away.");
+  MOZ_ASSERT(!mObservingAppThemeChanged,
+             "Document leaked to shutdown, then the observer service dropped "
+             "its ref to us so we were able to go away.");
 
   if (IsTopLevelContentDocument()) {
     //don't report for about: pages
     nsCOMPtr<nsIPrincipal> principal = GetPrincipal();
     nsCOMPtr<nsIURI> uri;
     principal->GetURI(getter_AddRefs(uri));
     bool isAboutScheme = true;
     if (uri) {
@@ -2207,17 +2207,17 @@
   NS_ENSURE_SUCCESS(rv, rv);
 
   // mNodeInfo keeps NodeInfoManager alive!
   mNodeInfo = mNodeInfoManager->GetDocumentNodeInfo();
   NS_ENSURE_TRUE(mNodeInfo, NS_ERROR_OUT_OF_MEMORY);
   NS_ABORT_IF_FALSE(mNodeInfo->NodeType() == nsIDOMNode::DOCUMENT_NODE,
                     "Bad NodeType in aNodeInfo");
 
-  NS_ASSERTION(OwnerDoc() == this, "Our nodeinfo is busted!");
+  MOZ_ASSERT(OwnerDoc() == this, "Our nodeinfo is busted!");
 
   // If after creation the owner js global is not set for a document
   // we use the default compartment for this document, instead of creating
   // wrapper in some random compartment when the document is exposed to js
   // via some events.
   nsCOMPtr<nsIGlobalObject> global = xpc::NativeGlobal(xpc::PrivilegedJunkScope());
   NS_ENSURE_TRUE(global, NS_ERROR_FAILURE);
   mScopeObject = do_GetWeakReference(global);
@@ -2244,17 +2244,17 @@
   for (uint32_t i = 0; i < GetPropertyTableCount(); ++i) {
     PropertyTable(i)->DeleteAllPropertiesFor(aNode);
   }
 }
 
 nsPropertyTable*
 nsIDocument::GetExtraPropertyTable(uint16_t aCategory)
 {
-  NS_ASSERTION(aCategory > 0, "Category 0 should have already been handled");
+  MOZ_ASSERT(aCategory > 0, "Category 0 should have already been handled");
   while (aCategory >= mExtraPropertyTables.Length() + 1) {
     mExtraPropertyTables.AppendElement(new nsPropertyTable());
   }
   return mExtraPropertyTables[aCategory - 1];
 }
 
 bool
 nsIDocument::IsVisibleConsideringAncestors() const
@@ -2960,17 +2960,17 @@
   if (applyAppManifestCSP) {
     csp->AppendPolicy(appManifestCSP, false);
   }
 
   // ----- if the doc is part of Loop, apply the loop CSP
   if (applyLoopCSP) {
     nsAdoptingString loopCSP;
     loopCSP = Preferences::GetString("loop.CSP");
-    NS_ASSERTION(loopCSP, "Missing loop.CSP preference");
+    MOZ_ASSERT(loopCSP, "Missing loop.CSP preference");
     // If the pref has been removed, we continue without setting a CSP
     if (loopCSP) {
       csp->AppendPolicy(loopCSP, false);
     }
   }
 
   // ----- if there's a full-strength CSP header, apply it.
   if (!cspHeaderValue.IsEmpty()) {
@@ -3162,17 +3162,17 @@
     }
     entry->AddIdElement(aElement);
   }
 }
 
 void
 nsDocument::RemoveFromIdTable(Element *aElement, nsIAtom* aId)
 {
-  NS_ASSERTION(aId, "huhwhatnow?");
+  MOZ_ASSERT(aId, "huhwhatnow?");
 
   // Speed up document teardown
   if (mIdentifierMap.Count() == 0) {
     return;
   }
 
   nsIdentifierMapEntry *entry =
     mIdentifierMap.GetEntry(nsDependentAtomString(aId));
@@ -3235,19 +3235,20 @@
   CopyUTF8toUTF16(GetContentTypeInternal(), aContentType);
 
   return NS_OK;
 }
 
 void
 nsDocument::SetContentType(const nsAString& aContentType)
 {
-  NS_ASSERTION(GetContentTypeInternal().IsEmpty() ||
-               GetContentTypeInternal().Equals(NS_ConvertUTF16toUTF8(aContentType)),
-               "Do you really want to change the content-type?");
+  MOZ_ASSERT(
+    GetContentTypeInternal().IsEmpty() ||
+      GetContentTypeInternal().Equals(NS_ConvertUTF16toUTF8(aContentType)),
+    "Do you really want to change the content-type?");
 
   SetContentTypeInternal(NS_ConvertUTF16toUTF8(aContentType));
 }
 
 nsresult
 nsDocument::GetAllowPlugins(bool * aAllowPlugins)
 {
   // First, we ask our docshell if it allows plugins.
@@ -3839,17 +3840,17 @@
                        eCompatibility_FullStandards);
 }
 
 already_AddRefed<nsIPresShell>
 nsDocument::doCreateShell(nsPresContext* aContext,
                           nsViewManager* aViewManager, nsStyleSet* aStyleSet,
                           nsCompatibility aCompatMode)
 {
-  NS_ASSERTION(!mPresShell, "We have a presshell already!");
+  MOZ_ASSERT(!mPresShell, "We have a presshell already!");
 
   NS_ENSURE_FALSE(GetBFCacheEntry(), nullptr);
 
   FillStyleSet(aStyleSet);
 
   nsRefPtr<PresShell> shell = new PresShell;
   shell->Init(this, aContext, aViewManager, aStyleSet, aCompatMode);
 
@@ -4280,17 +4281,17 @@
 
 void
 nsDocument::RemoveStyleSheet(nsIStyleSheet* aSheet)
 {
   NS_PRECONDITION(aSheet, "null arg");
   nsCOMPtr<nsIStyleSheet> sheet = aSheet; // hold ref so it won't die too soon
 
   if (!mStyleSheets.RemoveObject(aSheet)) {
-    NS_ASSERTION(mInUnlinkOrDeletion, "stylesheet not found");
+    MOZ_ASSERT(mInUnlinkOrDeletion, "stylesheet not found");
     return;
   }
 
   if (!mIsGoingAway) {
     if (aSheet->IsApplicable()) {
       RemoveStyleSheetFromStyleSets(aSheet);
     }
 
@@ -4312,17 +4313,17 @@
   int32_t count = aOldSheets.Count();
 
   nsCOMPtr<nsIStyleSheet> oldSheet;
   int32_t i;
   for (i = 0; i < count; ++i) {
     oldSheet = aOldSheets[i];
 
     // First remove the old sheet.
-    NS_ASSERTION(oldSheet, "None of the old sheets should be null");
+    MOZ_ASSERT(oldSheet, "None of the old sheets should be null");
     int32_t oldIndex = mStyleSheets.IndexOf(oldSheet);
     RemoveStyleSheet(oldSheet);  // This does the right notifications
 
     // Now put the new one in its place.  If it's null, just ignore it.
     nsIStyleSheet* newSheet = aNewSheets[i];
     if (newSheet) {
       mStyleSheets.InsertObjectAt(newSheet, oldIndex);
       newSheet->SetOwningDocument(this);
@@ -4409,17 +4410,17 @@
   switch(aType) {
     case nsIDocument::eAgentSheet:
       return nsStyleSet::eAgentSheet;
     case nsIDocument::eUserSheet:
       return nsStyleSet::eUserSheet;
     case nsIDocument::eAuthorSheet:
       return nsStyleSet::eDocSheet;
     default:
-      NS_ASSERTION(false, "wrong type");
+      MOZ_ASSERT(false, "wrong type");
       // we must return something although this should never happen
       return nsStyleSet::eSheetTypeCount;
   }
 }
 
 static int32_t
 FindSheet(const nsCOMArray<nsIStyleSheet>& aSheets, nsIURI* aSheetURI)
 {
@@ -4596,17 +4597,19 @@
     return;
   }
 
   // Get the Docshell
   if (aContainer->ItemType() == nsIDocShellTreeItem::typeContent) {
     // check if same type root
     nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
     aContainer->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
-    NS_ASSERTION(sameTypeRoot, "No document shell root tree item from document shell tree item!");
+    MOZ_ASSERT(
+      sameTypeRoot,
+      "No document shell root tree item from document shell tree item!");
 
     if (sameTypeRoot == aContainer) {
       static_cast<nsDocument*>(this)->SetIsTopLevelContentDocument(true);
     }
   }
 }
 
 nsISupports*
@@ -4617,18 +4620,18 @@
 
 void
 nsDocument::SetScriptGlobalObject(nsIScriptGlobalObject *aScriptGlobalObject)
 {
 #ifdef DEBUG
   {
     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobalObject));
 
-    NS_ASSERTION(!win || win->IsInnerWindow(),
-                 "Script global object must be an inner window!");
+    MOZ_ASSERT(!win || win->IsInnerWindow(),
+               "Script global object must be an inner window!");
   }
 #endif
   NS_ABORT_IF_FALSE(aScriptGlobalObject || !mAnimationController ||
                     mAnimationController->IsPausedByType(
                         nsSMILTimeContainer::PAUSE_PAGEHIDE |
                         nsSMILTimeContainer::PAUSE_BEGIN),
                     "Clearing window pointer while animations are unpaused");
 
@@ -4660,30 +4663,30 @@
     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
 #ifdef DEBUG
     if (!mWillReparent) {
       // We really shouldn't have a wrapper here but if we do we need to make sure
       // it has the correct parent.
       JSObject *obj = GetWrapperPreserveColor();
       if (obj) {
         JSObject *newScope = aScriptGlobalObject->GetGlobalJSObject();
-        NS_ASSERTION(js::GetGlobalForObjectCrossCompartment(obj) == newScope,
-                     "Wrong scope, this is really bad!");
+        MOZ_ASSERT(js::GetGlobalForObjectCrossCompartment(obj) == newScope,
+                   "Wrong scope, this is really bad!");
       }
     }
 #endif
 
     if (mAllowDNSPrefetch) {
       nsCOMPtr<nsIDocShell> docShell(mDocumentContainer);
       if (docShell) {
 #ifdef DEBUG
         nsCOMPtr<nsIWebNavigation> webNav =
           do_GetInterface(aScriptGlobalObject);
-        NS_ASSERTION(SameCOMIdentity(webNav, docShell),
-                     "Unexpected container or script global?");
+        MOZ_ASSERT(SameCOMIdentity(webNav, docShell),
+                   "Unexpected container or script global?");
 #endif
         bool allowDNSPrefetch;
         docShell->GetAllowDNSPrefetch(&allowDNSPrefetch);
         mAllowDNSPrefetch = allowDNSPrefetch;
       }
     }
 
     MaybeRescheduleAnimationFrameNotifications();
@@ -4762,33 +4765,32 @@
   if (mHasHadDefaultView) {
     return nullptr;
   }
 
   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
     do_QueryReferent(mScopeObject);
   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(scriptHandlingObject);
   if (win) {
-    NS_ASSERTION(win->IsInnerWindow(), "Should have inner window here!");
+    MOZ_ASSERT(win->IsInnerWindow(), "Should have inner window here!");
     nsPIDOMWindow* outer = win->GetOuterWindow();
     if (!outer || outer->GetCurrentInnerWindow() != win) {
       NS_WARNING("Wrong inner/outer window combination!");
       return nullptr;
     }
   }
   return scriptHandlingObject;
 }
 void
 nsDocument::SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject)
 {
-  NS_ASSERTION(!mScriptGlobalObject ||
-               mScriptGlobalObject == aScriptObject,
-               "Wrong script object!");
+  MOZ_ASSERT(!mScriptGlobalObject || mScriptGlobalObject == aScriptObject,
+             "Wrong script object!");
   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aScriptObject);
-  NS_ASSERTION(!win || win->IsInnerWindow(), "Should have inner window here!");
+  MOZ_ASSERT(!win || win->IsInnerWindow(), "Should have inner window here!");
   if (aScriptObject) {
     mScopeObject = do_GetWeakReference(aScriptObject);
     mHasHadScriptHandlingObject = true;
     mHasHadDefaultView = false;
   }
 }
 
 bool
@@ -4845,18 +4847,18 @@
   return false;
 }
 
 // Note: We don't hold a reference to the document observer; we assume
 // that it has a live reference to the document.
 void
 nsDocument::AddObserver(nsIDocumentObserver* aObserver)
 {
-  NS_ASSERTION(mObservers.IndexOf(aObserver) == nsTArray<int>::NoIndex,
-               "Observer already in the list");
+  MOZ_ASSERT(mObservers.IndexOf(aObserver) == nsTArray<int>::NoIndex,
+             "Observer already in the list");
   mObservers.AppendElement(aObserver);
   AddMutationObserver(aObserver);
 }
 
 bool
 nsDocument::RemoveObserver(nsIDocumentObserver* aObserver)
 {
   // If we're in the process of destroying the document (and we're
@@ -6400,17 +6402,17 @@
     aResult =
       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
                                                             nameSpaceId);
     if (aResult.Failed()) {
       return nullptr;
     }
   }
 
-  NS_ASSERTION(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
+  MOZ_ASSERT(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
 
   return NS_GetContentList(this, nameSpaceId, aLocalName);
 }
 
 NS_IMETHODIMP
 nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
                                    const nsAString& aLocalName,
                                    nsIDOMNodeList** aReturn)
@@ -6479,20 +6481,20 @@
 {
   aSheetSet.Truncate();
 
   // Look through our sheets, find the selected set title
   int32_t count = GetNumberOfStyleSheets();
   nsAutoString title;
   for (int32_t index = 0; index < count; index++) {
     nsIStyleSheet* sheet = GetStyleSheetAt(index);
-    NS_ASSERTION(sheet, "Null sheet in sheet list!");
+    MOZ_ASSERT(sheet, "Null sheet in sheet list!");
 
     nsCOMPtr<nsIDOMStyleSheet> domSheet = do_QueryInterface(sheet);
-    NS_ASSERTION(domSheet, "Sheet must QI to nsIDOMStyleSheet");
+    MOZ_ASSERT(domSheet, "Sheet must QI to nsIDOMStyleSheet");
     bool disabled;
     domSheet->GetDisabled(&disabled);
     if (disabled) {
       // Disabled sheets don't affect the currently selected set
       continue;
     }
 
     sheet->GetTitle(title);
@@ -6595,17 +6597,17 @@
 nsDocument::EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
                                             bool aUpdateCSSLoader)
 {
   BeginUpdate(UPDATE_STYLE);
   int32_t count = GetNumberOfStyleSheets();
   nsAutoString title;
   for (int32_t index = 0; index < count; index++) {
     nsIStyleSheet* sheet = GetStyleSheetAt(index);
-    NS_ASSERTION(sheet, "Null sheet in sheet list!");
+    MOZ_ASSERT(sheet, "Null sheet in sheet list!");
     sheet->GetTitle(title);
     if (!title.IsEmpty()) {
       sheet->SetEnabled(title.Equals(aSheetSet));
     }
   }
   if (aUpdateCSSLoader) {
     CSSLoader()->SetPreferredSheet(aSheetSet);
   }
@@ -7110,18 +7112,18 @@
 nsDocument::SetTitle(const nsAString& aTitle, ErrorResult& rv)
 {
   rv = SetTitle(aTitle);
 }
 
 void
 nsDocument::NotifyPossibleTitleChange(bool aBoundTitleElement)
 {
-  NS_ASSERTION(!mInUnlinkOrDeletion || !aBoundTitleElement,
-               "Setting a title while unlinking or destroying the element?");
+  MOZ_ASSERT(!mInUnlinkOrDeletion || !aBoundTitleElement,
+             "Setting a title while unlinking or destroying the element?");
   if (mInUnlinkOrDeletion) {
     return;
   }
 
   if (aBoundTitleElement) {
     mMayHaveTitleElement = true;
   }
   if (mPendingTitleChangeEvent.IsPending())
@@ -7327,17 +7329,17 @@
   mFrameLoaderRunner = nullptr;
 
   // Don't use a temporary array for mInitializableFrameLoaders, because
   // loading a frame may cause some other frameloader to be removed from the
   // array. But be careful to keep the loader alive when starting the load!
   while (mInitializableFrameLoaders.Length()) {
     nsRefPtr<nsFrameLoader> loader = mInitializableFrameLoaders[0];
     mInitializableFrameLoaders.RemoveElementAt(0);
-    NS_ASSERTION(loader, "null frameloader in the array?");
+    MOZ_ASSERT(loader, "null frameloader in the array?");
     loader->ReallyStartLoading();
   }
 
   uint32_t length = mFinalizableFrameLoaders.Length();
   if (length > 0) {
     nsTArray<nsRefPtr<nsFrameLoader> > loaders;
     mFinalizableFrameLoaders.SwapElements(loaders);
     for (uint32_t i = 0; i < length; ++i) {
@@ -7577,20 +7579,20 @@
   nsIDocument::GetCompatMode(temp);
   aCompatMode = temp;
   return NS_OK;
 }
 
 void
 nsIDocument::GetCompatMode(nsString& aCompatMode) const
 {
-  NS_ASSERTION(mCompatMode == eCompatibility_NavQuirks ||
+  MOZ_ASSERT(mCompatMode == eCompatibility_NavQuirks ||
                mCompatMode == eCompatibility_AlmostStandards ||
                mCompatMode == eCompatibility_FullStandards,
-               "mCompatMode is neither quirks nor strict for this document");
+             "mCompatMode is neither quirks nor strict for this document");
 
   if (mCompatMode == eCompatibility_NavQuirks) {
     aCompatMode.AssignLiteral("BackCompat");
   } else {
     aCompatMode.AssignLiteral("CSS1Compat");
   }
 }
 
@@ -7599,18 +7601,18 @@
 PLDHashOperator
 BlastFunc(nsAttrHashKey::KeyType aKey, Attr *aData, void* aUserArg)
 {
   nsCOMPtr<nsIAttribute> *attr =
     static_cast<nsCOMPtr<nsIAttribute>*>(aUserArg);
 
   *attr = aData;
 
-  NS_ASSERTION(attr->get(),
-               "non-nsIAttribute somehow made it into the hashmap?!");
+  MOZ_ASSERT(attr->get(),
+             "non-nsIAttribute somehow made it into the hashmap?!");
 
   return PL_DHASH_STOP;
 }
 
 static void
 BlastSubtreeToPieces(nsINode *aNode)
 {
   if (aNode->IsElement()) {
@@ -7624,17 +7626,17 @@
 #ifdef DEBUG
         nsresult rv =
 #endif
           element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
                              attr->NodeInfo()->NameAtom(),
                              false);
 
         // XXX Should we abort here?
-        NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
+        MOZ_ASSERT(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
       }
     }
   }
 
   uint32_t count = aNode->GetChildCount();
   for (uint32_t i = 0; i < count; ++i) {
     BlastSubtreeToPieces(aNode->GetFirstChild());
     aNode->RemoveChildAt(0, false);
@@ -7820,18 +7822,18 @@
     if (rv.Failed()) {
       // Disconnect all nodes from their parents.
       BlastSubtreeToPieces(adoptedNode);
 
       return nullptr;
     }
   }
 
-  NS_ASSERTION(adoptedNode->OwnerDoc() == this,
-               "Should still be in the document we just got adopted into");
+  MOZ_ASSERT(adoptedNode->OwnerDoc() == this,
+             "Should still be in the document we just got adopted into");
 
   return adoptedNode;
 }
 
 nsViewportInfo
 nsDocument::GetViewportInfo(const ScreenIntSize& aDisplaySize)
 {
   // Compute the CSS-to-LayoutDevice pixel scale as the product of the
@@ -8203,17 +8205,18 @@
     static_cast<nsTArray<nsCOMPtr<nsIDocument> >* >(aData);
   resources->AppendElement(aDocument);
   return true;
 }
 
 void
 nsDocument::FlushExternalResources(mozFlushType aType)
 {
-  NS_ASSERTION(aType >= Flush_Style,
+  MOZ_ASSERT(
+    aType >= Flush_Style,
     "should only need to flush for style or higher in external resources");
   if (GetDisplayDocument()) {
     return;
   }
   nsTArray<nsCOMPtr<nsIDocument> > resources;
   EnumerateExternalResources(Copy, &resources);
 
   for (uint32_t i = 0; i < resources.Length(); i++) {
@@ -8396,51 +8399,52 @@
     if (aPrevious) {
       if (--index < 0) {
         index = numRadios -1;
       }
     }
     else if (++index >= numRadios) {
       index = 0;
     }
-    NS_ASSERTION(static_cast<nsGenericHTMLFormElement*>(radioGroup->mRadioButtons[index])->IsHTML(nsGkAtoms::input),
-                 "mRadioButtons holding a non-radio button");
+    MOZ_ASSERT(static_cast<nsGenericHTMLFormElement*>(
+                 radioGroup->mRadioButtons[index])->IsHTML(nsGkAtoms::input),
+               "mRadioButtons holding a non-radio button");
     radio = static_cast<HTMLInputElement*>(radioGroup->mRadioButtons[index]);
   } while (radio->Disabled() && radio != currentRadio);
 
   radio.forget(aRadioOut);
   return NS_OK;
 }
 
 void
 nsDocument::AddToRadioGroup(const nsAString& aName,
                             nsIFormControl* aRadio)
 {
   nsRadioGroupStruct* radioGroup = GetOrCreateRadioGroup(aName);
   radioGroup->mRadioButtons.AppendObject(aRadio);
 
   nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
-  NS_ASSERTION(element, "radio controls have to be content elements");
+  MOZ_ASSERT(element, "radio controls have to be content elements");
   if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
     radioGroup->mRequiredRadioCount++;
   }
 }
 
 void
 nsDocument::RemoveFromRadioGroup(const nsAString& aName,
                                  nsIFormControl* aRadio)
 {
   nsRadioGroupStruct* radioGroup = GetOrCreateRadioGroup(aName);
   radioGroup->mRadioButtons.RemoveObject(aRadio);
 
   nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
-  NS_ASSERTION(element, "radio controls have to be content elements");
+  MOZ_ASSERT(element, "radio controls have to be content elements");
   if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
-    NS_ASSERTION(radioGroup->mRequiredRadioCount != 0,
-                 "mRequiredRadioCount about to wrap below 0!");
+    MOZ_ASSERT(radioGroup->mRequiredRadioCount != 0,
+               "mRequiredRadioCount about to wrap below 0!");
     radioGroup->mRequiredRadioCount--;
   }
 }
 
 NS_IMETHODIMP
 nsDocument::WalkRadioGroup(const nsAString& aName,
                            nsIRadioVisitor* aVisitor,
                            bool aFlushContent)
@@ -8466,18 +8470,18 @@
 void
 nsDocument::RadioRequiredWillChange(const nsAString& aName, bool aRequiredAdded)
 {
   nsRadioGroupStruct* radioGroup = GetOrCreateRadioGroup(aName);
 
   if (aRequiredAdded) {
     radioGroup->mRequiredRadioCount++;
   } else {
-    NS_ASSERTION(radioGroup->mRequiredRadioCount != 0,
-                 "mRequiredRadioCount about to wrap below 0!");
+    MOZ_ASSERT(radioGroup->mRequiredRadioCount != 0,
+               "mRequiredRadioCount about to wrap below 0!");
     radioGroup->mRequiredRadioCount--;
   }
 }
 
 bool
 nsDocument::GetValueMissingState(const nsAString& aName) const
 {
   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
@@ -8599,19 +8603,19 @@
     qName.Append(':');
   }
   qName.Append(aName);
 
   // Note: "a:b:c" is a valid name in non-namespaces XML, and
   // nsDocument::CreateElement can call us with such a name and no prefix,
   // which would cause an error if we just used true here.
   bool nsAware = aPrefix != nullptr || aNamespaceID != GetDefaultNamespaceID();
-  NS_ASSERTION(NS_SUCCEEDED(nsContentUtils::CheckQName(qName, nsAware)),
-               "Don't pass invalid prefixes to nsDocument::CreateElem, "
-               "check caller.");
+  MOZ_ASSERT(NS_SUCCEEDED(nsContentUtils::CheckQName(qName, nsAware)),
+             "Don't pass invalid prefixes to nsDocument::CreateElem, "
+             "check caller.");
 #endif
 
   *aResult = nullptr;
 
   nsRefPtr<mozilla::dom::NodeInfo> nodeInfo;
   mNodeInfoManager->GetNodeInfo(aName, aPrefix, aNamespaceID,
                                 nsIDOMNode::ELEMENT_NODE,
                                 getter_AddRefs(nodeInfo));
@@ -8648,17 +8652,17 @@
 
   nsRefPtr<nsContentList> nodes = GetElementsByTagName(NS_LITERAL_STRING("input"));
 
   nsCOMPtr<nsIContent> item;
   nsAutoString value;
 
   uint32_t length = nodes->Length(true);
   for (uint32_t i = 0; i < length; ++i) {
-    NS_ASSERTION(nodes->Item(i), "null item in node list!");
+    MOZ_ASSERT(nodes->Item(i), "null item in node list!");
 
     nsRefPtr<HTMLInputElement> input = HTMLInputElement::FromContentOrNull(nodes->Item(i));
     if (!input)
       continue;
 
     bool resetValue = false;
 
     input->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
@@ -8675,17 +8679,17 @@
     }
   }
 
   // Now locate all _form_ elements that have autocomplete=off and reset them
   nodes = GetElementsByTagName(NS_LITERAL_STRING("form"));
 
   length = nodes->Length(true);
   for (uint32_t i = 0; i < length; ++i) {
-    NS_ASSERTION(nodes->Item(i), "null item in nodelist");
+    MOZ_ASSERT(nodes->Item(i), "null item in nodelist");
 
     nsCOMPtr<nsIDOMHTMLFormElement> form = do_QueryInterface(nodes->Item(i));
     if (!form)
       continue;
 
     nodes->Item(i)->AsElement()->GetAttr(kNameSpaceID_None,
                                          nsGkAtoms::autocomplete, value);
     if (value.LowerCaseEqualsLiteral("off"))
@@ -9303,19 +9307,18 @@
     // change would be the least of the politeness.
     DispatchFullScreenChange(this);
   }
 }
 
 void
 nsDocument::WillDispatchMutationEvent(nsINode* aTarget)
 {
-  NS_ASSERTION(mSubtreeModifiedDepth != 0 ||
-               mSubtreeModifiedTargets.Count() == 0,
-               "mSubtreeModifiedTargets not cleared after dispatching?");
+  MOZ_ASSERT(mSubtreeModifiedDepth != 0 || mSubtreeModifiedTargets.Count() == 0,
+             "mSubtreeModifiedTargets not cleared after dispatching?");
   ++mSubtreeModifiedDepth;
   if (aTarget) {
     // MayDispatchMutationEvent is often called just before this method,
     // so it has already appended the node to mSubtreeModifiedTargets.
     int32_t count = mSubtreeModifiedTargets.Count();
     if (!count || mSubtreeModifiedTargets[count - 1] != aTarget) {
       mSubtreeModifiedTargets.AppendObject(aTarget);
     }
@@ -9371,33 +9374,33 @@
         RunDOMEventWhenSafe();
     }
   }
 }
 
 void
 nsDocument::AddStyleRelevantLink(Link* aLink)
 {
-  NS_ASSERTION(aLink, "Passing in a null link.  Expect crashes RSN!");
+  MOZ_ASSERT(aLink, "Passing in a null link.  Expect crashes RSN!");
 #ifdef DEBUG
   nsPtrHashKey<Link>* entry = mStyledLinks.GetEntry(aLink);
-  NS_ASSERTION(!entry, "Document already knows about this Link!");
+  MOZ_ASSERT(!entry, "Document already knows about this Link!");
   mStyledLinksCleared = false;
 #endif
   (void)mStyledLinks.PutEntry(aLink);
 }
 
 void
 nsDocument::ForgetLink(Link* aLink)
 {
-  NS_ASSERTION(aLink, "Passing in a null link.  Expect crashes RSN!");
+  MOZ_ASSERT(aLink, "Passing in a null link.  Expect crashes RSN!");
 #ifdef DEBUG
   nsPtrHashKey<Link>* entry = mStyledLinks.GetEntry(aLink);
-  NS_ASSERTION(entry || mStyledLinksCleared,
-               "Document knows nothing about this Link!");
+  MOZ_ASSERT(entry || mStyledLinksCleared,
+             "Document knows nothing about this Link!");
 #endif
   (void)mStyledLinks.RemoveEntry(aLink);
 }
 
 void
 nsDocument::DestroyElementMaps()
 {
 #ifdef DEBUG
@@ -10149,17 +10152,17 @@
     // Can't increment without overflowing; bail out
     return NS_ERROR_NOT_AVAILABLE;
   }
   int32_t newHandle = ++mFrameRequestCallbackCounter;
 
   bool alreadyRegistered = !mFrameRequestCallbacks.IsEmpty();
   DebugOnly<FrameRequest*> request =
     mFrameRequestCallbacks.AppendElement(FrameRequest(aCallback, newHandle));
-  NS_ASSERTION(request, "This is supposed to be infallible!");
+  MOZ_ASSERT(request, "This is supposed to be infallible!");
   if (!alreadyRegistered && mPresShell && IsEventHandlingEnabled()) {
     mPresShell->GetPresContext()->RefreshDriver()->
       ScheduleFrameRequestCallbacks(this);
   }
 
   *aHandle = newHandle;
   return NS_OK;
 }
@@ -10813,18 +10816,18 @@
   return NotFound;
 }
 
 /* static */
 void
 FullscreenRoots::Remove(nsIDocument* aRoot)
 {
   uint32_t index = Find(aRoot);
-  NS_ASSERTION(index != NotFound,
-    "Should only try to remove roots which are still added!");
+  MOZ_ASSERT(index != NotFound,
+             "Should only try to remove roots which are still added!");
   if (index == NotFound || !sInstance) {
     return;
   }
   sInstance->mRoots.RemoveElementAt(index);
   if (sInstance->mRoots.IsEmpty()) {
     delete sInstance;
     sInstance = nullptr;
   }
@@ -11005,20 +11008,20 @@
   }
   return CountFullscreenSubDocuments(this) == 0;
 }
 
 static bool
 ResetFullScreen(nsIDocument* aDocument, void* aData)
 {
   if (aDocument->IsFullScreenDoc()) {
-    NS_ASSERTION(CountFullscreenSubDocuments(aDocument) <= 1,
-        "Should have at most 1 fullscreen subdocument.");
+    MOZ_ASSERT(CountFullscreenSubDocuments(aDocument) <= 1,
+               "Should have at most 1 fullscreen subdocument.");
     static_cast<nsDocument*>(aDocument)->CleanupFullscreenState();
-    NS_ASSERTION(!aDocument->IsFullScreenDoc(), "Should reset full-screen");
+    MOZ_ASSERT(!aDocument->IsFullScreenDoc(), "Should reset full-screen");
     nsTArray<nsIDocument*>* changed = reinterpret_cast<nsTArray<nsIDocument*>*>(aData);
     changed->AppendElement(aDocument);
 
     if (HasCrossProcessParent(aDocument)) {
       // We're at the top of the content-process side doc tree. Ask the parent
       // process to exit fullscreen.
       nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
       os->NotifyObservers(aDocument, "ask-parent-to-exit-fullscreen", nullptr);
@@ -11036,22 +11039,22 @@
   return true;
 }
 
 static void
 ExitFullscreenInDocTree(nsIDocument* aMaybeNotARootDoc)
 {
   MOZ_ASSERT(aMaybeNotARootDoc);
   nsCOMPtr<nsIDocument> root = aMaybeNotARootDoc->GetFullscreenRoot();
-  NS_ASSERTION(root, "Should have root when in fullscreen!");
+  MOZ_ASSERT(root, "Should have root when in fullscreen!");
   if (!root) {
     return;
   }
-  NS_ASSERTION(root->IsFullScreenDoc(),
-    "Fullscreen root should be a fullscreen doc...");
+  MOZ_ASSERT(root->IsFullScreenDoc(),
+             "Fullscreen root should be a fullscreen doc...");
 
   // Stores a list of documents to which we must dispatch "mozfullscreenchange".
   // We're required by the spec to dispatch the events in leaf-to-root
   // order when exiting fullscreen, but we traverse the doctree in a
   // root-to-leaf order, so we save references to the documents we must
   // dispatch to so that we dispatch in the specified order.
   nsAutoTArray<nsIDocument*, 8> changed;
 
@@ -11060,18 +11063,18 @@
 
   // Dispatch "mozfullscreenchange" events. Note this loop is in reverse
   // order so that the events for the leaf document arrives before the root
   // document, as required by the spec.
   for (uint32_t i = 0; i < changed.Length(); ++i) {
     DispatchFullScreenChange(changed[changed.Length() - i - 1]);
   }
 
-  NS_ASSERTION(!root->IsFullScreenDoc(),
-    "Fullscreen root should no longer be a fullscreen doc...");
+  MOZ_ASSERT(!root->IsFullScreenDoc(),
+             "Fullscreen root should no longer be a fullscreen doc...");
 
   // Move the top-level window out of fullscreen mode.
   SetWindowFullScreen(root, false);
 }
 
 /* static */
 void
 nsDocument::ExitFullscreen(nsIDocument* aDoc)
@@ -11085,18 +11088,18 @@
 
   if (aDoc)  {
     ExitFullscreenInDocTree(aDoc);
     return;
   }
 
   // Clear fullscreen stacks in all fullscreen roots' descendant documents.
   FullscreenRoots::ForEach(&ExitFullscreenInDocTree);
-  NS_ASSERTION(FullscreenRoots::IsEmpty(),
-      "Should have exited all fullscreen roots from fullscreen");
+  MOZ_ASSERT(FullscreenRoots::IsEmpty(),
+             "Should have exited all fullscreen roots from fullscreen");
 }
 
 bool
 GetFullscreenLeaf(nsIDocument* aDoc, void* aData)
 {
   if (aDoc->IsFullscreenLeaf()) {
     nsIDocument** result = static_cast<nsIDocument**>(aData);
     *result = aDoc;
@@ -11125,22 +11128,22 @@
   }
   GetFullscreenLeaf(root, &leaf);
   return leaf;
 }
 
 void
 nsDocument::RestorePreviousFullScreenState()
 {
-  NS_ASSERTION(!IsFullScreenDoc() || !FullscreenRoots::IsEmpty(),
-    "Should have at least 1 fullscreen root when fullscreen!");
-  NS_ASSERTION(!nsContentUtils::IsFullscreenApiContentOnly() ||
+  MOZ_ASSERT(!IsFullScreenDoc() || !FullscreenRoots::IsEmpty(),
+             "Should have at least 1 fullscreen root when fullscreen!");
+  MOZ_ASSERT(!nsContentUtils::IsFullscreenApiContentOnly() ||
                !nsContentUtils::IsChromeDoc(this),
-               "Should not run RestorePreviousFullScreenState() on "
-               "chrome document when fullscreen is content only");
+             "Should not run RestorePreviousFullScreenState() on "
+             "chrome document when fullscreen is content only");
 
   if (!IsFullScreenDoc() || !GetWindow() || FullscreenRoots::IsEmpty()) {
     return;
   }
 
   // If fullscreen mode is updated the pointer should be unlocked
   nsCOMPtr<Element> pointerLockedElement =
     do_QueryReferent(EventStateManager::sPointerLockedElement);
@@ -11154,25 +11157,25 @@
   // has a cross process child. So send a notification so that its browser
   // parent will send a message to its child process to also exit fullscreen.
   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
   os->NotifyObservers(fullScreenDoc, "ask-children-to-exit-fullscreen", nullptr);
 
   // Clear full-screen stacks in all descendant in process documents, bottom up.
   nsIDocument* doc = fullScreenDoc;
   while (doc != this) {
-    NS_ASSERTION(doc->IsFullScreenDoc(), "Should be full-screen doc");
+    MOZ_ASSERT(doc->IsFullScreenDoc(), "Should be full-screen doc");
     static_cast<nsDocument*>(doc)->CleanupFullscreenState();
     UnlockPointer();
     DispatchFullScreenChange(doc);
     doc = doc->GetParentDocument();
   }
 
   // Roll-back full-screen state to previous full-screen element.
-  NS_ASSERTION(doc == this, "Must have reached this doc.");
+  MOZ_ASSERT(doc == this, "Must have reached this doc.");
   while (doc != nullptr) {
     static_cast<nsDocument*>(doc)->FullScreenStackPop();
     UnlockPointer();
     DispatchFullScreenChange(doc);
     if (static_cast<nsDocument*>(doc)->mFullScreenStack.IsEmpty()) {
       if (HasCrossProcessParent(doc)) {
         // Send notification to the parent process to tell it to rollback to
         // the previous fullscreen elements in its fullscreen element stacks.
@@ -11217,18 +11220,18 @@
 
       break;
     }
   }
 
   if (doc == nullptr) {
     // We moved all documents in this doctree out of fullscreen mode,
     // move the top-level window out of fullscreen mode.
-    NS_ASSERTION(!GetFullscreenRootDocument(this)->IsFullScreenDoc(),
-      "Should have cleared all docs' stacks");
+    MOZ_ASSERT(!GetFullscreenRootDocument(this)->IsFullScreenDoc(),
+               "Should have cleared all docs' stacks");
     SetWindowFullScreen(this, false);
   }
 }
 
 bool
 nsDocument::IsFullScreenDoc()
 {
   return GetFullScreenElement() != nullptr;
@@ -11267,17 +11270,18 @@
   bool mHadRequestPending;
   FullScreenOptions mOptions;
 };
 
 void
 nsDocument::AsyncRequestFullScreen(Element* aElement,
                                    FullScreenOptions& aOptions)
 {
-  NS_ASSERTION(aElement,
+  MOZ_ASSERT(
+    aElement,
     "Must pass non-null element to nsDocument::AsyncRequestFullScreen");
   if (!aElement) {
     return;
   }
   // Request full-screen asynchronously.
   nsCOMPtr<nsIRunnable> event(new nsCallRequestFullScreen(aElement, aOptions));
   NS_DispatchToCurrentThread(event);
 }
@@ -11339,47 +11343,47 @@
 void
 nsDocument::CleanupFullscreenState()
 {
   if (!mFullScreenStack.IsEmpty()) {
     // The top element in the full-screen stack will have full-screen
     // style bits set on it and its ancestors. Remove the style bits.
     // Note the non-top elements won't have the style bits set.
     Element* top = FullScreenStackTop();
-    NS_ASSERTION(top, "Should have a top when full-screen stack isn't empty");
+    MOZ_ASSERT(top, "Should have a top when full-screen stack isn't empty");
     if (top) {
       // Remove any VR state properties
       top->DeleteProperty(nsGkAtoms::vr_state);
 
       EventStateManager::SetFullScreenState(top, false);
     }
     mFullScreenStack.Clear();
   }
   SetApprovedForFullscreen(false);
   RemoveFullscreenApprovedObserver();
   mFullscreenRoot = nullptr;
 }
 
 bool
 nsDocument::FullScreenStackPush(Element* aElement)
 {
-  NS_ASSERTION(aElement, "Must pass non-null to FullScreenStackPush()");
+  MOZ_ASSERT(aElement, "Must pass non-null to FullScreenStackPush()");
   Element* top = FullScreenStackTop();
   if (top == aElement || !aElement) {
     return false;
   }
   if (top) {
     // We're pushing a new element onto the full-screen stack, so we must
     // remove the ancestor and full-screen styles from the former top of the
     // stack.
     EventStateManager::SetFullScreenState(top, false);
   }
   EventStateManager::SetFullScreenState(aElement, true);
   mFullScreenStack.AppendElement(do_GetWeakReference(aElement));
-  NS_ASSERTION(GetFullScreenElement() == aElement, "Should match");
+  MOZ_ASSERT(GetFullScreenElement() == aElement, "Should match");
   return true;
 }
 
 void
 nsDocument::FullScreenStackPop()
 {
   if (mFullScreenStack.IsEmpty()) {
     return;
@@ -11400,18 +11404,18 @@
   mFullScreenStack.RemoveElementAt(last);
 
   // Pop from the stack null elements (references to elements which have
   // been GC'd since they were added to the stack) and elements which are
   // no longer in this document.
   while (!mFullScreenStack.IsEmpty()) {
     Element* element = FullScreenStackTop();
     if (!element || !element->IsInDoc() || element->OwnerDoc() != this) {
-      NS_ASSERTION(!element->IsFullScreenAncestor(),
-                   "Should have already removed full-screen styles");
+      MOZ_ASSERT(!element->IsFullScreenAncestor(),
+                 "Should have already removed full-screen styles");
       uint32_t last = mFullScreenStack.Length() - 1;
       mFullScreenStack.RemoveElementAt(last);
     } else {
       // The top element of the stack is now an in-doc element. Apply the
       // full-screen styles and return.
       EventStateManager::SetFullScreenState(element, true);
       break;
     }
@@ -11421,19 +11425,20 @@
 Element*
 nsDocument::FullScreenStackTop()
 {
   if (mFullScreenStack.IsEmpty()) {
     return nullptr;
   }
   uint32_t last = mFullScreenStack.Length() - 1;
   nsCOMPtr<Element> element(do_QueryReferent(mFullScreenStack[last]));
-  NS_ASSERTION(element, "Should have full-screen element!");
-  NS_ASSERTION(element->IsInDoc(), "Full-screen element should be in doc");
-  NS_ASSERTION(element->OwnerDoc() == this, "Full-screen element should be in this doc");
+  MOZ_ASSERT(element, "Should have full-screen element!");
+  MOZ_ASSERT(element->IsInDoc(), "Full-screen element should be in doc");
+  MOZ_ASSERT(element->OwnerDoc() == this,
+             "Full-screen element should be in this doc");
   return element;
 }
 
 // Returns true if aDoc is in the focused tab in the active window.
 static bool
 IsInActiveTab(nsIDocument* aDoc)
 {
   nsCOMPtr<nsIDocShell> docshell = aDoc->GetDocShell();
@@ -11515,18 +11520,18 @@
 }
 
 void
 nsDocument::RequestFullScreen(Element* aElement,
                               FullScreenOptions& aOptions,
                               bool aWasCallerChrome,
                               bool aNotifyOnOriginChange)
 {
-  NS_ASSERTION(aElement,
-    "Must pass non-null element to nsDocument::RequestFullScreen");
+  MOZ_ASSERT(aElement,
+             "Must pass non-null element to nsDocument::RequestFullScreen");
   if (!aElement || aElement == GetFullScreenElement()) {
     return;
   }
   if (!aElement->IsInDoc()) {
     LogFullScreenDenied(true, "FullScreenDeniedNotInDocument", this);
     return;
   }
   if (aElement->OwnerDoc() != this) {
@@ -11612,29 +11617,29 @@
                           ReleaseHMDInfoRef,
                           true);
   }
 
   // Set the full-screen element. This sets the full-screen style on the
   // element, and the full-screen-ancestor styles on ancestors of the element
   // in this document.
   DebugOnly<bool> x = FullScreenStackPush(aElement);
-  NS_ASSERTION(x, "Full-screen state of requesting doc should always change!");
+  MOZ_ASSERT(x, "Full-screen state of requesting doc should always change!");
   changed.AppendElement(this);
 
   // Propagate up the document hierarchy, setting the full-screen element as
   // the element's container in ancestor documents. This also sets the
   // appropriate css styles as well. Note we don't propagate down the
   // document hierarchy, the full-screen element (or its container) is not
   // visible there. Stop when we reach the root document.
   nsIDocument* child = this;
   while (true) {
     child->SetFullscreenRoot(fullScreenRootDoc);
-    NS_ASSERTION(child->GetFullscreenRoot() == fullScreenRootDoc,
-        "Fullscreen root should be set!");
+    MOZ_ASSERT(child->GetFullscreenRoot() == fullScreenRootDoc,
+               "Fullscreen root should be set!");
     if (child == fullScreenRootDoc) {
       break;
     }
     nsIDocument* parent = child->GetParentDocument();
     Element* element = parent->FindContentForSubDocument(child)->AsElement();
     if (static_cast<nsDocument*>(parent)->FullScreenStackPush(element)) {
       changed.AppendElement(parent);
       child = parent;
@@ -11680,24 +11685,24 @@
                                true,
                                true);
     asyncDispatcher->PostDOMEvent();
   }
 
 #ifdef DEBUG
   // Note assertions must run before SetWindowFullScreen() as that does
   // synchronous event dispatch which can run script which exits full-screen!
-  NS_ASSERTION(GetFullScreenElement() == aElement,
-               "Full-screen element should be the requested element!");
-  NS_ASSERTION(IsFullScreenDoc(), "Should be full-screen doc");
+  MOZ_ASSERT(GetFullScreenElement() == aElement,
+             "Full-screen element should be the requested element!");
+  MOZ_ASSERT(IsFullScreenDoc(), "Should be full-screen doc");
   nsCOMPtr<nsIDOMElement> fse;
   GetMozFullScreenElement(getter_AddRefs(fse));
   nsCOMPtr<nsIContent> c(do_QueryInterface(fse));
-  NS_ASSERTION(c->AsElement() == aElement,
-    "GetMozFullScreenElement should match GetFullScreenElement()");
+  MOZ_ASSERT(c->AsElement() == aElement,
+             "GetMozFullScreenElement should match GetFullScreenElement()");
 #endif
 
   // The origin which is fullscreen changed, send a notifiction so that the
   // root document knows the origin of the document which requested fullscreen.
   // This is used for the fullscreen approval UI. If we're in a child
   // process, the root BrowserElementChild listens for this notification,
   // and forwards it across to its BrowserElementParent, which
   // re-broadcasts the message for the root document in its process.
@@ -11746,19 +11751,18 @@
   }
   return nullptr;
 }
 
 Element*
 nsDocument::GetFullScreenElement()
 {
   Element* element = FullScreenStackTop();
-  NS_ASSERTION(!element ||
-               element->IsFullScreenAncestor(),
-    "Fullscreen element should have fullscreen styles applied");
+  MOZ_ASSERT(!element || element->IsFullScreenAncestor(),
+             "Fullscreen element should have fullscreen styles applied");
   return element;
 }
 
 NS_IMETHODIMP
 nsDocument::GetMozFullScreen(bool *aFullScreen)
 {
   *aFullScreen = MozFullScreen();
   return NS_OK;
@@ -11777,17 +11781,18 @@
 {
   return IsFullScreenEnabled(nsContentUtils::IsCallerChrome(), false);
 }
 
 static bool
 HasFullScreenSubDocument(nsIDocument* aDoc)
 {
   uint32_t count = CountFullscreenSubDocuments(aDoc);
-  NS_ASSERTION(count <= 1, "Fullscreen docs should have at most 1 fullscreen child!");
+  MOZ_ASSERT(count <= 1,
+             "Fullscreen docs should have at most 1 fullscreen child!");
   return count >= 1;
 }
 
 bool
 nsDocument::IsFullScreenEnabled(bool aCallerIsChrome, bool aLogFailure)
 {
   if (nsContentUtils::IsFullScreenApiEnabled() && aCallerIsChrome) {
     // Chrome code can always use the full-screen API, provided it's not
@@ -12015,19 +12020,19 @@
     DispatchPointerLockError(d);
     return NS_OK;
   }
 
   d->mCancelledPointerLockRequests = 0;
   e->SetPointerLock();
   EventStateManager::sPointerLockedElement = do_GetWeakReference(e);
   EventStateManager::sPointerLockedDoc = do_GetWeakReference(doc);
-  NS_ASSERTION(EventStateManager::sPointerLockedElement &&
+  MOZ_ASSERT(EventStateManager::sPointerLockedElement &&
                EventStateManager::sPointerLockedDoc,
-               "aElement and this should support weak references!");
+             "aElement and this should support weak references!");
 
   DispatchPointerLockChange(d);
   return NS_OK;
 }
 
 void
 nsDocument::SetApprovedForFullscreen(bool aIsApproved)
 {
@@ -12112,18 +12117,18 @@
     bool isAlternate;
     link->UpdateStyleSheet(nullptr, &willNotify, &isAlternate, true);
   }
 }
 
 void
 nsDocument::RequestPointerLock(Element* aElement)
 {
-  NS_ASSERTION(aElement,
-    "Must pass non-null element to nsDocument::RequestPointerLock");
+  MOZ_ASSERT(aElement,
+             "Must pass non-null element to nsDocument::RequestPointerLock");
 
   nsCOMPtr<Element> pointerLockedElement =
     do_QueryReferent(EventStateManager::sPointerLockedElement);
   if (aElement == pointerLockedElement) {
     DispatchPointerLockChange(this);
     return;
   }
 
diff --git a/dom/base/nsDocument.h b/dom/base/nsDocument.h
--- a/dom/base/nsDocument.h
+++ b/dom/base/nsDocument.h
@@ -590,35 +590,33 @@
     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
 
     // Use shims for interfaces that docshell implements directly so that we
     // don't hand out references to the docshell.  The shims should all allow
     // getInterface back on us, but other than that each one should only
     // implement one interface.
     
     // XXXbz I wish we could just derive the _allcaps thing from _i
-#define DECL_SHIM(_i, _allcaps)                                              \
-    class _i##Shim MOZ_FINAL : public nsIInterfaceRequestor,                 \
-                               public _i                                     \
-    {                                                                        \
-      ~_i##Shim() {}                                                         \
-    public:                                                                  \
-      _i##Shim(nsIInterfaceRequestor* aIfreq, _i* aRealPtr)                  \
-        : mIfReq(aIfreq), mRealPtr(aRealPtr)                                 \
-      {                                                                      \
-        NS_ASSERTION(mIfReq, "Expected non-null here");                      \
-        NS_ASSERTION(mRealPtr, "Expected non-null here");                    \
-      }                                                                      \
-      NS_DECL_ISUPPORTS                                                      \
-      NS_FORWARD_NSIINTERFACEREQUESTOR(mIfReq->)                             \
-      NS_FORWARD_##_allcaps(mRealPtr->)                                      \
-    private:                                                                 \
-      nsCOMPtr<nsIInterfaceRequestor> mIfReq;                                \
-      nsCOMPtr<_i> mRealPtr;                                                 \
-    };
+#define DECL_SHIM(_i, _allcaps)                                                \
+  class _i##Shim MOZ_FINAL : public nsIInterfaceRequestor, public _i           \
+  {                                                                            \
+    ~_i##Shim() {}                                                             \
+                                                                               \
+  public:                                                                      \
+    _i##Shim(nsIInterfaceRequestor* aIfreq, _i* aRealPtr)                      \
+      : mIfReq(aIfreq), mRealPtr(aRealPtr)                                     \
+    {                                                                          \
+      MOZ_ASSERT(mIfReq, "Expected non-null here");                            \
+      MOZ_ASSERT(mRealPtr, "Expected non-null here");                          \
+    }                                                                          \
+    NS_DECL_ISUPPORTS NS_FORWARD_NSIINTERFACEREQUESTOR(mIfReq->)               \
+      NS_FORWARD_##_allcaps(mRealPtr->) private                                \
+      : nsCOMPtr<nsIInterfaceRequestor> mIfReq;                                \
+    nsCOMPtr<_i> mRealPtr;                                                     \
+  };
 
     DECL_SHIM(nsILoadContext, NSILOADCONTEXT)
     DECL_SHIM(nsIProgressEventSink, NSIPROGRESSEVENTSINK)
     DECL_SHIM(nsIChannelEventSink, NSICHANNELEVENTSINK)
     DECL_SHIM(nsISecurityEventSink, NSISECURITYEVENTSINK)
     DECL_SHIM(nsIApplicationCacheContainer, NSIAPPLICATIONCACHECONTAINER)
 #undef DECL_SHIM
   };
diff --git a/dom/base/nsDocumentEncoder.cpp b/dom/base/nsDocumentEncoder.cpp
--- a/dom/base/nsDocumentEncoder.cpp
+++ b/dom/base/nsDocumentEncoder.cpp
@@ -1035,18 +1035,19 @@
 
   aOutputString.Truncate();
 
   nsString output;
   static const size_t bufferSize = 2048;
   if (!mCachedBuffer) {
     mCachedBuffer = nsStringBuffer::Alloc(bufferSize).take();
   }
-  NS_ASSERTION(!mCachedBuffer->IsReadonly(),
-               "DocumentEncoder shouldn't keep reference to non-readonly buffer!");
+  MOZ_ASSERT(
+    !mCachedBuffer->IsReadonly(),
+    "DocumentEncoder shouldn't keep reference to non-readonly buffer!");
   static_cast<char16_t*>(mCachedBuffer->Data())[0] = char16_t(0);
   mCachedBuffer->ToString(0, output, true);
   // output owns the buffer now!
   mCachedBuffer = nullptr;
   
 
   if (!mSerializer) {
     nsAutoCString progId(NS_CONTENTSERIALIZER_CONTRACTID_PREFIX);
@@ -1850,17 +1851,17 @@
                               NS_LITERAL_STRING("_moz"), eIgnoreCase);
 }
 
 nsresult 
 nsHTMLCopyEncoder::GetNodeLocation(nsIDOMNode *inChild,
                                    nsCOMPtr<nsIDOMNode> *outParent,
                                    int32_t *outOffset)
 {
-  NS_ASSERTION((inChild && outParent && outOffset), "bad args");
+  MOZ_ASSERT((inChild && outParent && outOffset), "bad args");
   nsresult result = NS_ERROR_NULL_POINTER;
   if (inChild && outParent && outOffset)
   {
     result = inChild->GetParentNode(getter_AddRefs(*outParent));
     if ((NS_SUCCEEDED(result)) && (*outParent))
     {
       nsCOMPtr<nsIContent> content = do_QueryInterface(*outParent);
       nsCOMPtr<nsIContent> cChild = do_QueryInterface(inChild);
diff --git a/dom/base/nsElementFrameLoaderOwner.cpp b/dom/base/nsElementFrameLoaderOwner.cpp
--- a/dom/base/nsElementFrameLoaderOwner.cpp
+++ b/dom/base/nsElementFrameLoaderOwner.cpp
@@ -86,18 +86,18 @@
   mFrameLoader->GetDocShell(getter_AddRefs(doc_shell));
 
   nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(doc_shell);
 
   if (!win) {
     return nullptr;
   }
 
-  NS_ASSERTION(win->IsOuterWindow(),
-               "Uh, this window should always be an outer window!");
+  MOZ_ASSERT(win->IsOuterWindow(),
+             "Uh, this window should always be an outer window!");
 
   return win.forget();
 }
 
 void
 nsElementFrameLoaderOwner::EnsureFrameLoader()
 {
   Element* thisElement = ThisFrameElement();
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -447,18 +447,18 @@
   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
   if (window && window->IsOuterWindow())
     window = window->GetCurrentInnerWindow();
   if (!window)
     window = mFocusedWindow;
 
   *aLastFocusMethod = window ? window->GetFocusMethod() : 0;
 
-  NS_ASSERTION((*aLastFocusMethod & FOCUSMETHOD_MASK) == *aLastFocusMethod,
-               "invalid focus method");
+  MOZ_ASSERT((*aLastFocusMethod & FOCUSMETHOD_MASK) == *aLastFocusMethod,
+             "invalid focus method");
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsFocusManager::SetFocus(nsIDOMElement* aElement, uint32_t aFlags)
 {
   LOGFOCUS(("<<SetFocus begin>>"));
 
@@ -716,17 +716,17 @@
     ActivateOrDeactivate(window, true);
   }
 
   // retrieve the last focused element within the window that was raised
   nsCOMPtr<nsPIDOMWindow> currentWindow;
   nsCOMPtr<nsIContent> currentFocus =
     GetFocusedDescendant(window, true, getter_AddRefs(currentWindow));
 
-  NS_ASSERTION(currentWindow, "window raised with no window current");
+  MOZ_ASSERT(currentWindow, "window raised with no window current");
   if (!currentWindow)
     return NS_OK;
 
   nsCOMPtr<nsIDocShell> currentDocShell = currentWindow->GetDocShell();
 
   nsCOMPtr<nsIPresShell> presShell = currentDocShell->GetPresShell();
   if (presShell) {
     // disable selection mousedown state on activation
@@ -996,17 +996,17 @@
   nsCOMPtr<nsIDocShell> docShellBeingHidden = window->GetDocShell();
   docShellBeingHidden->IsBeingDestroyed(&beingDestroyed);
   if (beingDestroyed) {
     // There is usually no need to do anything if a toplevel window is going
     // away, as we assume that WindowLowered will be called. However, this may
     // not happen if nsIAppStartup::eForceQuit is used to quit, and can cause
     // a leak. So if the active window is being destroyed, call WindowLowered
     // directly.
-    NS_ASSERTION(mFocusedWindow->IsOuterWindow(), "outer window expected");
+    MOZ_ASSERT(mFocusedWindow->IsOuterWindow(), "outer window expected");
     if (mActiveWindow == mFocusedWindow || mActiveWindow == window)
       WindowLowered(mActiveWindow);
     else
       ClearFocus(mActiveWindow);
     return NS_OK;
   }
 
   // if the window being hidden is an ancestor of the focused window, adjust
@@ -1497,17 +1497,17 @@
 
   // If aContent is in designMode, the root element is not focusable.
   // NOTE: in designMode, most elements are not focusable, just the document is
   //       focusable.
   // Also, if aContent is not editable but it isn't in designMode, it's not
   // focusable.
   // And in userfocusignored context nothing is focusable.
   nsIDocument* doc = aContent->GetComposedDoc();
-  NS_ASSERTION(doc, "aContent must have current document");
+  MOZ_ASSERT(doc, "aContent must have current document");
   return aContent == doc->GetRootElement() &&
            (doc->HasFlag(NODE_IS_EDITABLE) || !aContent->IsEditable() ||
             nsContentUtils::IsUserFocusIgnored(aContent));
 }
 
 nsIContent*
 nsFocusManager::CheckIfFocusable(nsIContent* aContent, uint32_t aFlags)
 {
@@ -1984,18 +1984,18 @@
 nsFocusManager::SendFocusOrBlurEvent(uint32_t aType,
                                      nsIPresShell* aPresShell,
                                      nsIDocument* aDocument,
                                      nsISupports* aTarget,
                                      uint32_t aFocusMethod,
                                      bool aWindowRaised,
                                      bool aIsRefocus)
 {
-  NS_ASSERTION(aType == NS_FOCUS_CONTENT || aType == NS_BLUR_CONTENT,
-               "Wrong event type for SendFocusOrBlurEvent");
+  MOZ_ASSERT(aType == NS_FOCUS_CONTENT || aType == NS_BLUR_CONTENT,
+             "Wrong event type for SendFocusOrBlurEvent");
 
   nsCOMPtr<EventTarget> eventTarget = do_QueryInterface(aTarget);
 
   nsCOMPtr<nsINode> n = do_QueryInterface(aTarget);
   if (!n) {
     nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aTarget);
     n = win ? win->GetExtantDoc() : nullptr;
   }
@@ -2003,17 +2003,17 @@
 
   // for focus events, if this event was from a mouse or key and event
   // handling on the document is suppressed, queue the event and fire it
   // later. For blur events, a non-zero value would be set for aFocusMethod.
   if (aFocusMethod && !dontDispatchEvent &&
       aDocument && aDocument->EventHandlingSuppressed()) {
     // aFlags is always 0 when aWindowRaised is true so this won't be called
     // on a window raise.
-    NS_ASSERTION(!aWindowRaised, "aWindowRaised should not be set");
+    MOZ_ASSERT(!aWindowRaised, "aWindowRaised should not be set");
 
     for (uint32_t i = mDelayedBlurFocusEvents.Length(); i > 0; --i) {
       // if this event was already queued, remove it and append it to the end
       if (mDelayedBlurFocusEvents[i - 1].mType == aType &&
           mDelayedBlurFocusEvents[i - 1].mPresShell == aPresShell &&
           mDelayedBlurFocusEvents[i - 1].mDocument == aDocument &&
           mDelayedBlurFocusEvents[i - 1].mTarget == eventTarget) {
         mDelayedBlurFocusEvents.RemoveElementAt(i - 1);
@@ -2242,18 +2242,18 @@
     return NS_OK;
 
   bool caretVisible = caret->IsVisible();
   if (!aVisible && !caretVisible)
     return NS_OK;
 
   nsRefPtr<nsFrameSelection> frameSelection;
   if (aContent) {
-    NS_ASSERTION(aContent->GetComposedDoc() == aPresShell->GetDocument(),
-                 "Wrong document?");
+    MOZ_ASSERT(aContent->GetComposedDoc() == aPresShell->GetDocument(),
+               "Wrong document?");
     nsIFrame *focusFrame = aContent->GetPrimaryFrame();
     if (focusFrame)
       frameSelection = focusFrame->GetFrameSelection();
   }
 
   nsRefPtr<nsFrameSelection> docFrameSelection = aPresShell->FrameSelection();
 
   if (docFrameSelection && caret &&
@@ -2290,17 +2290,17 @@
                                      nsIPresShell* aPresShell,
                                      nsIContent **aStartContent,
                                      nsIContent **aEndContent)
 {
   *aStartContent = *aEndContent = nullptr;
   nsresult rv = NS_ERROR_FAILURE;
 
   nsPresContext* presContext = aPresShell->GetPresContext();
-  NS_ASSERTION(presContext, "mPresContent is null!!");
+  MOZ_ASSERT(presContext, "mPresContent is null!!");
 
   nsRefPtr<nsFrameSelection> frameSelection = aPresShell->FrameSelection();
 
   nsCOMPtr<nsISelection> domSelection;
   if (frameSelection) {
     domSelection = frameSelection->
       GetSelection(nsISelectionController::SELECTION_NORMAL);
   }
@@ -2317,28 +2317,28 @@
       domRange->GetStartContainer(getter_AddRefs(startNode));
       domRange->GetEndContainer(getter_AddRefs(endNode));
       domRange->GetStartOffset(&startOffset);
 
       nsIContent *childContent = nullptr;
 
       startContent = do_QueryInterface(startNode);
       if (startContent && startContent->IsElement()) {
-        NS_ASSERTION(startOffset >= 0, "Start offset cannot be negative");  
+        MOZ_ASSERT(startOffset >= 0, "Start offset cannot be negative");
         childContent = startContent->GetChildAt(startOffset);
         if (childContent) {
           startContent = childContent;
         }
       }
 
       endContent = do_QueryInterface(endNode);
       if (endContent && endContent->IsElement()) {
         int32_t endOffset = 0;
         domRange->GetEndOffset(&endOffset);
-        NS_ASSERTION(endOffset >= 0, "End offset cannot be negative");
+        MOZ_ASSERT(endOffset >= 0, "End offset cannot be negative");
         childContent = endContent->GetChildAt(endOffset);
         if (childContent) {
           endContent = childContent;
         }
       }
     }
   }
   else {
@@ -2527,17 +2527,17 @@
       popupFrame = nsLayoutUtils::GetClosestFrameOfType(frame,
                                                         nsGkAtoms::menuPopupFrame);
     }
 
     if (popupFrame) {
       // Don't navigate outside of a popup, so pretend that the
       // root content is the popup itself
       rootContent = popupFrame->GetContent();
-      NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
+      MOZ_ASSERT(rootContent, "Popup frame doesn't have a content node");
     }
     else if (!forward) {
       // If focus moves backward and when current focused node is root
       // content or <body> element which is editable by contenteditable
       // attribute, focus should move to its parent document.
       if (startContent == rootContent) {
         doNavigation = false;
       } else {
@@ -2556,17 +2556,17 @@
       // the panel
       nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
       if (pm)
         popupFrame = pm->GetTopPopup(ePopupTypePanel);
     }
 #endif
     if (popupFrame) {
       rootContent = popupFrame->GetContent();
-      NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
+      MOZ_ASSERT(rootContent, "Popup frame doesn't have a content node");
       startContent = rootContent;
     }
     else {
       // Otherwise, for content shells, start from the location of the caret.
       if (docShell->ItemType() != nsIDocShellTreeItem::typeChrome) {
         nsCOMPtr<nsIContent> endSelectionContent;
         GetSelectionLocation(doc, presShell,
                              getter_AddRefs(startContent),
@@ -2598,17 +2598,17 @@
       if (!startContent) {
         // otherwise, just use the root content as the starting point
         startContent = rootContent;
         NS_ENSURE_TRUE(startContent, NS_OK);
       }
     }
   }
 
-  NS_ASSERTION(startContent, "starting content not set");
+  MOZ_ASSERT(startContent, "starting content not set");
 
   // keep a reference to the starting content. If we find that again, it means
   // we've iterated around completely and we don't want to adjust the focus.
   // The skipOriginalContentCheck will be set to true only for the first time
   // GetNextTabbableContent is called. This ensures that we don't break out
   // when nothing is focused to start with. Specifically,
   // GetNextTabbableContent first checks the root content -- which happens to
   // be the same as the start content -- when nothing is focused and tabbing
@@ -2708,17 +2708,17 @@
         // popup. This handles the situation of tabbing amongst elements
         // inside an iframe which is itself inside a popup. Otherwise,
         // navigation would move outside the popup when tabbing outside the
         // iframe.
         popupFrame = nsLayoutUtils::GetClosestFrameOfType(frame,
                                                           nsGkAtoms::menuPopupFrame);
         if (popupFrame) {
           rootContent = popupFrame->GetContent();
-          NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
+          MOZ_ASSERT(rootContent, "Popup frame doesn't have a content node");
         }
       }
       else {
         startContent = rootContent;
         tabIndex = forward ? 1 : 0;
       }
     }
     else {
@@ -2836,17 +2836,18 @@
       int32_t tabIndex;
       frame->IsFocusable(&tabIndex, 0);
 
       LOGCONTENTNAVIGATION("Next Tabbable %s:", frame->GetContent());
       LOGFOCUSNAVIGATION(("  with tabindex: %d expected: %d", tabIndex, aCurrentTabIndex));
 
       nsIContent* currentContent = frame->GetContent();
       if (tabIndex >= 0) {
-        NS_ASSERTION(currentContent, "IsFocusable set a tabindex for a frame with no content");
+        MOZ_ASSERT(currentContent,
+                   "IsFocusable set a tabindex for a frame with no content");
         if (currentContent->Tag() == nsGkAtoms::img &&
             currentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::usemap)) {
           // This is an image with a map. Image map areas are not traversed by
           // nsIFrameTraversal so look for the next or previous area element.
           nsIContent *areaContent =
             GetNextTabbableMapArea(aForward, aCurrentTabIndex,
                                    currentContent, iterStartContent);
           if (areaContent) {
@@ -2859,17 +2860,17 @@
           if (aOriginalStartContent && currentContent == aOriginalStartContent) {
             NS_ADDREF(*aResultContent = currentContent);
             return NS_OK;
           }
 
           // found a node with a matching tab index. Check if it is a child
           // frame. If so, navigate into the child frame instead.
           nsIDocument* doc = currentContent->GetComposedDoc();
-          NS_ASSERTION(doc, "content not in document");
+          MOZ_ASSERT(doc, "content not in document");
           nsIDocument* subdoc = doc->GetSubDocumentFor(currentContent);
           if (subdoc) {
             if (!subdoc->EventHandlingSuppressed()) {
               if (aForward) {
                 // when tabbing forward into a frame, return the root
                 // frame so that the canvas becomes focused.
                 nsCOMPtr<nsPIDOMWindow> subframe = subdoc->GetWindow();
                 if (subframe) {
diff --git a/dom/base/nsFrameLoader.cpp b/dom/base/nsFrameLoader.cpp
--- a/dom/base/nsFrameLoader.cpp
+++ b/dom/base/nsFrameLoader.cpp
@@ -384,18 +384,17 @@
       mRemoteBrowser->LoadURL(mURIToLoad);
     } else {
       NS_WARNING("[nsFrameLoader] ReallyStartLoadingInternal tried but couldn't show remote browser.\n");
     }
 
     return NS_OK;
   }
 
-  NS_ASSERTION(mDocShell,
-               "MaybeCreateDocShell succeeded with a null mDocShell");
+  MOZ_ASSERT(mDocShell, "MaybeCreateDocShell succeeded with a null mDocShell");
 
   // Just to be safe, recheck uri.
   rv = CheckURILoad(mURIToLoad);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
   mDocShell->CreateLoadInfo(getter_AddRefs(loadInfo));
   NS_ENSURE_TRUE(loadInfo, NS_ERROR_FAILURE);
@@ -519,18 +518,17 @@
   if (mOwnerContent) {
     nsresult rv = MaybeCreateDocShell();
     if (NS_FAILED(rv))
       return rv;
     if (mRemoteFrame) {
       NS_WARNING("No docshells for remote frames!");
       return rv;
     }
-    NS_ASSERTION(mDocShell,
-                 "MaybeCreateDocShell succeeded, but null mDocShell");
+    MOZ_ASSERT(mDocShell, "MaybeCreateDocShell succeeded, but null mDocShell");
   }
 
   *aDocShell = mDocShell;
   NS_IF_ADDREF(*aDocShell);
 
   return rv;
 }
 
@@ -544,17 +542,17 @@
   mDocShell = nullptr;
 }
 
 static void
 FirePageHideEvent(nsIDocShellTreeItem* aItem,
                   EventTarget* aChromeEventHandler)
 {
   nsCOMPtr<nsIDocument> doc = aItem->GetDocument();
-  NS_ASSERTION(doc, "What happened here?");
+  MOZ_ASSERT(doc, "What happened here?");
   doc->OnPageHide(true, aChromeEventHandler);
 
   int32_t childCount = 0;
   aItem->GetChildCount(&childCount);
   nsAutoTArray<nsCOMPtr<nsIDocShellTreeItem>, 8> kids;
   kids.AppendElements(childCount);
   for (int32_t i = 0; i < childCount; ++i) {
     aItem->GetChildAt(i, getter_AddRefs(kids[i]));
@@ -586,17 +584,17 @@
 
   for (uint32_t i = 0; i < kids.Length(); ++i) {
     if (kids[i]) {
       FirePageShowEvent(kids[i], aChromeEventHandler, aFireIfShowing);
     }
   }
 
   nsCOMPtr<nsIDocument> doc = aItem->GetDocument();
-  NS_ASSERTION(doc, "What happened here?");
+  MOZ_ASSERT(doc, "What happened here?");
   if (doc->IsShowing() == aFireIfShowing) {
     doc->OnPageShow(true, aChromeEventHandler);
   }
 }
 
 static void
 SetTreeOwnerAndChromeEventHandlerOnDocshellTree(nsIDocShellTreeItem* aItem,
                                                 nsIDocShellTreeOwner* aOwner,
@@ -780,17 +778,17 @@
     return ShowRemoteFrame(size, frame);
   }
 
   nsView* view = frame->EnsureInnerView();
   if (!view)
     return false;
 
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(mDocShell);
-  NS_ASSERTION(baseWindow, "Found a nsIDocShell that isn't a nsIBaseWindow.");
+  MOZ_ASSERT(baseWindow, "Found a nsIDocShell that isn't a nsIBaseWindow.");
   baseWindow->InitWindow(nullptr, view->GetWidget(), 0, 0,
                          size.width, size.height);
   // This is kinda whacky, this "Create()" call doesn't really
   // create anything, one starts to wonder why this was named
   // "Create"...
   baseWindow->Create();
   baseWindow->SetVisibility(true);
   NS_ENSURE_TRUE(mDocShell, false);
@@ -866,17 +864,17 @@
   if (presContext)
     presContext->RebuildAllStyleData(nsChangeHint(0), eRestyle_Subtree);
 }
 
 bool
 nsFrameLoader::ShowRemoteFrame(const nsIntSize& size,
                                nsSubDocumentFrame *aFrame)
 {
-  NS_ASSERTION(mRemoteFrame, "ShowRemote only makes sense on remote frames.");
+  MOZ_ASSERT(mRemoteFrame, "ShowRemote only makes sense on remote frames.");
 
   if (!mRemoteBrowser) {
     TryRemoteBrowser();
 
     if (!mRemoteBrowser) {
       NS_ERROR("Couldn't create child process.");
       return false;
     }
@@ -943,18 +941,18 @@
     return;
 
   nsCOMPtr<nsIContentViewer> contentViewer;
   mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
   if (contentViewer)
     contentViewer->SetSticky(false);
 
   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(mDocShell);
-  NS_ASSERTION(baseWin,
-               "Found an nsIDocShell which doesn't implement nsIBaseWindow.");
+  MOZ_ASSERT(baseWin,
+             "Found an nsIDocShell which doesn't implement nsIBaseWindow.");
   baseWin->SetVisibility(false);
   baseWin->SetParentWidget(nullptr);
 }
 
 nsresult
 nsFrameLoader::SwapWithOtherRemoteLoader(nsFrameLoader* aOther,
                                          nsRefPtr<nsFrameLoader>& aFirstToSwap,
                                          nsRefPtr<nsFrameLoader>& aSecondToSwap)
@@ -1160,21 +1158,21 @@
   nsCOMPtr<EventTarget> ourChromeEventHandler =
     do_QueryInterface(ourWindow->GetChromeEventHandler());
   nsCOMPtr<EventTarget> otherChromeEventHandler =
     do_QueryInterface(otherWindow->GetChromeEventHandler());
 
   nsCOMPtr<EventTarget> ourEventTarget = ourWindow->GetParentTarget();
   nsCOMPtr<EventTarget> otherEventTarget = otherWindow->GetParentTarget();
 
-  NS_ASSERTION(SameCOMIdentity(ourFrameElement, ourContent) &&
+  MOZ_ASSERT(SameCOMIdentity(ourFrameElement, ourContent) &&
                SameCOMIdentity(otherFrameElement, otherContent) &&
                SameCOMIdentity(ourChromeEventHandler, ourContent) &&
                SameCOMIdentity(otherChromeEventHandler, otherContent),
-               "How did that happen, exactly?");
+             "How did that happen, exactly?");
 
   nsCOMPtr<nsIDocument> ourChildDocument = ourWindow->GetExtantDoc();
   nsCOMPtr<nsIDocument> otherChildDocument = otherWindow ->GetExtantDoc();
   if (!ourChildDocument || !otherChildDocument) {
     // This shouldn't be happening
     return NS_ERROR_NOT_IMPLEMENTED;
   }
 
@@ -1186,18 +1184,18 @@
   // Make sure to swap docshells between the two frames.
   nsIDocument* ourDoc = ourContent->GetUncomposedDoc();
   nsIDocument* otherDoc = otherContent->GetUncomposedDoc();
   if (!ourDoc || !otherDoc) {
     // Again, how odd, given that we had docshells
     return NS_ERROR_NOT_IMPLEMENTED;
   }
 
-  NS_ASSERTION(ourDoc == ourParentDocument, "Unexpected parent document");
-  NS_ASSERTION(otherDoc == otherParentDocument, "Unexpected parent document");
+  MOZ_ASSERT(ourDoc == ourParentDocument, "Unexpected parent document");
+  MOZ_ASSERT(otherDoc == otherParentDocument, "Unexpected parent document");
 
   nsIPresShell* ourShell = ourDoc->GetShell();
   nsIPresShell* otherShell = otherDoc->GetShell();
   if (!ourShell || !otherShell) {
     return NS_ERROR_NOT_IMPLEMENTED;
   }
 
   if (ourDocshell->GetIsBrowserElement() !=
@@ -1322,19 +1320,19 @@
     do_QueryInterface(otherHistory);
   if (ourInternalHistory) {
     ourInternalHistory->EvictAllContentViewers();
   }
   if (otherInternalHistory) {
     otherInternalHistory->EvictAllContentViewers();
   }
 
-  NS_ASSERTION(ourFrame == ourContent->GetPrimaryFrame() &&
+  MOZ_ASSERT(ourFrame == ourContent->GetPrimaryFrame() &&
                otherFrame == otherContent->GetPrimaryFrame(),
-               "changed primary frame");
+             "changed primary frame");
 
   ourFrameFrame->EndSwapDocShells(otherFrame);
 
   // If the content being swapped came from windows on two screens with
   // incompatible backing resolution (e.g. dragging a tab between windows on
   // hi-dpi and low-dpi screens), it will have style data that is based on
   // the wrong appUnitsPerDevPixel value. So we tell the PresShells that their
   // backing scale factor may have changed. (Bug 822266)
@@ -1687,35 +1685,34 @@
   // in the nearest enclosing chrome shell.
   nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
 
   if (parentType == nsIDocShellTreeItem::typeChrome) {
     // Our parent shell is a chrome shell. It is therefore our nearest
     // enclosing chrome shell.
 
     chromeEventHandler = do_QueryInterface(mOwnerContent);
-    NS_ASSERTION(chromeEventHandler,
-                 "This mContent should implement this.");
+    MOZ_ASSERT(chromeEventHandler, "This mContent should implement this.");
   } else {
     // Our parent shell is a content shell. Get the chrome event
     // handler from it and use that for our shell as well.
 
     docShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
   }
 
   mDocShell->SetChromeEventHandler(chromeEventHandler);
 
   // This is nasty, this code (the mDocShell->GetWindow() below)
   // *must* come *after* the above call to
   // mDocShell->SetChromeEventHandler() for the global window to get
   // the right chrome event handler.
 
   // Tell the window about the frame that hosts it.
   nsCOMPtr<Element> frame_element = mOwnerContent;
-  NS_ASSERTION(frame_element, "frame loader owner element not a DOM element!");
+  MOZ_ASSERT(frame_element, "frame loader owner element not a DOM element!");
 
   nsCOMPtr<nsPIDOMWindow> win_private(mDocShell->GetWindow());
   nsCOMPtr<nsIBaseWindow> base_win(do_QueryInterface(mDocShell));
   if (win_private) {
     win_private->SetFrameElementInternal(frame_element);
   }
 
   // This is kinda whacky, this call doesn't really create anything,
@@ -1825,18 +1822,18 @@
 {
   nsresult rv;
 
   mDepthTooGreat = false;
   rv = MaybeCreateDocShell();
   if (NS_FAILED(rv)) {
     return rv;
   }
-  NS_ASSERTION(!mRemoteFrame,
-               "Shouldn't call CheckForRecursiveLoad on remote frames.");
+  MOZ_ASSERT(!mRemoteFrame,
+             "Shouldn't call CheckForRecursiveLoad on remote frames.");
   if (!mDocShell) {
     return NS_ERROR_FAILURE;
   }
 
   // Check that we're still in the docshell tree.
   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
   mDocShell->GetTreeOwner(getter_AddRefs(treeOwner));
   NS_WARN_IF_FALSE(treeOwner,
@@ -2068,17 +2065,18 @@
     }
   }
   return NS_OK;
 }
 
 bool
 nsFrameLoader::TryRemoteBrowser()
 {
-  NS_ASSERTION(!mRemoteBrowser, "TryRemoteBrowser called with a remote browser already?");
+  MOZ_ASSERT(!mRemoteBrowser,
+             "TryRemoteBrowser called with a remote browser already?");
 
   //XXXsmaug Per spec (2014/08/21) frameloader should not work in case the
   //         element isn't in document, only in shadow dom, but that will change
   //         https://www.w3.org/Bugs/Public/show_bug.cgi?id=26365#c0
   nsIDocument* doc = mOwnerContent->GetComposedDoc();
   if (!doc) {
     return false;
   }
diff --git a/dom/base/nsFrameMessageManager.cpp b/dom/base/nsFrameMessageManager.cpp
--- a/dom/base/nsFrameMessageManager.cpp
+++ b/dom/base/nsFrameMessageManager.cpp
@@ -589,19 +589,19 @@
                                    JS::Handle<JS::Value> aJSON,
                                    JS::Handle<JS::Value> aObjects,
                                    nsIPrincipal* aPrincipal,
                                    JSContext* aCx,
                                    uint8_t aArgc,
                                    JS::MutableHandle<JS::Value> aRetval,
                                    bool aIsSync)
 {
-  NS_ASSERTION(!IsGlobal(), "Should not call SendSyncMessage in chrome");
-  NS_ASSERTION(!IsBroadcaster(), "Should not call SendSyncMessage in chrome");
-  NS_ASSERTION(!mParentManager, "Should not have parent manager in content!");
+  MOZ_ASSERT(!IsGlobal(), "Should not call SendSyncMessage in chrome");
+  MOZ_ASSERT(!IsBroadcaster(), "Should not call SendSyncMessage in chrome");
+  MOZ_ASSERT(!mParentManager, "Should not have parent manager in content!");
 
   aRetval.setUndefined();
   NS_ENSURE_TRUE(mCallback, NS_ERROR_NOT_INITIALIZED);
 
   if (sSendingSyncMessage && aIsSync) {
     // No kind of blocking send should be issued on top of a sync message.
     return NS_ERROR_UNEXPECTED;
   }
@@ -1395,17 +1395,17 @@
 
 nsDataHashtable<nsStringHashKey, nsFrameScriptObjectExecutorHolder*>*
   nsFrameScriptExecutor::sCachedScripts = nullptr;
 nsScriptCacheCleaner* nsFrameScriptExecutor::sScriptCacheCleaner = nullptr;
 
 void
 nsFrameScriptExecutor::DidCreateGlobal()
 {
-  NS_ASSERTION(mGlobal, "Should have mGlobal!");
+  MOZ_ASSERT(mGlobal, "Should have mGlobal!");
   if (!sCachedScripts) {
     sCachedScripts =
       new nsDataHashtable<nsStringHashKey, nsFrameScriptObjectExecutorHolder*>;
 
     nsRefPtr<nsScriptCacheCleaner> scriptCacheCleaner =
       new nsScriptCacheCleaner();
     scriptCacheCleaner.forget(&sScriptCacheCleaner);
   }
@@ -1421,17 +1421,17 @@
 }
 
 // static
 void
 nsFrameScriptExecutor::Shutdown()
 {
   if (sCachedScripts) {
     AutoSafeJSContext cx;
-    NS_ASSERTION(sCachedScripts != nullptr, "Need cached scripts");
+    MOZ_ASSERT(sCachedScripts != nullptr, "Need cached scripts");
     sCachedScripts->Enumerate(RemoveCachedScriptEntry, nullptr);
 
     delete sCachedScripts;
     sCachedScripts = nullptr;
 
     nsRefPtr<nsScriptCacheCleaner> scriptCacheCleaner;
     scriptCacheCleaner.swap(sScriptCacheCleaner);
   }
@@ -1867,18 +1867,18 @@
 
 };
 
 
 // This creates the global parent process message manager.
 nsresult
 NS_NewParentProcessMessageManager(nsIMessageBroadcaster** aResult)
 {
-  NS_ASSERTION(!nsFrameMessageManager::sParentProcessManager,
-               "Re-creating sParentProcessManager");
+  MOZ_ASSERT(!nsFrameMessageManager::sParentProcessManager,
+             "Re-creating sParentProcessManager");
   nsRefPtr<nsFrameMessageManager> mm = new nsFrameMessageManager(nullptr,
                                                                  nullptr,
                                                                  MM_CHROME | MM_PROCESSMANAGER | MM_BROADCASTER);
   nsFrameMessageManager::sParentProcessManager = mm;
   nsFrameMessageManager::NewProcessMessageManager(nullptr); // Create same process message manager.
   return CallQueryInterface(mm, aResult);
 }
 
@@ -1905,18 +1905,18 @@
     sSameProcessParentManager = mm;
   }
   return mm;
 }
 
 nsresult
 NS_NewChildProcessMessageManager(nsISyncMessageSender** aResult)
 {
-  NS_ASSERTION(!nsFrameMessageManager::sChildProcessManager,
-               "Re-creating sChildProcessManager");
+  MOZ_ASSERT(!nsFrameMessageManager::sChildProcessManager,
+             "Re-creating sChildProcessManager");
 
   MessageManagerCallback* cb;
   if (XRE_GetProcessType() == GeckoProcessType_Default) {
     cb = new SameChildProcessMessageManagerCallback();
   } else {
     cb = new ChildProcessMessageManagerCallback();
     RegisterStrongMemoryReporter(new MessageManagerReporter());
   }
diff --git a/dom/base/nsFrameMessageManager.h b/dom/base/nsFrameMessageManager.h
--- a/dom/base/nsFrameMessageManager.h
+++ b/dom/base/nsFrameMessageManager.h
@@ -167,19 +167,19 @@
     mIsProcessManager(!!(aFlags & mozilla::dom::ipc::MM_PROCESSMANAGER)),
     mIsBroadcaster(!!(aFlags & mozilla::dom::ipc::MM_BROADCASTER)),
     mOwnsCallback(!!(aFlags & mozilla::dom::ipc::MM_OWNSCALLBACK)),
     mHandlingMessage(false),
     mDisconnected(false),
     mCallback(aCallback),
     mParentManager(aParentManager)
   {
-    NS_ASSERTION(mChrome || !aParentManager, "Should not set parent manager!");
-    NS_ASSERTION(!mIsBroadcaster || !mCallback,
-                 "Broadcasters cannot have callbacks!");
+    MOZ_ASSERT(mChrome || !aParentManager, "Should not set parent manager!");
+    MOZ_ASSERT(!mIsBroadcaster || !mCallback,
+               "Broadcasters cannot have callbacks!");
     // This is a bit hackish. When parent manager is global, we want
     // to attach the message manager to it immediately.
     // Is it just the frame message manager which waits until the
     // content process is running.
     if (mParentManager && (mCallback || IsBroadcaster())) {
       mParentManager->AddChildManager(this);
     }
     if (mOwnsCallback) {
@@ -253,18 +253,18 @@
                                         const nsAString& aMessage,
                                         const StructuredCloneData& aData,
                                         JS::Handle<JSObject*> aCpows,
                                         nsIPrincipal* aPrincipal);
   void RemoveFromParent();
   nsFrameMessageManager* GetParentManager() { return mParentManager; }
   void SetParentManager(nsFrameMessageManager* aParent)
   {
-    NS_ASSERTION(!mParentManager, "We have parent manager already!");
-    NS_ASSERTION(mChrome, "Should not set parent manager!");
+    MOZ_ASSERT(!mParentManager, "We have parent manager already!");
+    MOZ_ASSERT(mChrome, "Should not set parent manager!");
     mParentManager = aParent;
   }
   bool IsGlobal() { return mGlobal; }
   bool IsBroadcaster() { return mIsBroadcaster; }
 
   static nsFrameMessageManager* GetParentProcessManager()
   {
     return sParentProcessManager;
diff --git a/dom/base/nsGenericDOMDataNode.cpp b/dom/base/nsGenericDOMDataNode.cpp
--- a/dom/base/nsGenericDOMDataNode.cpp
+++ b/dom/base/nsGenericDOMDataNode.cpp
@@ -139,17 +139,17 @@
 NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE(nsGenericDOMDataNode,
                                                    nsNodeUtils::LastRelease(this))
 
 
 void
 nsGenericDOMDataNode::GetNodeValueInternal(nsAString& aNodeValue)
 {
   DebugOnly<nsresult> rv = GetData(aNodeValue);
-  NS_ASSERTION(NS_SUCCEEDED(rv), "GetData() failed!");
+  MOZ_ASSERT(NS_SUCCEEDED(rv), "GetData() failed!");
 }
 
 void
 nsGenericDOMDataNode::SetNodeValueInternal(const nsAString& aNodeValue,
                                            ErrorResult& aError)
 {
   aError = SetTextInternal(0, mText.GetLength(), aNodeValue.BeginReading(),
                            aNodeValue.Length(), true);
@@ -484,21 +484,21 @@
                   "own binding parent");
 
   if (!aBindingParent && aParent) {
     aBindingParent = aParent->GetBindingParent();
   }
 
   // First set the binding parent
   if (aBindingParent) {
-    NS_ASSERTION(IsRootOfNativeAnonymousSubtree() ||
+    MOZ_ASSERT(IsRootOfNativeAnonymousSubtree() ||
                  !HasFlag(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE) ||
                  (aParent && aParent->IsInNativeAnonymousSubtree()),
-                 "Trying to re-bind content from native anonymous subtree to "
-                 "non-native anonymous parent!");
+               "Trying to re-bind content from native anonymous subtree to "
+               "non-native anonymous parent!");
     DataSlots()->mBindingParent = aBindingParent; // Weak, so no addref happens.
     if (aParent->IsInNativeAnonymousSubtree()) {
       SetFlags(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE);
     }
     if (aParent->HasFlag(NODE_CHROME_ONLY_ACCESS)) {
       SetFlags(NODE_CHROME_ONLY_ACCESS);
     }
     if (aParent->IsInShadowTree()) {
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1057,17 +1057,17 @@
   js::WrapperOptions options;
   options.setClass(&OuterWindowProxyClass);
   options.setSingleton(true);
   JSObject *obj = js::Wrapper::New(cx, parent, parent,
                                    isChrome ? &nsChromeOuterWindowProxy::singleton
                                             : &nsOuterWindowProxy::singleton,
                                    options);
 
-  NS_ASSERTION(js::GetObjectClass(obj)->ext.innerObject, "bad class");
+  MOZ_ASSERT(js::GetObjectClass(obj)->ext.innerObject, "bad class");
   return obj;
 }
 
 //*****************************************************************************
 //***    nsGlobalWindow: Object Management
 //*****************************************************************************
 
 nsGlobalWindow::nsGlobalWindow(nsGlobalWindow *aOuterWindow)
@@ -1209,19 +1209,19 @@
 #endif
 
 #ifdef PR_LOGGING
   if (gDOMLeakPRLog)
     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
            ("DOMWINDOW %p created outer=%p", this, aOuterWindow));
 #endif
 
-  NS_ASSERTION(sWindowsById, "Windows hash table must be created!");
-  NS_ASSERTION(!sWindowsById->Get(mWindowID),
-               "This window shouldn't be in the hash table yet!");
+  MOZ_ASSERT(sWindowsById, "Windows hash table must be created!");
+  MOZ_ASSERT(!sWindowsById->Get(mWindowID),
+             "This window shouldn't be in the hash table yet!");
   // We seem to see crashes in release builds because of null |sWindowsById|.
   if (sWindowsById) {
     sWindowsById->Put(mWindowID, this);
   }
 
   // Ensure that the current active state is initialized for child process windows.
   nsFocusManager* fm = nsFocusManager::GetFocusManager();
   if (fm) {
@@ -1242,22 +1242,22 @@
 
 /* static */
 void
 nsGlobalWindow::Init()
 {
   AssertIsOnMainThread();
 
   CallGetService(NS_ENTROPYCOLLECTOR_CONTRACTID, &gEntropyCollector);
-  NS_ASSERTION(gEntropyCollector,
-               "gEntropyCollector should have been initialized!");
+  MOZ_ASSERT(gEntropyCollector,
+             "gEntropyCollector should have been initialized!");
 
 #ifdef PR_LOGGING
   gDOMLeakPRLog = PR_NewLogModule("DOMLeak");
-  NS_ASSERTION(gDOMLeakPRLog, "gDOMLeakPRLog should have been initialized!");
+  MOZ_ASSERT(gDOMLeakPRLog, "gDOMLeakPRLog should have been initialized!");
 #endif
 
   sWindowsById = new WindowByIdTable();
 }
 
 static PLDHashOperator
 DisconnectEventTargetObjects(nsPtrHashKey<DOMEventTargetHelper>* aKey,
                              void* aClosure)
@@ -1272,18 +1272,18 @@
   AssertIsOnMainThread();
 
   mEventTargetObjects.EnumerateEntries(DisconnectEventTargetObjects, nullptr);
   mEventTargetObjects.Clear();
 
   // We have to check if sWindowsById isn't null because ::Shutdown might have
   // been called.
   if (sWindowsById) {
-    NS_ASSERTION(sWindowsById->Get(mWindowID),
-                 "This window should be in the hash table");
+    MOZ_ASSERT(sWindowsById->Get(mWindowID),
+               "This window should be in the hash table");
     sWindowsById->Remove(mWindowID);
   }
 
   --gRefCnt;
 
 #ifdef DEBUG
   if (!PR_GetEnv("MOZ_QUIET")) {
     nsAutoCString url;
@@ -1415,18 +1415,18 @@
 void
 nsGlobalWindow::MaybeForgiveSpamCount()
 {
   if (IsOuterWindow() &&
       IsPopupSpamWindow())
   {
     SetPopupSpamWindow(false);
     --gOpenPopupSpamCount;
-    NS_ASSERTION(gOpenPopupSpamCount >= 0,
-                 "Unbalanced decrement of gOpenPopupSpamCount");
+    MOZ_ASSERT(gOpenPopupSpamCount >= 0,
+               "Unbalanced decrement of gOpenPopupSpamCount");
   }
 }
 
 void
 nsGlobalWindow::DropOuterWindowDocs()
 {
   MOZ_ASSERT(IsOuterWindow());
   MOZ_ASSERT_IF(mDoc, !mDoc->EventHandlingSuppressed());
@@ -1568,17 +1568,17 @@
 
     mControllers = nullptr;
   }
 }
 
 void
 nsGlobalWindow::FreeInnerObjects()
 {
-  NS_ASSERTION(IsInnerWindow(), "Don't free inner objects on an outer window");
+  MOZ_ASSERT(IsInnerWindow(), "Don't free inner objects on an outer window");
 
   // Make sure that this is called before we null out the document and
   // other members that the window destroyed observers could
   // re-create.
   NotifyDOMWindowDestroyed(this);
 
   mInnerObjectsFreed = true;
 
@@ -1941,25 +1941,25 @@
     NS_WARNING("No outer window available!");
     return NS_ERROR_FAILURE;
   }
 
   if (outer->GetWrapperPreserveColor()) {
     return NS_OK;
   }
 
-  NS_ASSERTION(!outer->GetCurrentInnerWindowInternal(),
-               "No cached wrapper, but we have an inner window?");
+  MOZ_ASSERT(!outer->GetCurrentInnerWindowInternal(),
+             "No cached wrapper, but we have an inner window?");
 
   // If this window is a [i]frame, don't bother GC'ing when the frame's context
   // is destroyed since a GC will happen when the frameset or host document is
   // destroyed anyway.
   nsCOMPtr<nsIScriptContext> context = new nsJSContext(!IsFrame(), outer);
 
-  NS_ASSERTION(!outer->mContext, "Will overwrite mContext!");
+  MOZ_ASSERT(!outer->mContext, "Will overwrite mContext!");
 
   // should probably assert the context is clean???
   context->WillInitializeContext();
 
   nsresult rv = context->InitContext();
   NS_ENSURE_SUCCESS(rv, rv);
 
   outer->mContext = context;
@@ -2033,19 +2033,18 @@
 
   if (!mDoc || !aNewDocument) {
     return false;
   }
 
   if (!mDoc->IsInitialDocument()) {
     return false;
   }
-  
-  NS_ASSERTION(NS_IsAboutBlank(mDoc->GetDocumentURI()),
-               "How'd this happen?");
+
+  MOZ_ASSERT(NS_IsAboutBlank(mDoc->GetDocumentURI()), "How'd this happen?");
 
   // Great, we're the original document, check for one of the other
   // conditions.
 
   if (mDoc == aNewDocument) {
     return true;
   }
 
@@ -2084,19 +2083,19 @@
     if (mDoc->NodePrincipal() == newWindowPrincipal)
       return;
 
 #ifdef DEBUG
     // If we have a document loaded at this point, it had better be about:blank.
     // Otherwise, something is really weird.
     nsCOMPtr<nsIURI> uri;
     mDoc->NodePrincipal()->GetURI(getter_AddRefs(uri));
-    NS_ASSERTION(uri && NS_IsAboutBlank(uri) &&
+    MOZ_ASSERT(uri && NS_IsAboutBlank(uri) &&
                  NS_IsAboutBlank(mDoc->GetDocumentURI()),
-                 "Unexpected original document");
+               "Unexpected original document");
 #endif
   }
 
   GetDocShell()->CreateAboutBlankContentViewer(newWindowPrincipal);
   mDoc->SetIsInitialDocument(true);
 
   nsCOMPtr<nsIPresShell> shell = GetDocShell()->GetPresShell();
 
@@ -2358,20 +2357,20 @@
 
   if (IsFrozen()) {
     // This outer is now getting its first inner, thaw the outer now
     // that it's ready and is getting an inner window.
 
     Thaw();
   }
 
-  NS_ASSERTION(!GetCurrentInnerWindow() ||
+  MOZ_ASSERT(!GetCurrentInnerWindow() ||
                GetCurrentInnerWindow()->GetExtantDoc() == mDoc,
-               "Uh, mDoc doesn't match the current inner window "
-               "document!");
+             "Uh, mDoc doesn't match the current inner window "
+             "document!");
 
   bool wouldReuseInnerWindow = WouldReuseInnerWindow(aDocument);
   if (aForceReuseInnerWindow &&
       !wouldReuseInnerWindow &&
       mDoc &&
       mDoc->NodePrincipal() != aDocument->NodePrincipal()) {
     NS_ERROR("Attempted forced inner window reuse while changing principal");
     return NS_ERROR_UNEXPECTED;
@@ -2441,23 +2440,24 @@
 
   // Check if we're anywhere near the stack limit before we reach the
   // transplanting code, since it has no good way to handle errors. This uses
   // the untrusted script limit, which is not strictly necessary since no
   // actual script should run.
   JS_CHECK_RECURSION_CONSERVATIVE(cx, return NS_ERROR_FAILURE);
 
   nsCOMPtr<WindowStateHolder> wsh = do_QueryInterface(aState);
-  NS_ASSERTION(!aState || wsh, "What kind of weird state are you giving me here?");
+  MOZ_ASSERT(!aState || wsh,
+             "What kind of weird state are you giving me here?");
 
   JS::Rooted<JSObject*> newInnerGlobal(cx);
   if (reUseInnerWindow) {
     // We're reusing the current inner window.
-    NS_ASSERTION(!currentInner->IsFrozen(),
-                 "We should never be reusing a shared inner window");
+    MOZ_ASSERT(!currentInner->IsFrozen(),
+               "We should never be reusing a shared inner window");
     newInnerWindow = currentInner;
     newInnerGlobal = currentInner->GetWrapperPreserveColor();
 
     if (aDocument != oldDoc) {
       JS::ExposeObjectToActiveJS(newInnerGlobal);
     }
 
     // We're reusing the inner window, but this still counts as a navigation,
@@ -2512,19 +2512,19 @@
       Freeze();
       mCreatingInnerWindow = true;
       // Every script context we are initialized with must create a
       // new global.
       rv = CreateNativeGlobalForInner(cx, newInnerWindow,
                                       aDocument->GetDocumentURI(),
                                       aDocument->NodePrincipal(),
                                       &newInnerGlobal);
-      NS_ASSERTION(NS_SUCCEEDED(rv) && newInnerGlobal &&
+      MOZ_ASSERT(NS_SUCCEEDED(rv) && newInnerGlobal &&
                    newInnerWindow->GetWrapperPreserveColor() == newInnerGlobal,
-                   "Failed to get script global");
+                 "Failed to get script global");
 
       mCreatingInnerWindow = false;
       createdInnerWindow = true;
       Thaw();
 
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
@@ -2600,18 +2600,18 @@
       {
         JSAutoCompartment ac(cx, outerObject);
 
         JS_SetParent(cx, outerObject, newInnerGlobal);
 
         // Inform the nsJSContext, which is the canonical holder of the outer.
         mContext->SetWindowProxy(outerObject);
 
-        NS_ASSERTION(!JS_IsExceptionPending(cx),
-                     "We might overwrite a pending exception!");
+        MOZ_ASSERT(!JS_IsExceptionPending(cx),
+                   "We might overwrite a pending exception!");
         XPCWrappedNativeScope* scope = xpc::ObjectScope(outerObject);
         if (scope->mWaiverWrapperMap) {
           scope->mWaiverWrapperMap->Reparent(cx, newInnerGlobal);
         }
       }
     }
 
     // Enter the new global's compartment.
@@ -2645,18 +2645,18 @@
     // Now that both the the inner and outer windows are initialized
     // let the script context do its magic to hook them together.
     MOZ_ASSERT(mContext->GetWindowProxy() == GetWrapperPreserveColor());
 #ifdef DEBUG
     JS::Rooted<JSObject*> rootedJSObject(cx, GetWrapperPreserveColor());
     JS::Rooted<JSObject*> proto1(cx), proto2(cx);
     JS_GetPrototype(cx, rootedJSObject, &proto1);
     JS_GetPrototype(cx, newInnerGlobal, &proto2);
-    NS_ASSERTION(proto1 == proto2,
-                 "outer and inner globals should have the same prototype");
+    MOZ_ASSERT(proto1 == proto2,
+               "outer and inner globals should have the same prototype");
 #endif
 
     nsCOMPtr<Element> frame = GetFrameElementInternal();
     if (frame) {
       nsPIDOMWindow* parentWindow = frame->OwnerDoc()->GetWindow();
       if (parentWindow && parentWindow->TimeoutSuspendCount()) {
         SuspendTimeouts(parentWindow->TimeoutSuspendCount());
       }
@@ -2835,26 +2835,26 @@
 
   // Clear our mutation bitfield.
   mMutationBits = 0;
 }
 
 void
 nsGlobalWindow::SetDocShell(nsIDocShell* aDocShell)
 {
-  NS_ASSERTION(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
+  MOZ_ASSERT(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
   MOZ_ASSERT(aDocShell);
 
   if (aDocShell == mDocShell) {
     return;
   }
 
   mDocShell = aDocShell; // Weak Reference
 
-  NS_ASSERTION(!mNavigator, "Non-null mNavigator in outer window!");
+  MOZ_ASSERT(!mNavigator, "Non-null mNavigator in outer window!");
 
   if (mFrames) {
     mFrames->SetDocShell(aDocShell);
   }
 
   // Get our enclosing chrome shell and retrieve its global window impl, so
   // that we can do some forwarding to the chrome document.
   nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
@@ -2881,45 +2881,46 @@
   bool docShellActive;
   mDocShell->GetIsActive(&docShellActive);
   mIsBackground = !docShellActive;
 }
 
 void
 nsGlobalWindow::DetachFromDocShell()
 {
-  NS_ASSERTION(IsOuterWindow(), "Uh, DetachFromDocShell() called on inner window!");
+  MOZ_ASSERT(IsOuterWindow(),
+             "Uh, DetachFromDocShell() called on inner window!");
 
   // DetachFromDocShell means the window is being torn down. Drop our
   // reference to the script context, allowing it to be deleted
   // later. Meanwhile, keep our weak reference to the script object
   // so that it can be retrieved later (until it is finalized by the JS GC).
 
-  NS_ASSERTION(mTimeouts.isEmpty(), "Uh, outer window holds timeouts!");
+  MOZ_ASSERT(mTimeouts.isEmpty(), "Uh, outer window holds timeouts!");
 
   // Call FreeInnerObjects on all inner windows, not just the current
   // one, since some could be held by WindowStateHolder objects that
   // are GC-owned.
   for (nsRefPtr<nsGlobalWindow> inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
        inner != this;
        inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
-    NS_ASSERTION(!inner->mOuterWindow || inner->mOuterWindow == this,
-                 "bad outer window pointer");
+    MOZ_ASSERT(!inner->mOuterWindow || inner->mOuterWindow == this,
+               "bad outer window pointer");
     inner->FreeInnerObjects();
   }
 
   // Make sure that this is called before we null out the document.
   NotifyDOMWindowDestroyed(this);
 
   NotifyWindowIDDestroyed("outer-window-destroyed");
 
   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
 
   if (currentInner) {
-    NS_ASSERTION(mDoc, "Must have doc!");
+    MOZ_ASSERT(mDoc, "Must have doc!");
 
     // Remember the document's principal and URI.
     mDocumentPrincipal = mDoc->NodePrincipal();
     mDocumentURI = mDoc->GetDocumentURI();
     mDocBaseURI = mDoc->GetDocBaseURI();
 
     // Release our document reference
     DropOuterWindowDocs();
@@ -2932,44 +2933,44 @@
 
   if (mContext) {
     nsJSContext::PokeGC(JS::gcreason::SET_DOC_SHELL);
     mContext = nullptr;
   }
 
   mDocShell = nullptr; // Weak Reference
 
-  NS_ASSERTION(!mNavigator, "Non-null mNavigator in outer window!");
+  MOZ_ASSERT(!mNavigator, "Non-null mNavigator in outer window!");
 
   if (mFrames) {
     mFrames->SetDocShell(nullptr);
   }
 
   MaybeForgiveSpamCount();
   CleanUp();
 }
 
 void
 nsGlobalWindow::SetOpenerWindow(nsIDOMWindow* aOpener,
                                 bool aOriginalOpener)
 {
   FORWARD_TO_OUTER_VOID(SetOpenerWindow, (aOpener, aOriginalOpener));
 
-  NS_ASSERTION(!aOriginalOpener || !mSetOpenerWindowCalled,
-               "aOriginalOpener is true, but not first call to "
-               "SetOpenerWindow!");
-  NS_ASSERTION(aOpener || !aOriginalOpener,
-               "Shouldn't set mHadOriginalOpener if aOpener is null");
+  MOZ_ASSERT(!aOriginalOpener || !mSetOpenerWindowCalled,
+             "aOriginalOpener is true, but not first call to "
+             "SetOpenerWindow!");
+  MOZ_ASSERT(aOpener || !aOriginalOpener,
+             "Shouldn't set mHadOriginalOpener if aOpener is null");
 
 #ifdef DEBUG
   nsCOMPtr<nsPIDOMWindow> opener = do_QueryInterface(aOpener);
   MOZ_ASSERT(!opener || opener->IsOuterWindow());
 #endif
   mOpener = do_GetWeakReference(aOpener);
-  NS_ASSERTION(mOpener || !aOpener, "Opener must support weak references!");
+  MOZ_ASSERT(mOpener || !aOpener, "Opener must support weak references!");
 
   if (aOriginalOpener) {
     mHadOriginalOpener = true;
   }
 
 #ifdef DEBUG
   mSetOpenerWindowCalled = true;
 #endif
@@ -3106,17 +3107,18 @@
 
 bool
 nsGlobalWindow::ShouldPromptToBlockDialogs()
 {
   MOZ_ASSERT(IsOuterWindow());
 
   nsGlobalWindow *topWindow = GetScriptableTop();
   if (!topWindow) {
-    NS_ASSERTION(!mDocShell, "ShouldPromptToBlockDialogs() called without a top window?");
+    MOZ_ASSERT(!mDocShell,
+               "ShouldPromptToBlockDialogs() called without a top window?");
     return true;
   }
 
   topWindow = topWindow->GetCurrentInnerWindowInternal();
   if (!topWindow) {
     return true;
   }
 
@@ -3154,19 +3156,19 @@
 
   return topWindow->mAreDialogsEnabled;
 }
 
 bool
 nsGlobalWindow::DialogsAreBeingAbused()
 {
   MOZ_ASSERT(IsInnerWindow());
-  NS_ASSERTION(GetScriptableTop() &&
+  MOZ_ASSERT(GetScriptableTop() &&
                GetScriptableTop()->GetCurrentInnerWindowInternal() == this,
-               "DialogsAreBeingAbused called with invalid window");
+             "DialogsAreBeingAbused called with invalid window");
 
   if (mLastDialogQuitTime.IsNull() ||
       nsContentUtils::IsCallerChrome()) {
     return false;
   }
 
   TimeDuration dialogInterval(TimeStamp::Now() - mLastDialogQuitTime);
   if (dialogInterval.ToSeconds() <
@@ -3440,18 +3442,18 @@
 
 Element*
 nsPIDOMWindow::GetFrameElementInternal() const
 {
   if (mOuterWindow) {
     return mOuterWindow->GetFrameElementInternal();
   }
 
-  NS_ASSERTION(!IsInnerWindow(),
-               "GetFrameElementInternal() called on orphan inner window");
+  MOZ_ASSERT(!IsInnerWindow(),
+             "GetFrameElementInternal() called on orphan inner window");
 
   return mFrameElement;
 }
 
 void
 nsPIDOMWindow::SetFrameElementInternal(Element* aFrameElement)
 {
   if (IsOuterWindow()) {
@@ -6113,18 +6115,18 @@
 
   return NS_OK;
 }
 
 void
 nsGlobalWindow::EnsureReflowFlushAndPaint()
 {
   MOZ_ASSERT(IsOuterWindow());
-  NS_ASSERTION(mDocShell, "EnsureReflowFlushAndPaint() called with no "
-               "docshell!");
+  MOZ_ASSERT(mDocShell, "EnsureReflowFlushAndPaint() called with no "
+                        "docshell!");
 
   if (!mDocShell)
     return;
 
   nsCOMPtr<nsIPresShell> presShell = mDocShell->GetPresShell();
 
   if (!presShell)
     return;
@@ -7533,18 +7535,18 @@
  * routine to determine whether to allow the new window.
  * Returns a value from the PopupControlState enum.
  */
 PopupControlState
 nsGlobalWindow::RevisePopupAbuseLevel(PopupControlState aControl)
 {
   MOZ_ASSERT(IsOuterWindow());
 
-  NS_ASSERTION(mDocShell, "Must have docshell");
-  
+  MOZ_ASSERT(mDocShell, "Must have docshell");
+
   if (mDocShell->ItemType() != nsIDocShellTreeItem::typeContent) {
     return openAllowed;
   }
 
   PopupControlState abuse = aControl;
   switch (abuse) {
   case openControlled:
   case openAbused:
@@ -7903,20 +7905,20 @@
 static JSObject*
 PostMessageReadStructuredClone(JSContext* cx,
                                JSStructuredCloneReader* reader,
                                uint32_t tag,
                                uint32_t data,
                                void* closure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   if (tag == SCTAG_DOM_BLOB) {
-    NS_ASSERTION(!data, "Data should be empty");
+    MOZ_ASSERT(!data, "Data should be empty");
 
     // What we get back from the reader is a FileImpl.
     // From that we create a new File.
     FileImpl* blobImpl;
     if (JS_ReadBytes(reader, &blobImpl, sizeof(blobImpl))) {
       MOZ_ASSERT(blobImpl);
 
       // nsRefPtr<File> needs to go out of scope before toObjectOrNull() is
@@ -7932,17 +7934,17 @@
         }
       }
 
       return &val.toObject();
     }
   }
 
   if (tag == SCTAG_DOM_FILELIST) {
-    NS_ASSERTION(!data, "Data should be empty");
+    MOZ_ASSERT(!data, "Data should be empty");
 
     nsISupports* supports;
     if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
       JS::Rooted<JS::Value> val(cx);
       if (NS_SUCCEEDED(nsContentUtils::WrapNative(cx, supports, &val))) {
         return val.toObjectOrNull();
       }
     }
@@ -7960,17 +7962,17 @@
 
 static bool
 PostMessageWriteStructuredClone(JSContext* cx,
                                 JSStructuredCloneWriter* writer,
                                 JS::Handle<JSObject*> obj,
                                 void *closure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   // See if this is a File/Blob object.
   {
     File* blob = nullptr;
     if (scInfo->subsumes && NS_SUCCEEDED(UNWRAP_OBJECT(Blob, obj, blob))) {
       FileImpl* blobImpl = blob->Impl();
       if (JS_WriteUint32Pair(writer, SCTAG_DOM_BLOB, 0) &&
           JS_WriteBytes(writer, &blobImpl, sizeof(blobImpl))) {
@@ -8011,17 +8013,17 @@
 PostMessageReadTransferStructuredClone(JSContext* aCx,
                                        JSStructuredCloneReader* reader,
                                        uint32_t tag, void* aData,
                                        uint64_t aExtraData,
                                        void* aClosure,
                                        JS::MutableHandle<JSObject*> returnObject)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(aClosure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   if (tag == SCTAG_DOM_MAP_MESSAGEPORT) {
     MessagePort* port = static_cast<MessagePort*>(aData);
     port->BindToOwner(scInfo->window);
     scInfo->ports.Put(port, nullptr);
 
     JS::Rooted<JSObject*> obj(aCx, port->WrapObject(aCx));
     if (JS_WrapObject(aCx, &obj)) {
@@ -8040,17 +8042,17 @@
                                    JS::Handle<JSObject*> aObj,
                                    void* aClosure,
                                    uint32_t* aTag,
                                    JS::TransferableOwnership* aOwnership,
                                    void** aContent,
                                    uint64_t* aExtraData)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(aClosure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   MessagePortBase* port = nullptr;
   nsresult rv = UNWRAP_OBJECT(MessagePort, aObj, port);
   if (NS_SUCCEEDED(rv)) {
     nsRefPtr<MessagePortBase> newPort;
     if (scInfo->ports.Get(port, getter_AddRefs(newPort))) {
       // No duplicate.
       return false;
@@ -8070,17 +8072,17 @@
   return false;
 }
 
 void
 PostMessageFreeTransferStructuredClone(uint32_t aTag, JS::TransferableOwnership aOwnership,
                                        void *aContent, uint64_t aExtraData, void* aClosure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(aClosure);
-  NS_ASSERTION(scInfo, "Must have scInfo!");
+  MOZ_ASSERT(scInfo, "Must have scInfo!");
 
   if (aTag == SCTAG_DOM_MAP_MESSAGEPORT) {
     nsRefPtr<MessagePortBase> port(static_cast<MessagePort*>(aContent));
     scInfo->ports.Remove(port);
   }
 }
 
 const JSStructuredCloneCallbacks kPostMessageCallbacks = {
@@ -8233,17 +8235,17 @@
     // *now* that determines who sent the message (and not an identity which might
     // have changed due to intervening navigations).
     callerPrin = callerInnerWin->GetPrincipal();
   }
   else {
     // In case the global is not a window, it can be a sandbox, and the sandbox's
     // principal can be used for the security check.
     nsIGlobalObject* global = GetIncumbentGlobal();
-    NS_ASSERTION(global, "Why is there no global object?");
+    MOZ_ASSERT(global, "Why is there no global object?");
     callerPrin = global->PrincipalOrNull();
   }
   if (!callerPrin) {
     return;
   }
 
   nsCOMPtr<nsIURI> callerOuterURI;
   if (NS_FAILED(callerPrin->GetURI(getter_AddRefs(callerOuterURI)))) {
@@ -8685,17 +8687,17 @@
   nsIDocument* topDoc = topWin->GetExtantDoc();
   nsIContent* capturingContent = nsIPresShell::GetCapturingContent();
   if (capturingContent && topDoc &&
       nsContentUtils::ContentIsCrossDocDescendantOf(capturingContent, topDoc)) {
     nsIPresShell::SetCapturingContent(nullptr, 0);
   }
 
   if (topWin->mModalStateDepth == 0) {
-    NS_ASSERTION(!mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
+    MOZ_ASSERT(!mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
 
     mSuspendedDoc = topDoc;
     if (mSuspendedDoc) {
       mSuspendedDoc->SuppressEventHandling(nsIDocument::eAnimationsOnly);
     }
   }
   topWin->mModalStateDepth++;
 }
@@ -8751,17 +8753,17 @@
 }
 
 class nsPendingTimeoutRunner : public nsRunnable
 {
 public:
   explicit nsPendingTimeoutRunner(nsGlobalWindow* aWindow)
     : mWindow(aWindow)
   {
-    NS_ASSERTION(mWindow, "mWindow is null.");
+    MOZ_ASSERT(mWindow, "mWindow is null.");
   }
 
   NS_IMETHOD Run()
   {
     nsGlobalWindow::RunPendingTimeoutsRecursive(mWindow, mWindow);
 
     return NS_OK;
   }
@@ -9564,20 +9566,20 @@
 }
 
 NS_IMETHODIMP
 nsGlobalWindow::AddEventListener(const nsAString& aType,
                                  nsIDOMEventListener *aListener,
                                  bool aUseCapture, bool aWantsUntrusted,
                                  uint8_t aOptionalArgc)
 {
-  NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
-               "Won't check if this is chrome, you want to set "
-               "aWantsUntrusted to false or make the aWantsUntrusted "
-               "explicit by making optional_argc non-zero.");
+  MOZ_ASSERT(!aWantsUntrusted || aOptionalArgc > 1,
+             "Won't check if this is chrome, you want to set "
+             "aWantsUntrusted to false or make the aWantsUntrusted "
+             "explicit by making optional_argc non-zero.");
 
   if (IsOuterWindow() && mInnerWindow &&
       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   if (!aWantsUntrusted &&
       (aOptionalArgc < 2 && !nsContentUtils::IsChromeDoc(mDoc))) {
@@ -9620,20 +9622,20 @@
 
 NS_IMETHODIMP
 nsGlobalWindow::AddSystemEventListener(const nsAString& aType,
                                        nsIDOMEventListener *aListener,
                                        bool aUseCapture,
                                        bool aWantsUntrusted,
                                        uint8_t aOptionalArgc)
 {
-  NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
-               "Won't check if this is chrome, you want to set "
-               "aWantsUntrusted to false or make the aWantsUntrusted "
-               "explicit by making optional_argc non-zero.");
+  MOZ_ASSERT(!aWantsUntrusted || aOptionalArgc > 1,
+             "Won't check if this is chrome, you want to set "
+             "aWantsUntrusted to false or make the aWantsUntrusted "
+             "explicit by making optional_argc non-zero.");
 
   if (IsOuterWindow() && mInnerWindow &&
       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   if (!aWantsUntrusted &&
       (aOptionalArgc < 2 && !nsContentUtils::IsChromeDoc(mDoc))) {
@@ -9924,18 +9926,18 @@
 {
   MOZ_ASSERT(IsOuterWindow());
 
   SetChromeEventHandlerInternal(aChromeEventHandler);
   // update the chrome event handler on all our inner windows
   for (nsGlobalWindow *inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
        inner != this;
        inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
-    NS_ASSERTION(!inner->mOuterWindow || inner->mOuterWindow == this,
-                 "bad outer window pointer");
+    MOZ_ASSERT(!inner->mOuterWindow || inner->mOuterWindow == this,
+               "bad outer window pointer");
     inner->SetChromeEventHandlerInternal(aChromeEventHandler);
   }
 }
 
 static bool IsLink(nsIContent* aContent)
 {
   return aContent && (aContent->IsHTML(nsGkAtoms::a) ||
                       aContent->AttrValueIs(kNameSpaceID_XLink, nsGkAtoms::type,
@@ -9950,17 +9952,17 @@
   FORWARD_TO_INNER_VOID(SetFocusedNode, (aNode, aFocusMethod, aNeedsFocus));
 
   if (aNode && aNode->GetComposedDoc() != mDoc) {
     NS_WARNING("Trying to set focus to a node from a wrong document");
     return;
   }
 
   if (mCleanedUp) {
-    NS_ASSERTION(!aNode, "Trying to focus cleaned up window!");
+    MOZ_ASSERT(!aNode, "Trying to focus cleaned up window!");
     aNode = nullptr;
     aNeedsFocus = false;
   }
   if (mFocusedNode != aNode) {
     UpdateCanvasFocus(false, aNode);
     mFocusedNode = aNode;
     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
     mShowFocusRingForContent = false;
@@ -10217,18 +10219,18 @@
   return DispatchEvent(event, &dummy);
 }
 
 nsresult
 nsGlobalWindow::DispatchSyncPopState()
 {
   FORWARD_TO_INNER(DispatchSyncPopState, (), NS_OK);
 
-  NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
-               "Must be safe to run script here.");
+  MOZ_ASSERT(nsContentUtils::IsSafeToRunScript(),
+             "Must be safe to run script here.");
 
   // Check that PopState hasn't been pref'ed off.
   if (!Preferences::GetBool(sPopStatePrefStr, false)) {
     return NS_OK;
   }
 
   nsresult rv = NS_OK;
 
@@ -10460,19 +10462,18 @@
 
   if (mSessionStorage) {
 #ifdef PR_LOGGING
     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
       PR_LogPrint("nsGlobalWindow %p has %p sessionStorage", this, mSessionStorage.get());
     }
 #endif
     bool canAccess = mSessionStorage->CanAccess(principal);
-    NS_ASSERTION(canAccess,
-                 "This window owned sessionStorage "
-                 "that could not be accessed!");
+    MOZ_ASSERT(canAccess, "This window owned sessionStorage "
+                          "that could not be accessed!");
     if (!canAccess) {
       mSessionStorage = nullptr;
     }
   }
 
   if (!mSessionStorage) {
     nsString documentURI;
     if (mDoc) {
@@ -11644,17 +11645,17 @@
   nsCOMPtr<nsIDocShell> docShell = GetDocShell();
   if (docShell) {
     int32_t childCount = 0;
     docShell->GetChildCount(&childCount);
 
     for (int32_t i = 0; i < childCount; ++i) {
       nsCOMPtr<nsIDocShellTreeItem> childShell;
       docShell->GetChildAt(i, getter_AddRefs(childShell));
-      NS_ASSERTION(childShell, "null child shell");
+      MOZ_ASSERT(childShell, "null child shell");
 
       nsCOMPtr<nsPIDOMWindow> pWin = childShell->GetWindow();
       if (pWin) {
         nsGlobalWindow *win =
           static_cast<nsGlobalWindow*>
                      (static_cast<nsPIDOMWindow*>(pWin));
         win->FireDelayedDOMEvents();
       }
@@ -11749,17 +11750,17 @@
 
   nsCOMPtr<nsIWebBrowserChrome> chrome = GetWebBrowserChrome();
   if (!chrome) {
     // No chrome means we don't want to go through with this open call
     // -- see nsIWindowWatcher.idl
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  NS_ASSERTION(mDocShell, "Must have docshell here");
+  MOZ_ASSERT(mDocShell, "Must have docshell here");
 
   // Popups from apps are never blocked.
   bool isApp = false;
   if (mDoc) {
     isApp = mDoc->NodePrincipal()->GetAppStatus() >=
               nsIPrincipal::APP_STATUS_INSTALLED;
   }
 
@@ -11878,17 +11879,17 @@
       // window.open() from JavaScript, make sure there's a document in
       // the new window. We do this by simply asking the new window for
       // its document, this will synchronously create an empty document
       // if there is no document in the window.
       // XXXbz should this just use EnsureInnerWindow()?
 #ifdef DEBUG_jst
       {
         nsCOMPtr<nsPIDOMWindow> pidomwin(do_QueryInterface(*aReturn));
-        NS_ASSERTION(pidomwin->GetExtantDoc(), "No document in new window!!!");
+        MOZ_ASSERT(pidomwin->GetExtantDoc(), "No document in new window!!!");
       }
 #endif
 
       nsCOMPtr<nsIDOMDocument> doc;
       (*aReturn)->GetDocument(getter_AddRefs(doc));
     }
   }
 
@@ -12270,17 +12271,17 @@
     sNestingLevel = timeout->mNestingLevel;
   }
 
   nsCOMPtr<nsIScriptTimeoutHandler> handler(timeout->mScriptHandler);
   nsRefPtr<Function> callback = handler->GetCallback();
   if (!callback) {
     // Evaluate the timeout expression.
     const char16_t* script = handler->GetHandlerText();
-    NS_ASSERTION(script, "timeout has no script nor handler text!");
+    MOZ_ASSERT(script, "timeout has no script nor handler text!");
 
     const char* filename = nullptr;
     uint32_t lineNo = 0;
     handler->GetLocation(&filename, &lineNo);
 
     // New script entry point required, due to the "Create a script" sub-step of
     // http://www.whatwg.org/specs/web-apps/current-work/#timer-initialization-steps
     AutoEntryScript entryScript(this, true, aScx->GetNativeContext());
@@ -12357,19 +12358,19 @@
   // And make sure delay is nonnegative; that might happen if the timer
   // thread is firing our timers somewhat early or if they're taking a long
   // time to run the callback.
   if (delay < TimeDuration(0)) {
     delay = TimeDuration(0);
   }
 
   if (!aTimeout->mTimer) {
-    NS_ASSERTION(IsFrozen() || mTimeoutsSuspendDepth,
-                 "How'd our timer end up null if we're not frozen or "
-                 "suspended?");
+    MOZ_ASSERT(IsFrozen() || mTimeoutsSuspendDepth,
+               "How'd our timer end up null if we're not frozen or "
+               "suspended?");
 
     aTimeout->mTimeRemaining = delay;
     return true;
   }
 
   aTimeout->mWhen = currentNow + delay;
 
   // Reschedule the OS timer. Don't bother returning any error codes if
@@ -12402,18 +12403,18 @@
 nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
 {
   // If a modal dialog is open for this window, return early. Pending
   // timeouts will run when the modal dialog is dismissed.
   if (IsInModalState() || mTimeoutsSuspendDepth) {
     return;
   }
 
-  NS_ASSERTION(IsInnerWindow(), "Timeout running on outer window!");
-  NS_ASSERTION(!IsFrozen(), "Timeout running on a window in the bfcache!");
+  MOZ_ASSERT(IsInnerWindow(), "Timeout running on outer window!");
+  MOZ_ASSERT(!IsFrozen(), "Timeout running on a window in the bfcache!");
 
   nsTimeout *nextTimeout;
   nsTimeout *last_expired_timeout, *last_insertion_point;
   uint32_t firingDepth = mTimeoutFiringDepth + 1;
 
   // Make sure that the window and the script context don't go away as
   // a result of running timeouts
   nsCOMPtr<nsIScriptGlobalObject> windowKungFuDeathGrip(this);
@@ -12641,34 +12642,34 @@
     uint32_t oldIntervalMillisecs = 0;
     timeout->mTimer->GetDelay(&oldIntervalMillisecs);
     TimeDuration oldInterval = TimeDuration::FromMilliseconds(oldIntervalMillisecs);
     if (oldInterval > interval) {
       // unclamp
       TimeStamp firingTime =
         std::max(timeout->mWhen - oldInterval + interval, now);
 
-      NS_ASSERTION(firingTime < timeout->mWhen,
-                   "Our firing time should strictly decrease!");
+      MOZ_ASSERT(firingTime < timeout->mWhen,
+                 "Our firing time should strictly decrease!");
 
       TimeDuration delay = firingTime - now;
       timeout->mWhen = firingTime;
 
       // Since we reset mWhen we need to move |timeout| to the right
       // place in the list so that it remains sorted by mWhen.
       
       // Get the pointer to the next timeout now, before we move the
       // current timeout in the list.
       nsTimeout* nextTimeout = timeout->getNext();
 
       // It is safe to remove and re-insert because mWhen is now
       // strictly smaller than it used to be, so we know we'll insert
       // |timeout| before nextTimeout.
-      NS_ASSERTION(!nextTimeout ||
-                   timeout->mWhen < nextTimeout->mWhen, "How did that happen?");
+      MOZ_ASSERT(!nextTimeout || timeout->mWhen < nextTimeout->mWhen,
+                 "How did that happen?");
       timeout->remove();
       // InsertTimeoutIntoList will addref |timeout| and reset
       // mFiringDepth.  Make sure to undo that after calling it.
       uint32_t firingDepth = timeout->mFiringDepth;
       InsertTimeoutIntoList(timeout);
       timeout->mFiringDepth = firingDepth;
       timeout->Release();
 
@@ -12723,18 +12724,18 @@
 
   // Clear out our list
   mTimeouts.clear();
 }
 
 void
 nsGlobalWindow::InsertTimeoutIntoList(nsTimeout *aTimeout)
 {
-  NS_ASSERTION(IsInnerWindow(),
-               "InsertTimeoutIntoList() called on outer window!");
+  MOZ_ASSERT(IsInnerWindow(),
+             "InsertTimeoutIntoList() called on outer window!");
 
   // Start at mLastTimeout and go backwards.  Don't go further than
   // mTimeoutInsertionPoint, though.  This optimizes for the common case of
   // insertion at the end.
   nsTimeout* prevSibling;
   for (prevSibling = mTimeouts.getLast();
        prevSibling && prevSibling != mTimeoutInsertionPoint &&
          // This condition needs to match the one in SetTimeoutOrInterval that
@@ -12899,17 +12900,17 @@
   NS_PRECONDITION(IsOuterWindow(), "Can't save the inner window's state");
 
   if (!mContext || !GetWrapperPreserveColor()) {
     // The window may be getting torn down; don't bother saving state.
     return nullptr;
   }
 
   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
-  NS_ASSERTION(inner, "No inner window to save");
+  MOZ_ASSERT(inner, "No inner window to save");
 
   // Don't do anything else to this inner window! After this point, all
   // calls to SetTimeoutOrInterval will create entries in the timeout
   // list that will only run after this window has come out of the bfcache.
   // Also, while we're frozen, we won't dispatch online/offline events
   // to the page.
   inner->Freeze();
 
@@ -12920,17 +12921,17 @@
 #endif
 
   return state.forget();
 }
 
 nsresult
 nsGlobalWindow::RestoreWindowState(nsISupports *aState)
 {
-  NS_ASSERTION(IsOuterWindow(), "Cannot restore an inner window");
+  MOZ_ASSERT(IsOuterWindow(), "Cannot restore an inner window");
 
   if (!mContext || !GetWrapperPreserveColor()) {
     // The window may be getting torn down; don't bother restoring state.
     return NS_OK;
   }
 
   nsCOMPtr<WindowStateHolder> holder = do_QueryInterface(aState);
   NS_ENSURE_TRUE(holder, NS_ERROR_FAILURE);
@@ -13012,24 +13013,24 @@
   nsCOMPtr<nsIDocShell> docShell = GetDocShell();
   if (docShell) {
     int32_t childCount = 0;
     docShell->GetChildCount(&childCount);
 
     for (int32_t i = 0; i < childCount; ++i) {
       nsCOMPtr<nsIDocShellTreeItem> childShell;
       docShell->GetChildAt(i, getter_AddRefs(childShell));
-      NS_ASSERTION(childShell, "null child shell");
+      MOZ_ASSERT(childShell, "null child shell");
 
       nsCOMPtr<nsPIDOMWindow> pWin = childShell->GetWindow();
       if (pWin) {
         nsGlobalWindow *win =
           static_cast<nsGlobalWindow*>
                      (static_cast<nsPIDOMWindow*>(pWin));
-        NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
+        MOZ_ASSERT(win->IsOuterWindow(), "Expected outer window");
         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
 
         // This is a bit hackish. Only freeze/suspend windows which are truly our
         // subwindows.
         nsCOMPtr<Element> frame = pWin->GetFrameElementInternal();
         if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
           continue;
         }
@@ -13044,17 +13045,17 @@
   }
 }
 
 nsresult
 nsGlobalWindow::ResumeTimeouts(bool aThawChildren)
 {
   FORWARD_TO_INNER(ResumeTimeouts, (), NS_ERROR_NOT_INITIALIZED);
 
-  NS_ASSERTION(mTimeoutsSuspendDepth, "Mismatched calls to ResumeTimeouts!");
+  MOZ_ASSERT(mTimeoutsSuspendDepth, "Mismatched calls to ResumeTimeouts!");
   --mTimeoutsSuspendDepth;
   bool shouldResume = (mTimeoutsSuspendDepth == 0) && !mInnerObjectsFreed;
   nsresult rv;
 
   if (shouldResume) {
     nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
     if (ac) {
       for (uint32_t i = 0; i < mEnabledSensors.Length(); i++)
@@ -13080,17 +13081,17 @@
 #endif
 
     for (nsTimeout *t = mTimeouts.getFirst(); t; t = t->getNext()) {
       // There's a chance we're being called with RunTimeout on the stack in which
       // case we have a dummy timeout in the list that *must not* be resumed. It
       // can be identified by a null mWindow.
       if (!t->mWindow) {
 #ifdef DEBUG
-        NS_ASSERTION(!_seenDummyTimeout, "More than one dummy timeout?!");
+        MOZ_ASSERT(!_seenDummyTimeout, "More than one dummy timeout?!");
         _seenDummyTimeout = true;
 #endif
         continue;
       }
 
       // XXXbz the combination of the way |delay| and |t->mWhen| are set here
       // makes no sense.  Are we trying to impose that min timeout value or
       // not???
@@ -13120,25 +13121,25 @@
   nsCOMPtr<nsIDocShell> docShell = GetDocShell();
   if (docShell) {
     int32_t childCount = 0;
     docShell->GetChildCount(&childCount);
 
     for (int32_t i = 0; i < childCount; ++i) {
       nsCOMPtr<nsIDocShellTreeItem> childShell;
       docShell->GetChildAt(i, getter_AddRefs(childShell));
-      NS_ASSERTION(childShell, "null child shell");
+      MOZ_ASSERT(childShell, "null child shell");
 
       nsCOMPtr<nsPIDOMWindow> pWin = childShell->GetWindow();
       if (pWin) {
         nsGlobalWindow *win =
           static_cast<nsGlobalWindow*>
                      (static_cast<nsPIDOMWindow*>(pWin));
 
-        NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
+        MOZ_ASSERT(win->IsOuterWindow(), "Expected outer window");
         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
 
         // This is a bit hackish. Only thaw/resume windows which are truly our
         // subwindows.
         nsCOMPtr<Element> frame = pWin->GetFrameElementInternal();
         if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
           continue;
         }
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1335,17 +1335,17 @@
   // caller.
   bool WindowExists(const nsAString& aName, bool aLookForCallerOnJSStack);
 
   already_AddRefed<nsIWidget> GetMainWidget();
   nsIWidget* GetNearestWidget();
 
   void Freeze()
   {
-    NS_ASSERTION(!IsFrozen(), "Double-freezing?");
+    MOZ_ASSERT(!IsFrozen(), "Double-freezing?");
     mIsFrozen = true;
     NotifyDOMWindowFrozen(this);
   }
 
   void Thaw()
   {
     mIsFrozen = false;
     NotifyDOMWindowThawed(this);
diff --git a/dom/base/nsHTMLContentSerializer.cpp b/dom/base/nsHTMLContentSerializer.cpp
--- a/dom/base/nsHTMLContentSerializer.cpp
+++ b/dom/base/nsHTMLContentSerializer.cpp
@@ -323,17 +323,17 @@
       // We're looking at a malformed script tag. This means that the end tag
       // was missing in the source. Imitate that here by not serializing the end
       // tag.
       --PreLevel();
       return NS_OK;
     }
   }
   else if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML) {
-    NS_ASSERTION((!mOLStateStack.IsEmpty()), "Cannot have an empty OL Stack");
+    MOZ_ASSERT((!mOLStateStack.IsEmpty()), "Cannot have an empty OL Stack");
     /* Though at this point we must always have an state to be deleted as all 
     the OL opening tags are supposed to push an olState object to the stack*/
     if (!mOLStateStack.IsEmpty()) {
       mOLStateStack.RemoveElementAt(mOLStateStack.Length() -1);
     }
   }
   
   if (ns == kNameSpaceID_XHTML) {
diff --git a/dom/base/nsHostObjectProtocolHandler.cpp b/dom/base/nsHostObjectProtocolHandler.cpp
--- a/dom/base/nsHostObjectProtocolHandler.cpp
+++ b/dom/base/nsHostObjectProtocolHandler.cpp
@@ -504,17 +504,17 @@
     return NS_ERROR_DOM_BAD_URI;
   }
 
 #ifdef DEBUG
   {
     nsCOMPtr<nsIURIWithPrincipal> uriPrinc = do_QueryInterface(uri);
     nsCOMPtr<nsIPrincipal> principal;
     uriPrinc->GetPrincipal(getter_AddRefs(principal));
-    NS_ASSERTION(info->mPrincipal == principal, "Wrong principal!");
+    MOZ_ASSERT(info->mPrincipal == principal, "Wrong principal!");
   }
 #endif
 
   nsCOMPtr<nsIInputStream> stream;
   nsresult rv = blob->GetInternalStream(getter_AddRefs(stream));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIChannel> channel;
@@ -605,17 +605,17 @@
 {
   result.AssignLiteral(FONTTABLEURI_SCHEME);
   return NS_OK;
 }
 
 nsresult
 NS_GetBlobForBlobURI(nsIURI* aURI, FileImpl** aBlob)
 {
-  NS_ASSERTION(IsBlobURI(aURI), "Only call this with blob URIs");
+  MOZ_ASSERT(IsBlobURI(aURI), "Only call this with blob URIs");
 
   *aBlob = nullptr;
 
   nsCOMPtr<FileImpl> blob = do_QueryInterface(GetDataObject(aURI));
   if (!blob) {
     return NS_ERROR_DOM_BAD_URI;
   }
 
@@ -633,17 +633,17 @@
   }
 
   return blobImpl->GetInternalStream(aStream);
 }
 
 nsresult
 NS_GetStreamForMediaStreamURI(nsIURI* aURI, mozilla::DOMMediaStream** aStream)
 {
-  NS_ASSERTION(IsMediaStreamURI(aURI), "Only call this with mediastream URIs");
+  MOZ_ASSERT(IsMediaStreamURI(aURI), "Only call this with mediastream URIs");
 
   nsISupports* dataObject = GetDataObject(aURI);
   if (!dataObject) {
     return NS_ERROR_DOM_BAD_URI;
   }
 
   *aStream = nullptr;
   return CallQueryInterface(dataObject, aStream);
@@ -680,17 +680,17 @@
 
   uri.forget(aResult);
   return NS_OK;
 }
 
 nsresult
 NS_GetSourceForMediaSourceURI(nsIURI* aURI, mozilla::dom::MediaSource** aSource)
 {
-  NS_ASSERTION(IsMediaSourceURI(aURI), "Only call this with mediasource URIs");
+  MOZ_ASSERT(IsMediaSourceURI(aURI), "Only call this with mediasource URIs");
 
   *aSource = nullptr;
 
   nsCOMPtr<mozilla::dom::MediaSource> source = do_QueryInterface(GetDataObject(aURI));
   if (!source) {
     return NS_ERROR_DOM_BAD_URI;
   }
 
diff --git a/dom/base/nsIContent.h b/dom/base/nsIContent.h
--- a/dom/base/nsIContent.h
+++ b/dom/base/nsIContent.h
@@ -160,20 +160,20 @@
 
   /**
    * Get whether this content is C++-generated anonymous content
    * @see nsIAnonymousContentCreator
    * @return whether this content is anonymous
    */
   bool IsRootOfNativeAnonymousSubtree() const
   {
-    NS_ASSERTION(!HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT) ||
+    MOZ_ASSERT(!HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT) ||
                  (HasFlag(NODE_IS_ANONYMOUS_ROOT) &&
                   HasFlag(NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE)),
-                 "Some flags seem to be missing!");
+               "Some flags seem to be missing!");
     return HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT);
   }
 
   bool IsRootOfChromeAccessOnlySubtree() const
   {
     return HasFlag(NODE_IS_NATIVE_ANONYMOUS_ROOT |
                    NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS);
   }
@@ -195,48 +195,49 @@
   virtual nsIContent* FindFirstNonChromeOnlyAccessContent() const;
 
   /**
    * Returns true if and only if this node has a parent, but is not in
    * its parent's child list.
    */
   bool IsRootOfAnonymousSubtree() const
   {
-    NS_ASSERTION(!IsRootOfNativeAnonymousSubtree() ||
+    MOZ_ASSERT(!IsRootOfNativeAnonymousSubtree() ||
                  (GetParent() && GetBindingParent() == GetParent()),
-                 "root of native anonymous subtree must have parent equal "
-                 "to binding parent");
-    NS_ASSERTION(!GetParent() ||
-                 ((GetBindingParent() == GetParent()) ==
-                  HasFlag(NODE_IS_ANONYMOUS_ROOT)) ||
+               "root of native anonymous subtree must have parent equal "
+               "to binding parent");
+    MOZ_ASSERT(!GetParent() || ((GetBindingParent() == GetParent()) ==
+                                HasFlag(NODE_IS_ANONYMOUS_ROOT)) ||
                  // Unfortunately default content for XBL insertion points is
                  // anonymous content that is bound with the parent of the
                  // insertion point as the parent but the bound element for the
                  // binding as the binding parent.  So we have to complicate
                  // the assert a bit here.
                  (GetBindingParent() &&
                   (GetBindingParent() == GetParent()->GetBindingParent()) ==
-                  HasFlag(NODE_IS_ANONYMOUS_ROOT)),
-                 "For nodes with parent, flag and GetBindingParent() check "
-                 "should match");
+                    HasFlag(NODE_IS_ANONYMOUS_ROOT)),
+               "For nodes with parent, flag and GetBindingParent() check "
+               "should match");
     return HasFlag(NODE_IS_ANONYMOUS_ROOT);
   }
 
   /**
    * Returns true if there is NOT a path through child lists
    * from the top of this node's parent chain back to this node or
    * if the node is in native anonymous subtree without a parent.
    */
   bool IsInAnonymousSubtree() const
   {
-    NS_ASSERTION(!IsInNativeAnonymousSubtree() || GetBindingParent() ||
-                 (!IsInDoc() &&
-                  static_cast<nsIContent*>(SubtreeRoot())->IsInNativeAnonymousSubtree()),
-                 "Must have binding parent when in native anonymous subtree which is in document.\n"
-                 "Native anonymous subtree which is not in document must have native anonymous root.");
+    MOZ_ASSERT(!IsInNativeAnonymousSubtree() || GetBindingParent() ||
+                 (!IsInDoc() && static_cast<nsIContent*>(SubtreeRoot())
+                                  ->IsInNativeAnonymousSubtree()),
+               "Must have binding parent when in native anonymous subtree "
+               "which is in document.\n"
+               "Native anonymous subtree which is not in document must have "
+               "native anonymous root.");
     return IsInNativeAnonymousSubtree() || (!IsInShadowTree() && GetBindingParent() != nullptr);
   }
 
   /**
    * Return true iff this node is in an HTML document (in the HTML5 sense of
    * the term, i.e. not in an XHTML/XML document).
    */
   inline bool IsInHTMLDocument() const;
@@ -909,18 +910,19 @@
         // xml:lang has precedence over lang on HTML elements (see
         // XHTML1 section C.7).
         bool hasAttr = content->GetAttr(kNameSpaceID_XML, nsGkAtoms::lang,
                                           aResult);
         if (!hasAttr && (content->IsHTML() || content->IsSVG())) {
           hasAttr = content->GetAttr(kNameSpaceID_None, nsGkAtoms::lang,
                                      aResult);
         }
-        NS_ASSERTION(hasAttr || aResult.IsEmpty(),
-                     "GetAttr that returns false should not make string non-empty");
+        MOZ_ASSERT(
+          hasAttr || aResult.IsEmpty(),
+          "GetAttr that returns false should not make string non-empty");
         if (hasAttr) {
           return;
         }
       }
     }
   }
 
   // Overloaded from nsINode
diff --git a/dom/base/nsIDocument.h b/dom/base/nsIDocument.h
--- a/dom/base/nsIDocument.h
+++ b/dom/base/nsIDocument.h
@@ -628,29 +628,28 @@
 
   nsIPresShell* GetShell() const
   {
     return GetBFCacheEntry() ? nullptr : mPresShell;
   }
 
   void DisallowBFCaching()
   {
-    NS_ASSERTION(!mBFCacheEntry, "We're already in the bfcache!");
+    MOZ_ASSERT(!mBFCacheEntry, "We're already in the bfcache!");
     mBFCacheDisallowed = true;
   }
 
   bool IsBFCachingAllowed() const
   {
     return !mBFCacheDisallowed;
   }
 
   void SetBFCacheEntry(nsIBFCacheEntry* aEntry)
   {
-    NS_ASSERTION(IsBFCachingAllowed() || !aEntry,
-                 "You should have checked!");
+    MOZ_ASSERT(IsBFCachingAllowed() || !aEntry, "You should have checked!");
 
     mBFCacheEntry = aEntry;
   }
 
   nsIBFCacheEntry* GetBFCacheEntry() const
   {
     return mBFCacheEntry;
   }
diff --git a/dom/base/nsINode.cpp b/dom/base/nsINode.cpp
--- a/dom/base/nsINode.cpp
+++ b/dom/base/nsINode.cpp
@@ -251,26 +251,26 @@
   if (IsInDoc()) {
     node = OwnerDocAsNode();
   } else if (IsContent()) {
     ShadowRoot* containingShadow = AsContent()->GetContainingShadow();
     node = containingShadow ? containingShadow : mSubtreeRoot;
   } else {
     node = mSubtreeRoot;
   }
-  NS_ASSERTION(node, "Should always have a node here!");
+  MOZ_ASSERT(node, "Should always have a node here!");
 #ifdef DEBUG
   {
     const nsINode* slowNode = this;
     const nsINode* iter = slowNode;
     while ((iter = iter->GetParentNode())) {
       slowNode = iter;
     }
 
-    NS_ASSERTION(slowNode == node, "These should always be in sync!");
+    MOZ_ASSERT(slowNode == node, "These should always be in sync!");
   }
 #endif
   return node;
 }
 
 static nsIContent* GetRootForContentSubtree(nsIContent* aContent)
 {
   NS_ENSURE_TRUE(aContent, nullptr);
@@ -625,39 +625,39 @@
   // Merge and remove all nodes
   nsAutoString tmpStr;
   for (uint32_t i = 0; i < nodes.Length(); ++i) {
     nsIContent* node = nodes[i];
     // Merge with previous node unless empty
     const nsTextFragment* text = node->GetText();
     if (text->GetLength()) {
       nsIContent* target = node->GetPreviousSibling();
-      NS_ASSERTION((target && target->NodeType() == nsIDOMNode::TEXT_NODE) ||
+      MOZ_ASSERT((target && target->NodeType() == nsIDOMNode::TEXT_NODE) ||
                    hasRemoveListeners,
-                   "Should always have a previous text sibling unless "
-                   "mutation events messed us up");
+                 "Should always have a previous text sibling unless "
+                 "mutation events messed us up");
       if (!hasRemoveListeners ||
           (target && target->NodeType() == nsIDOMNode::TEXT_NODE)) {
         nsTextNode* t = static_cast<nsTextNode*>(target);
         if (text->Is2b()) {
           t->AppendTextForNormalize(text->Get2b(), text->GetLength(), true, node);
         }
         else {
           tmpStr.Truncate();
           text->AppendTo(tmpStr);
           t->AppendTextForNormalize(tmpStr.get(), tmpStr.Length(), true, node);
         }
       }
     }
 
     // Remove node
     nsCOMPtr<nsINode> parent = node->GetParentNode();
-    NS_ASSERTION(parent || hasRemoveListeners,
-                 "Should always have a parent unless "
-                 "mutation events messed us up");
+    MOZ_ASSERT(parent || hasRemoveListeners,
+               "Should always have a parent unless "
+               "mutation events messed us up");
     if (parent) {
       parent->RemoveChildAt(parent->IndexOf(node), true);
     }
   }
 }
 
 void
 nsINode::GetBaseURI(nsAString &aURI) const
@@ -862,18 +862,18 @@
     if (elem == node1 && attr1) {
       // Both nodes are attributes on the same element.
       // Compare position between the attributes.
 
       uint32_t i;
       const nsAttrName* attrName;
       for (i = 0; (attrName = elem->GetAttrNameAt(i)); ++i) {
         if (attrName->Equals(attr1->NodeInfo())) {
-          NS_ASSERTION(!attrName->Equals(attr2->NodeInfo()),
-                       "Different attrs at same position");
+          MOZ_ASSERT(!attrName->Equals(attr2->NodeInfo()),
+                     "Different attrs at same position");
           return nsIDOMNode::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
             nsIDOMNode::DOCUMENT_POSITION_PRECEDING;
         }
         if (attrName->Equals(attr2->NodeInfo())) {
           return nsIDOMNode::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
             nsIDOMNode::DOCUMENT_POSITION_FOLLOWING;
         }
       }
@@ -983,18 +983,18 @@
         // Iterate over attributes.
         for (uint32_t i = 0; i < attrCount; ++i) {
           const nsAttrName* attrName = element1->GetAttrNameAt(i);
 #ifdef DEBUG
           bool hasAttr =
 #endif
           element1->GetAttr(attrName->NamespaceID(), attrName->LocalName(),
                             string1);
-          NS_ASSERTION(hasAttr, "Why don't we have an attr?");
-    
+          MOZ_ASSERT(hasAttr, "Why don't we have an attr?");
+
           if (!element2->AttrValueIs(attrName->NamespaceID(),
                                      attrName->LocalName(),
                                      string1,
                                      eCaseMatters)) {
             return false;
           }
         }
         break;
@@ -1015,33 +1015,34 @@
 
         break;
       }
       case nsIDOMNode::DOCUMENT_NODE:
       case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
         break;
       case nsIDOMNode::ATTRIBUTE_NODE:
       {
-        NS_ASSERTION(node1 == this && node2 == aOther,
-                     "Did we come upon an attribute node while walking a "
-                     "subtree?");
+        MOZ_ASSERT(node1 == this && node2 == aOther,
+                   "Did we come upon an attribute node while walking a "
+                   "subtree?");
         node1->GetNodeValue(string1);
         node2->GetNodeValue(string2);
         
         // Returning here as to not bother walking subtree. And there is no
         // risk that we're half way through walking some other subtree since
         // attribute nodes doesn't appear in subtrees.
         return string1.Equals(string2);
       }
       case nsIDOMNode::DOCUMENT_TYPE_NODE:
       {
         nsCOMPtr<nsIDOMDocumentType> docType1 = do_QueryInterface(node1);
         nsCOMPtr<nsIDOMDocumentType> docType2 = do_QueryInterface(node2);
-    
-        NS_ASSERTION(docType1 && docType2, "Why don't we have a document type node?");
+
+        MOZ_ASSERT(docType1 && docType2,
+                   "Why don't we have a document type node?");
 
         // Public ID
         docType1->GetPublicId(string1);
         docType2->GetPublicId(string2);
         if (!string1.Equals(string2)) {
           return false;
         }
     
@@ -1074,18 +1075,18 @@
       if (node2->GetFirstChild()) {
         // node2 has a firstChild, but node1 doesn't
         return false;
       }
 
       // Find next sibling, possibly walking parent chain.
       while (1) {
         if (node1 == this) {
-          NS_ASSERTION(node2 == aOther, "Should have reached the start node "
-                                        "for both trees at the same time");
+          MOZ_ASSERT(node2 == aOther, "Should have reached the start node "
+                                      "for both trees at the same time");
           return true;
         }
 
         nextNode = node1->GetNextSibling();
         if (nextNode) {
           node1 = nextNode;
           node2 = node2->GetNextSibling();
           break;
@@ -1093,17 +1094,17 @@
 
         if (node2->GetNextSibling()) {
           // node2 has a nextSibling, but node1 doesn't
           return false;
         }
         
         node1 = node1->GetParentNode();
         node2 = node2->GetParentNode();
-        NS_ASSERTION(node1 && node2, "no parent while walking subtree");
+        MOZ_ASSERT(node1 && node2, "no parent while walking subtree");
       }
     }
   } while(node2);
 
   return false;
 }
 
 void
@@ -1122,20 +1123,20 @@
 
 NS_IMETHODIMP
 nsINode::AddEventListener(const nsAString& aType,
                           nsIDOMEventListener *aListener,
                           bool aUseCapture,
                           bool aWantsUntrusted,
                           uint8_t aOptionalArgc)
 {
-  NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
-               "Won't check if this is chrome, you want to set "
-               "aWantsUntrusted to false or make the aWantsUntrusted "
-               "explicit by making aOptionalArgc non-zero.");
+  MOZ_ASSERT(!aWantsUntrusted || aOptionalArgc > 1,
+             "Won't check if this is chrome, you want to set "
+             "aWantsUntrusted to false or make the aWantsUntrusted "
+             "explicit by making aOptionalArgc non-zero.");
 
   if (!aWantsUntrusted &&
       (aOptionalArgc < 2 &&
        !nsContentUtils::IsChromeDoc(OwnerDoc()))) {
     aWantsUntrusted = true;
   }
 
   EventListenerManager* listener_manager = GetOrCreateListenerManager();
@@ -1170,20 +1171,20 @@
 
 NS_IMETHODIMP
 nsINode::AddSystemEventListener(const nsAString& aType,
                                 nsIDOMEventListener *aListener,
                                 bool aUseCapture,
                                 bool aWantsUntrusted,
                                 uint8_t aOptionalArgc)
 {
-  NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
-               "Won't check if this is chrome, you want to set "
-               "aWantsUntrusted to false or make the aWantsUntrusted "
-               "explicit by making aOptionalArgc non-zero.");
+  MOZ_ASSERT(!aWantsUntrusted || aOptionalArgc > 1,
+             "Won't check if this is chrome, you want to set "
+             "aWantsUntrusted to false or make the aWantsUntrusted "
+             "explicit by making aOptionalArgc non-zero.");
 
   if (!aWantsUntrusted &&
       (aOptionalArgc < 2 &&
        !nsContentUtils::IsChromeDoc(OwnerDoc()))) {
     aWantsUntrusted = true;
   }
 
   return NS_AddSystemEventListener(this, aType, aListener, aUseCapture,
@@ -1433,37 +1434,36 @@
     NS_ADDREF(aURI);
   }
   return rv;
 }
 
 static nsresult
 AdoptNodeIntoOwnerDoc(nsINode *aParent, nsINode *aNode)
 {
-  NS_ASSERTION(!aNode->GetParentNode(),
-               "Should have removed from parent already");
+  MOZ_ASSERT(!aNode->GetParentNode(),
+             "Should have removed from parent already");
 
   nsIDocument *doc = aParent->OwnerDoc();
 
   nsresult rv;
   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(doc, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDOMNode> adoptedNode;
   rv = domDoc->AdoptNode(node, getter_AddRefs(adoptedNode));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  NS_ASSERTION(aParent->OwnerDoc() == doc,
-               "ownerDoc chainged while adopting");
-  NS_ASSERTION(adoptedNode == node, "Uh, adopt node changed nodes?");
-  NS_ASSERTION(aParent->OwnerDoc() == aNode->OwnerDoc(),
-               "ownerDocument changed again after adopting!");
+  MOZ_ASSERT(aParent->OwnerDoc() == doc, "ownerDoc chainged while adopting");
+  MOZ_ASSERT(adoptedNode == node, "Uh, adopt node changed nodes?");
+  MOZ_ASSERT(aParent->OwnerDoc() == aNode->OwnerDoc(),
+             "ownerDocument changed again after adopting!");
 
   return NS_OK;
 }
 
 static nsresult
 CheckForOutdatedParent(nsINode* aParent, nsINode* aNode)
 {
   if (JSObject* existingObjUnrooted = aNode->GetWrapper()) {
@@ -1529,18 +1529,18 @@
     if (GetFirstChild() == aKid) {
       mFirstChild = aKid->GetNextSibling();
     }
     aChildArray.RemoveChildAt(aIndex);
     aKid->UnbindFromTree();
     return rv;
   }
 
-  NS_ASSERTION(aKid->GetParentNode() == this,
-               "Did we run script inappropriately?");
+  MOZ_ASSERT(aKid->GetParentNode() == this,
+             "Did we run script inappropriately?");
 
   if (aNotify) {
     // Note that we always want to call ContentInserted when things are added
     // as kids to documents
     if (parent && isAppend) {
       nsNodeUtils::ContentAppended(parent, aKid, aIndex);
     } else {
       nsNodeUtils::ContentInserted(this, aKid, aIndex);
@@ -1988,18 +1988,18 @@
     fragChildren.emplace();
 
     // Copy the children into a separate array to avoid having to deal with
     // mutations to the fragment later on here.
     fragChildren->SetCapacity(count);
     for (nsIContent* child = newContent->GetFirstChild();
          child;
          child = child->GetNextSibling()) {
-      NS_ASSERTION(child->GetComposedDoc() == nullptr,
-                   "How did we get a child with a current doc?");
+      MOZ_ASSERT(child->GetComposedDoc() == nullptr,
+                 "How did we get a child with a current doc?");
       fragChildren->AppendElement(child);
     }
 
     // Hold a strong ref to nodeToInsertBefore across the removals
     nsCOMPtr<nsINode> kungFuDeathGrip = nodeToInsertBefore;
 
     nsMutationGuard guard;
 
@@ -2098,22 +2098,22 @@
   }
 
   // If we're replacing and we haven't removed aRefChild yet, do so now
   if (aReplace && aRefChild != aNewChild) {
     mb.Init(this, true, true);
 
     // Since aRefChild is never null in the aReplace case, we know that at
     // this point nodeToInsertBefore is the next sibling of aRefChild.
-    NS_ASSERTION(aRefChild->GetNextSibling() == nodeToInsertBefore,
-                 "Unexpected nodeToInsertBefore");
+    MOZ_ASSERT(aRefChild->GetNextSibling() == nodeToInsertBefore,
+               "Unexpected nodeToInsertBefore");
 
     // An since nodeToInsertBefore is at index insPos, we want to remove
     // at the previous index.
-    NS_ASSERTION(insPos >= 1, "insPos too small");
+    MOZ_ASSERT(insPos >= 1, "insPos too small");
     RemoveChildAt(insPos-1, true);
     --insPos;
   }
 
   // Move new child over to our document if needed. Do this after removing
   // it from its parent so that AdoptNode doesn't fire DOMNodeRemoved
   // DocumentType nodes are the only nodes that can have a null
   // ownerDocument according to the DOM spec, and we need to allow
@@ -2440,18 +2440,17 @@
       cur->mNext = nullptr;
       delete cur;
     } else {
       slot = &cur->mNext;
     }
   } while (*slot);
 
   if (selectorList) {
-    NS_ASSERTION(selectorList->mSelectors,
-                 "How can we not have any selectors?");
+    MOZ_ASSERT(selectorList->mSelectors, "How can we not have any selectors?");
     cache.CacheList(aSelectorString, selectorList);
   } else {
     // This is the "only pseudo-element selectors" case, which is
     // not common, so just don't worry about caching it.  That way a
     // null cached value can always indicate an invalid selector.
   }
 
   return selectorList;
@@ -2535,21 +2534,21 @@
   doc->FlushPendingLinkUpdates();
   AddScopeElements(matchingContext, aRoot);
 
   // Fast-path selectors involving IDs.  We can only do this if aRoot
   // is in the document and the document is not in quirks mode, since
   // ID selectors are case-insensitive in quirks mode.  Also, only do
   // this if aSelectorList only has one selector, because otherwise
   // ordering the elements correctly is a pain.
-  NS_ASSERTION(aRoot->IsElement() || aRoot->IsNodeOfType(nsINode::eDOCUMENT) ||
+  MOZ_ASSERT(aRoot->IsElement() || aRoot->IsNodeOfType(nsINode::eDOCUMENT) ||
                !aRoot->IsInDoc(),
-               "The optimization below to check ContentIsDescendantOf only for "
-               "elements depends on aRoot being either an element or a "
-               "document if it's in the document.");
+             "The optimization below to check ContentIsDescendantOf only for "
+             "elements depends on aRoot being either an element or a "
+             "document if it's in the document.");
   if (aRoot->IsInDoc() &&
       doc->GetCompatibilityMode() != eCompatibility_NavQuirks &&
       !aSelectorList->mNext &&
       aSelectorList->mSelectors->mIDList) {
     nsIAtom* id = aSelectorList->mSelectors->mIDList->mAtom;
     SelectorMatchInfo info = { aSelectorList, matchingContext };
     FindMatchingElementsWithId<onlyFirstMatch, T>(nsDependentAtomString(id),
                                                   aRoot, &info, aList);
diff --git a/dom/base/nsINode.h b/dom/base/nsINode.h
--- a/dom/base/nsINode.h
+++ b/dom/base/nsINode.h
@@ -867,19 +867,19 @@
    * while observers are being notified, it may also be notified.  In general,
    * adding observers while inside a notification is not a good idea.  An
    * observer that is already observing the node must not be added without
    * being removed first.
    */
   void AddMutationObserver(nsIMutationObserver* aMutationObserver)
   {
     nsSlots* s = Slots();
-    NS_ASSERTION(s->mMutationObservers.IndexOf(aMutationObserver) ==
+    MOZ_ASSERT(s->mMutationObservers.IndexOf(aMutationObserver) ==
                  nsTArray<int>::NoIndex,
-                 "Observer already in the list");
+               "Observer already in the list");
     s->mMutationObservers.AppendElement(aMutationObserver);
   }
 
   /**
    * Same as above, but only adds the observer if its not observing
    * the node already.
    */
   void AddMutationObserverUnlessExists(nsIMutationObserver* aMutationObserver)
@@ -955,34 +955,32 @@
   nsSlots* DebugGetSlots()
   {
     return Slots();
   }
 #endif
 
   void SetFlags(FlagsType aFlagsToSet)
   {
-    NS_ASSERTION(!(aFlagsToSet & (NODE_IS_ANONYMOUS_ROOT |
-                                  NODE_IS_NATIVE_ANONYMOUS_ROOT |
-                                  NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE |
-                                  NODE_DESCENDANTS_NEED_FRAMES |
-                                  NODE_NEEDS_FRAME |
-                                  NODE_CHROME_ONLY_ACCESS)) ||
-                 IsNodeOfType(eCONTENT),
-                 "Flag only permitted on nsIContent nodes");
+    MOZ_ASSERT(
+      !(aFlagsToSet &
+        (NODE_IS_ANONYMOUS_ROOT | NODE_IS_NATIVE_ANONYMOUS_ROOT |
+         NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE | NODE_DESCENDANTS_NEED_FRAMES |
+         NODE_NEEDS_FRAME | NODE_CHROME_ONLY_ACCESS)) ||
+        IsNodeOfType(eCONTENT),
+      "Flag only permitted on nsIContent nodes");
     nsWrapperCache::SetFlags(aFlagsToSet);
   }
 
   void UnsetFlags(FlagsType aFlagsToUnset)
   {
-    NS_ASSERTION(!(aFlagsToUnset &
-                   (NODE_IS_ANONYMOUS_ROOT |
-                    NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE |
-                    NODE_IS_NATIVE_ANONYMOUS_ROOT)),
-                 "Trying to unset write-only flags");
+    MOZ_ASSERT(!(aFlagsToUnset &
+                 (NODE_IS_ANONYMOUS_ROOT | NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE |
+                  NODE_IS_NATIVE_ANONYMOUS_ROOT)),
+               "Trying to unset write-only flags");
     nsWrapperCache::UnsetFlags(aFlagsToUnset);
   }
 
   void SetEditableFlag(bool aEditable)
   {
     if (aEditable) {
       SetFlags(NODE_IS_EDITABLE);
     }
@@ -1222,17 +1220,17 @@
   {
     // Can't use nsContentUtils::ContentIsDescendantOf here, since we
     // can't include it here.
 #ifdef DEBUG
     if (aRoot) {
       const nsINode* cur = this;
       for (; cur; cur = cur->GetParentNode())
         if (cur == aRoot) break;
-      NS_ASSERTION(cur, "aRoot not an ancestor of |this|?");
+      MOZ_ASSERT(cur, "aRoot not an ancestor of |this|?");
     }
 #endif
     if (!aSkipChildren) {
       nsIContent* kid = GetFirstChild();
       if (kid) {
         return kid;
       }
     }
@@ -1267,17 +1265,17 @@
   {
       // Can't use nsContentUtils::ContentIsDescendantOf here, since we
       // can't include it here.
 #ifdef DEBUG
       if (aRoot) {
         const nsINode* cur = this;
         for (; cur; cur = cur->GetParentNode())
           if (cur == aRoot) break;
-        NS_ASSERTION(cur, "aRoot not an ancestor of |this|?");
+        MOZ_ASSERT(cur, "aRoot not an ancestor of |this|?");
       }
 #endif
 
     if (this == aRoot) {
       return nullptr;
     }
     nsIContent* cur = this->GetParent();
     nsIContent* iter = this->GetPreviousSibling();
@@ -1530,19 +1528,19 @@
   bool HasWeirdParserInsertionMode() const
   { return GetBoolFlag(ElementHasWeirdParserInsertionMode); }
   bool HandlingClick() const { return GetBoolFlag(NodeHandlingClick); }
   void SetHandlingClick() { SetBoolFlag(NodeHandlingClick); }
   void ClearHandlingClick() { ClearBoolFlag(NodeHandlingClick); }
 
   void SetSubtreeRootPointer(nsINode* aSubtreeRoot)
   {
-    NS_ASSERTION(aSubtreeRoot, "aSubtreeRoot can never be null!");
-    NS_ASSERTION(!(IsNodeOfType(eCONTENT) && IsInDoc()) &&
-                 !IsInShadowTree(), "Shouldn't be here!");
+    MOZ_ASSERT(aSubtreeRoot, "aSubtreeRoot can never be null!");
+    MOZ_ASSERT(!(IsNodeOfType(eCONTENT) && IsInDoc()) && !IsInShadowTree(),
+               "Shouldn't be here!");
     mSubtreeRoot = aSubtreeRoot;
   }
 
   void ClearSubtreeRootPointer()
   {
     mSubtreeRoot = nullptr;
   }
 
diff --git a/dom/base/nsImageLoadingContent.cpp b/dom/base/nsImageLoadingContent.cpp
--- a/dom/base/nsImageLoadingContent.cpp
+++ b/dom/base/nsImageLoadingContent.cpp
@@ -106,20 +106,20 @@
   // Cancel our requests so they won't hold stale refs to us
   // NB: Don't ask to discard the images here.
   ClearCurrentRequest(NS_BINDING_ABORTED, 0);
   ClearPendingRequest(NS_BINDING_ABORTED, 0);
 }
 
 nsImageLoadingContent::~nsImageLoadingContent()
 {
-  NS_ASSERTION(!mCurrentRequest && !mPendingRequest,
-               "DestroyImageLoadingContent not called");
-  NS_ASSERTION(!mObserverList.mObserver && !mObserverList.mNext,
-               "Observers still registered?");
+  MOZ_ASSERT(!mCurrentRequest && !mPendingRequest,
+             "DestroyImageLoadingContent not called");
+  MOZ_ASSERT(!mObserverList.mObserver && !mObserverList.mNext,
+             "Observers still registered?");
 }
 
 /*
  * imgINotificationObserver impl
  */
 NS_IMETHODIMP
 nsImageLoadingContent::Notify(imgIRequest* aRequest,
                               int32_t aType,
@@ -491,17 +491,17 @@
   *aRequest = GetRequest(aRequestType, result).take();
 
   return result.ErrorCode();
 }
 
 NS_IMETHODIMP_(void)
 nsImageLoadingContent::FrameCreated(nsIFrame* aFrame)
 {
-  NS_ASSERTION(aFrame, "aFrame is null");
+  MOZ_ASSERT(aFrame, "aFrame is null");
 
   mFrameCreateCalled = true;
 
   if (aFrame->HasAnyStateBits(NS_FRAME_IN_POPUP)) {
     // Assume all images in popups are visible.
     IncrementVisibleCount();
   }
 
@@ -520,17 +520,17 @@
     nsLayoutUtils::RegisterImageRequestIfAnimated(presContext, mPendingRequest,
                                                   &mPendingRequestRegistered);
   }
 }
 
 NS_IMETHODIMP_(void)
 nsImageLoadingContent::FrameDestroyed(nsIFrame* aFrame)
 {
-  NS_ASSERTION(aFrame, "aFrame is null");
+  MOZ_ASSERT(aFrame, "aFrame is null");
 
   mFrameCreateCalled = false;
 
   // We need to make sure that our image request is deregistered.
   nsPresContext* presContext = GetFramePresContext();
   if (mCurrentRequest) {
     nsLayoutUtils::DeregisterImageRequest(presContext,
                                           mCurrentRequest,
@@ -719,22 +719,22 @@
   ForceReload(notify, result);
   return result.ErrorCode();
 }
 
 NS_IMETHODIMP
 nsImageLoadingContent::BlockOnload(imgIRequest* aRequest)
 {
   if (aRequest == mCurrentRequest) {
-    NS_ASSERTION(!(mCurrentRequestFlags & REQUEST_BLOCKS_ONLOAD),
-                 "Double BlockOnload!?");
+    MOZ_ASSERT(!(mCurrentRequestFlags & REQUEST_BLOCKS_ONLOAD),
+               "Double BlockOnload!?");
     mCurrentRequestFlags |= REQUEST_BLOCKS_ONLOAD;
   } else if (aRequest == mPendingRequest) {
-    NS_ASSERTION(!(mPendingRequestFlags & REQUEST_BLOCKS_ONLOAD),
-                 "Double BlockOnload!?");
+    MOZ_ASSERT(!(mPendingRequestFlags & REQUEST_BLOCKS_ONLOAD),
+               "Double BlockOnload!?");
     mPendingRequestFlags |= REQUEST_BLOCKS_ONLOAD;
   } else {
     return NS_OK;
   }
 
   nsIDocument* doc = GetOurCurrentDoc();
   if (doc) {
     doc->BlockOnload();
@@ -742,22 +742,22 @@
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImageLoadingContent::UnblockOnload(imgIRequest* aRequest)
 {
   if (aRequest == mCurrentRequest) {
-    NS_ASSERTION(mCurrentRequestFlags & REQUEST_BLOCKS_ONLOAD,
-                 "Double UnblockOnload!?");
+    MOZ_ASSERT(mCurrentRequestFlags & REQUEST_BLOCKS_ONLOAD,
+               "Double UnblockOnload!?");
     mCurrentRequestFlags &= ~REQUEST_BLOCKS_ONLOAD;
   } else if (aRequest == mPendingRequest) {
-    NS_ASSERTION(mPendingRequestFlags & REQUEST_BLOCKS_ONLOAD,
-                 "Double UnblockOnload!?");
+    MOZ_ASSERT(mPendingRequestFlags & REQUEST_BLOCKS_ONLOAD,
+               "Double UnblockOnload!?");
     mPendingRequestFlags &= ~REQUEST_BLOCKS_ONLOAD;
   } else {
     return NS_OK;
   }
 
   nsIDocument* doc = GetOurCurrentDoc();
   if (doc) {
     doc->UnblockOnload(false);
@@ -774,17 +774,17 @@
     TrackImage(mCurrentRequest);
     TrackImage(mPendingRequest);
   }
 }
 
 void
 nsImageLoadingContent::DecrementVisibleCount()
 {
-  NS_ASSERTION(mVisibleCount > 0, "visible count should be positive here");
+  MOZ_ASSERT(mVisibleCount > 0, "visible count should be positive here");
   mVisibleCount--;
 
   if (mVisibleCount == 0) {
     UntrackImage(mCurrentRequest);
     UntrackImage(mPendingRequest);
   }
 }
 
@@ -849,18 +849,18 @@
 {
   if (!mLoadingEnabled) {
     // XXX Why fire an error here? seems like the callers to SetLoadingEnabled
     // don't want/need it.
     FireEvent(NS_LITERAL_STRING("error"));
     return NS_OK;
   }
 
-  NS_ASSERTION(!aDocument || aDocument == GetOurOwnerDoc(),
-               "Bogus document passed in");
+  MOZ_ASSERT(!aDocument || aDocument == GetOurOwnerDoc(),
+             "Bogus document passed in");
   // First, get a document (needed for security checks and the like)
   if (!aDocument) {
     aDocument = GetOurOwnerDoc();
     if (!aDocument) {
       // No reason to bother, I think...
       return NS_OK;
     }
   }
@@ -1083,17 +1083,17 @@
     nsresult rv = mCurrentRequest->GetImageStatus(&currentLoadStatus);
     if (NS_FAILED(rv) || (currentLoadStatus & imgIRequest::STATUS_ERROR)) {
       mBroken = true;
     } else if (!(currentLoadStatus & imgIRequest::STATUS_SIZE_AVAILABLE)) {
       mLoading = true;
     }
   }
 
-  NS_ASSERTION(thisContent->IsElement(), "Not an element?");
+  MOZ_ASSERT(thisContent->IsElement(), "Not an element?");
   thisContent->AsElement()->UpdateState(aNotify);
 }
 
 void
 nsImageLoadingContent::CancelImageRequests(bool aNotify)
 {
   AutoStateChanger changer(this, aNotify);
   ClearPendingRequest(NS_BINDING_ABORTED, REQUEST_DISCARD);
@@ -1168,17 +1168,17 @@
                                    nsIDocument* aDocument,
                                    nsIURI** aURI)
 {
   NS_PRECONDITION(aDocument, "Must have a document");
   NS_PRECONDITION(aURI, "Null out param");
 
   // (1) Get the base URI
   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "An image loading content must be an nsIContent");
+  MOZ_ASSERT(thisContent, "An image loading content must be an nsIContent");
   nsCOMPtr<nsIURI> baseURL = thisContent->GetBaseURI();
 
   // (2) Get the charset
   const nsAFlatCString &charset = aDocument->GetDocumentCharacterSet();
 
   // (3) Construct the silly thing
   return NS_NewURI(aURI,
                    aSpec,
diff --git a/dom/base/nsInProcessTabChildGlobal.cpp b/dom/base/nsInProcessTabChildGlobal.cpp
--- a/dom/base/nsInProcessTabChildGlobal.cpp
+++ b/dom/base/nsInProcessTabChildGlobal.cpp
@@ -287,20 +287,20 @@
     aVisitor.mParentTarget = mOwner;
   }
 
 #ifdef DEBUG
   if (mOwner) {
     nsCOMPtr<nsIFrameLoaderOwner> owner = do_QueryInterface(mOwner);
     nsRefPtr<nsFrameLoader> fl = owner->GetFrameLoader();
     if (fl) {
-      NS_ASSERTION(this == fl->GetTabChildGlobalAsEventTarget(),
-                   "Wrong event target!");
-      NS_ASSERTION(fl->mMessageManager == mChromeMessageManager,
-                   "Wrong message manager!");
+      MOZ_ASSERT(this == fl->GetTabChildGlobalAsEventTarget(),
+                 "Wrong event target!");
+      MOZ_ASSERT(fl->mMessageManager == mChromeMessageManager,
+                 "Wrong message manager!");
     }
   }
 #endif
 
   return NS_OK;
 }
 
 nsresult
diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -664,18 +664,18 @@
 // QueryInterface implementation for nsJSContext
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsJSContext)
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSContext)
   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mWindowProxy)
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsJSContext)
-  NS_ASSERTION(!tmp->mContext || !js::ContextHasOutstandingRequests(tmp->mContext),
-               "Trying to unlink a context with outstanding requests.");
+MOZ_ASSERT(!tmp->mContext || !js::ContextHasOutstandingRequests(tmp->mContext),
+           "Trying to unlink a context with outstanding requests.");
   tmp->mIsInitialized = false;
   tmp->mGCOnDestruction = false;
   tmp->mWindowProxy = nullptr;
   tmp->DestroyJSContext();
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mGlobalObjectRef)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(nsJSContext)
   NS_IMPL_CYCLE_COLLECTION_DESCRIBE(nsJSContext, tmp->GetCCRefcnt())
@@ -861,18 +861,18 @@
         rv = AddSupportsPrimitiveTojsvals(arg, thisVal.address());
         if (rv == NS_ERROR_NO_INTERFACE) {
           // something else - probably an event object or similar -
           // just wrap it.
 #ifdef DEBUG
           // but first, check its not another nsISupportsPrimitive, as
           // these are now deprecated for use with script contexts.
           nsCOMPtr<nsISupportsPrimitive> prim(do_QueryInterface(arg));
-          NS_ASSERTION(prim == nullptr,
-                       "Don't pass nsISupportsPrimitives - use nsIVariant!");
+          MOZ_ASSERT(prim == nullptr,
+                     "Don't pass nsISupportsPrimitives - use nsIVariant!");
 #endif
           JSAutoCompartment ac(cx, aScope);
           rv = nsContentUtils::WrapNative(cx, arg, thisVal);
         }
       }
     }
   } else {
     nsCOMPtr<nsIVariant> variant = do_QueryInterface(aArgs);
@@ -2139,17 +2139,17 @@
   observerService->NotifyObservers(nullptr, "garbage-collection-statistics", toSend);
 
   return NS_OK;
 }
 
 static void
 DOMGCSliceCallback(JSRuntime *aRt, JS::GCProgress aProgress, const JS::GCDescription &aDesc)
 {
-  NS_ASSERTION(NS_IsMainThread(), "GCs must run on the main thread");
+  MOZ_ASSERT(NS_IsMainThread(), "GCs must run on the main thread");
 
   switch (aProgress) {
     case JS::GC_CYCLE_BEGIN: {
       // Prevent cycle collections and shrinking during incremental GC.
       sCCLockedOut = true;
 
       nsJSContext::KillShrinkGCBuffersTimer();
 
diff --git a/dom/base/nsJSTimeoutHandler.cpp b/dom/base/nsJSTimeoutHandler.cpp
--- a/dom/base/nsJSTimeoutHandler.cpp
+++ b/dom/base/nsJSTimeoutHandler.cpp
@@ -376,17 +376,17 @@
   }
   *aInterval = interval;
   return NS_OK;
 }
 
 const char16_t *
 nsJSScriptTimeoutHandler::GetHandlerText()
 {
-  NS_ASSERTION(!mFunction, "No expression, so no handler text!");
+  MOZ_ASSERT(!mFunction, "No expression, so no handler text!");
   return mExpr.get();
 }
 
 nsresult NS_CreateJSTimeoutHandler(nsGlobalWindow *aWindow,
                                    bool *aIsInterval,
                                    int32_t *aInterval,
                                    nsIScriptTimeoutHandler **aRet)
 {
diff --git a/dom/base/nsLineBreaker.cpp b/dom/base/nsLineBreaker.cpp
--- a/dom/base/nsLineBreaker.cpp
+++ b/dom/base/nsLineBreaker.cpp
@@ -17,17 +17,18 @@
     mCurrentWordContainsComplexChar(false),
     mAfterBreakableSpace(false), mBreakHere(false),
     mWordBreak(nsILineBreaker::kWordBreak_Normal)
 {
 }
 
 nsLineBreaker::~nsLineBreaker()
 {
-  NS_ASSERTION(mCurrentWord.Length() == 0, "Should have Reset() before destruction!");
+  MOZ_ASSERT(mCurrentWord.Length() == 0,
+             "Should have Reset() before destruction!");
 }
 
 static void
 SetupCapitalization(const char16_t* aWord, uint32_t aLength,
                     bool* aCapitalization)
 {
   // Capitalize the first alphanumeric character after a space or start
   // of the word.
@@ -96,17 +97,17 @@
                             mCurrentWord.Elements() + length,
                             breakState.Elements());
     }
   }
 
   uint32_t offset = 0;
   for (i = 0; i < mTextItems.Length(); ++i) {
     TextItem* ti = &mTextItems[i];
-    NS_ASSERTION(ti->mLength > 0, "Zero length word contribution?");
+    MOZ_ASSERT(ti->mLength > 0, "Zero length word contribution?");
 
     if ((ti->mFlags & BREAK_SUPPRESS_INITIAL) && ti->mSinkOffset == 0) {
       breakState[offset] = gfxTextRun::CompressedGlyph::FLAG_BREAK_TYPE_NONE;
     }
     if (ti->mFlags & BREAK_SUPPRESS_INSIDE) {
       uint32_t exclude = ti->mSinkOffset == 0 ? 1 : 0;
       memset(breakState.Elements() + offset + exclude,
              gfxTextRun::CompressedGlyph::FLAG_BREAK_TYPE_NONE,
@@ -144,23 +145,23 @@
   mCurrentWordLanguage = nullptr;
   return NS_OK;
 }
 
 nsresult
 nsLineBreaker::AppendText(nsIAtom* aHyphenationLanguage, const char16_t* aText, uint32_t aLength,
                           uint32_t aFlags, nsILineBreakSink* aSink)
 {
-  NS_ASSERTION(aLength > 0, "Appending empty text...");
+  MOZ_ASSERT(aLength > 0, "Appending empty text...");
 
   uint32_t offset = 0;
 
   // Continue the current word
   if (mCurrentWord.Length() > 0) {
-    NS_ASSERTION(!mAfterBreakableSpace && !mBreakHere, "These should not be set");
+    MOZ_ASSERT(!mAfterBreakableSpace && !mBreakHere, "These should not be set");
 
     while (offset < aLength && !IsSpace(aText[offset])) {
       mCurrentWord.AppendElement(aText[offset]);
       if (!mCurrentWordContainsComplexChar && IsComplexChar(aText[offset])) {
         mCurrentWordContainsComplexChar = true;
       }
       UpdateCurrentWordLanguage(aHyphenationLanguage);
       ++offset;
@@ -312,31 +313,31 @@
     }
   }
 }
 
 nsresult
 nsLineBreaker::AppendText(nsIAtom* aHyphenationLanguage, const uint8_t* aText, uint32_t aLength,
                           uint32_t aFlags, nsILineBreakSink* aSink)
 {
-  NS_ASSERTION(aLength > 0, "Appending empty text...");
+  MOZ_ASSERT(aLength > 0, "Appending empty text...");
 
   if (aFlags & (BREAK_NEED_CAPITALIZATION | BREAK_USE_AUTO_HYPHENATION)) {
     // Defer to the Unicode path if capitalization or hyphenation is required
     nsAutoString str;
     const char* cp = reinterpret_cast<const char*>(aText);
     CopyASCIItoUTF16(nsDependentCSubstring(cp, cp + aLength), str);
     return AppendText(aHyphenationLanguage, str.get(), aLength, aFlags, aSink);
   }
 
   uint32_t offset = 0;
 
   // Continue the current word
   if (mCurrentWord.Length() > 0) {
-    NS_ASSERTION(!mAfterBreakableSpace && !mBreakHere, "These should not be set");
+    MOZ_ASSERT(!mAfterBreakableSpace && !mBreakHere, "These should not be set");
 
     while (offset < aLength && !IsSpace(aText[offset])) {
       mCurrentWord.AppendElement(aText[offset]);
       if (!mCurrentWordContainsComplexChar &&
           IsComplexASCIIChar(aText[offset])) {
         mCurrentWordContainsComplexChar = true;
       }
       ++offset;
diff --git a/dom/base/nsLocation.cpp b/dom/base/nsLocation.cpp
--- a/dom/base/nsLocation.cpp
+++ b/dom/base/nsLocation.cpp
@@ -221,17 +221,17 @@
   if (aGetInnermostURI) {
     nsCOMPtr<nsIJARURI> jarURI(do_QueryInterface(uri));
     while (jarURI) {
       jarURI->GetJARFile(getter_AddRefs(uri));
       jarURI = do_QueryInterface(uri);
     }
   }
 
-  NS_ASSERTION(uri, "nsJARURI screwed up?");
+  MOZ_ASSERT(uri, "nsJARURI screwed up?");
 
   nsCOMPtr<nsIURIFixup> urifixup(do_GetService(NS_URIFIXUP_CONTRACTID, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
   return urifixup->CreateExposableURI(uri, aURI);
 }
 
 nsresult
diff --git a/dom/base/nsMappedAttributes.cpp b/dom/base/nsMappedAttributes.cpp
--- a/dom/base/nsMappedAttributes.cpp
+++ b/dom/base/nsMappedAttributes.cpp
@@ -24,17 +24,17 @@
 {
 }
 
 nsMappedAttributes::nsMappedAttributes(const nsMappedAttributes& aCopy)
   : mAttrCount(aCopy.mAttrCount),
     mSheet(aCopy.mSheet),
     mRuleMapper(aCopy.mRuleMapper)
 {
-  NS_ASSERTION(mBufferSize >= aCopy.mAttrCount, "can't fit attributes");
+  MOZ_ASSERT(mBufferSize >= aCopy.mAttrCount, "can't fit attributes");
 
   uint32_t i;
   for (i = 0; i < mAttrCount; ++i) {
     new (&Attrs()[i]) InternalAttr(aCopy.Attrs()[i]);
   }
 }
 
 nsMappedAttributes::~nsMappedAttributes()
@@ -56,17 +56,17 @@
   uint32_t extra = aWillAddAttr ? 1 : 0;
 
   // This will call the overridden operator new
   return new (mAttrCount + extra) nsMappedAttributes(*this);
 }
 
 void* nsMappedAttributes::operator new(size_t aSize, uint32_t aAttrCount) CPP_THROW_NEW
 {
-  NS_ASSERTION(aAttrCount > 0, "zero-attribute nsMappedAttributes requested");
+  MOZ_ASSERT(aAttrCount > 0, "zero-attribute nsMappedAttributes requested");
 
   // aSize will include the mAttrs buffer so subtract that.
   void* newAttrs = ::operator new(aSize - sizeof(void*[1]) +
                                   aAttrCount * sizeof(InternalAttr));
 
 #ifdef DEBUG
   static_cast<nsMappedAttributes*>(newAttrs)->mBufferSize = aAttrCount;
 #endif
@@ -86,17 +86,17 @@
   for (i = 0; i < mAttrCount && !Attrs()[i].mName.IsSmaller(aAttrName); ++i) {
     if (Attrs()[i].mName.Equals(aAttrName)) {
       Attrs()[i].mValue.Reset();
       Attrs()[i].mValue.SwapValueWith(aValue);
       return;
     }
   }
 
-  NS_ASSERTION(mBufferSize >= mAttrCount + 1, "can't fit attributes");
+  MOZ_ASSERT(mBufferSize >= mAttrCount + 1, "can't fit attributes");
 
   if (mAttrCount != i) {
     memmove(&Attrs()[i + 1], &Attrs()[i], (mAttrCount - i) * sizeof(InternalAttr));
   }
 
   new (&Attrs()[i].mName) nsAttrName(aAttrName);
   new (&Attrs()[i].mValue) nsAttrValue();
   Attrs()[i].mValue.SwapValueWith(aValue);
@@ -249,18 +249,18 @@
   }
 
   return -1;
 }
 
 size_t
 nsMappedAttributes::SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const
 {
-  NS_ASSERTION(mAttrCount == mBufferSize,
-               "mBufferSize and mAttrCount are expected to be the same.");
+  MOZ_ASSERT(mAttrCount == mBufferSize,
+             "mBufferSize and mAttrCount are expected to be the same.");
 
   size_t n = aMallocSizeOf(this);
   for (uint16_t i = 0; i < mAttrCount; ++i) {
     n += Attrs()[i].mValue.SizeOfExcludingThis(aMallocSizeOf);
   }
   return n;
 }
 
diff --git a/dom/base/nsMappedAttributes.h b/dom/base/nsMappedAttributes.h
--- a/dom/base/nsMappedAttributes.h
+++ b/dom/base/nsMappedAttributes.h
@@ -52,22 +52,22 @@
   void SetStyleSheet(nsHTMLStyleSheet* aSheet);
   nsHTMLStyleSheet* GetStyleSheet()
   {
     return mSheet;
   }
 
   const nsAttrName* NameAt(uint32_t aPos) const
   {
-    NS_ASSERTION(aPos < mAttrCount, "out-of-bounds");
+    MOZ_ASSERT(aPos < mAttrCount, "out-of-bounds");
     return &Attrs()[aPos].mName;
   }
   const nsAttrValue* AttrAt(uint32_t aPos) const
   {
-    NS_ASSERTION(aPos < mAttrCount, "out-of-bounds");
+    MOZ_ASSERT(aPos < mAttrCount, "out-of-bounds");
     return &Attrs()[aPos].mValue;
   }
   // Remove the attr at position aPos.  The value of the attr is placed in
   // aValue; any value that was already in aValue is destroyed.
   void RemoveAttrAt(uint32_t aPos, nsAttrValue& aValue);
   const nsAttrName* GetExistingAttrNameFromQName(const nsAString& aName) const;
   int32_t IndexOfAttr(nsIAtom* aLocalName) const;
   
diff --git a/dom/base/nsNameSpaceManager.cpp b/dom/base/nsNameSpaceManager.cpp
--- a/dom/base/nsNameSpaceManager.cpp
+++ b/dom/base/nsNameSpaceManager.cpp
@@ -178,19 +178,19 @@
 
 nsresult nsNameSpaceManager::AddNameSpace(const nsAString& aURI,
                                           const int32_t aNameSpaceID)
 {
   if (aNameSpaceID < 0) {
     // We've wrapped...  Can't do anything else here; just bail.
     return NS_ERROR_OUT_OF_MEMORY;
   }
-  
-  NS_ASSERTION(aNameSpaceID - 1 == (int32_t) mURIArray.Length(),
-               "BAD! AddNameSpace not called in right order!");
+
+  MOZ_ASSERT(aNameSpaceID - 1 == (int32_t)mURIArray.Length(),
+             "BAD! AddNameSpace not called in right order!");
 
   nsString* uri = new nsString(aURI);
   if (!uri || !mURIArray.AppendElement(uri)) {
     delete uri;
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   mURIToIDTable.Put(uri, aNameSpaceID);
diff --git a/dom/base/nsNodeInfoManager.cpp b/dom/base/nsNodeInfoManager.cpp
--- a/dom/base/nsNodeInfoManager.cpp
+++ b/dom/base/nsNodeInfoManager.cpp
@@ -222,17 +222,17 @@
 {
   if (mBindingManager) {
     mBindingManager->DropDocumentReference();
   }
 
   // This is probably not needed anymore.
   PL_HashTableEnumerateEntries(mNodeInfoHash, DropNodeInfoDocument, nullptr);
 
-  NS_ASSERTION(!mNonDocumentNodeInfos, "Shouldn't have non-document nodeinfos!");
+  MOZ_ASSERT(!mNonDocumentNodeInfos, "Shouldn't have non-document nodeinfos!");
   mDocument = nullptr;
 }
 
 
 already_AddRefed<mozilla::dom::NodeInfo>
 nsNodeInfoManager::GetNodeInfo(nsIAtom *aName, nsIAtom *aPrefix,
                                int32_t aNamespaceID, uint16_t aNodeType,
                                nsIAtom* aExtraName /* = nullptr */)
@@ -368,17 +368,17 @@
 }
 
 already_AddRefed<NodeInfo>
 nsNodeInfoManager::GetDocumentNodeInfo()
 {
   nsRefPtr<NodeInfo> nodeInfo;
 
   if (!mDocumentNodeInfo) {
-    NS_ASSERTION(mDocument, "Should have mDocument!");
+    MOZ_ASSERT(mDocument, "Should have mDocument!");
     nodeInfo = GetNodeInfo(nsGkAtoms::documentNodeName, nullptr,
                            kNameSpaceID_None, nsIDOMNode::DOCUMENT_NODE,
                            nullptr);
     // Hold a weak ref; the nodeinfo will let us know when it goes away
     mDocumentNodeInfo = nodeInfo;
 
     --mNonDocumentNodeInfos;
     if (!mNonDocumentNodeInfos) {
@@ -395,17 +395,17 @@
 void
 nsNodeInfoManager::SetDocumentPrincipal(nsIPrincipal *aPrincipal)
 {
   mPrincipal = nullptr;
   if (!aPrincipal) {
     aPrincipal = mDefaultPrincipal;
   }
 
-  NS_ASSERTION(aPrincipal, "Must have principal by this point!");
+  MOZ_ASSERT(aPrincipal, "Must have principal by this point!");
 
   mPrincipal = aPrincipal;
 }
 
 void
 nsNodeInfoManager::RemoveNodeInfo(NodeInfo *aNodeInfo)
 {
   NS_PRECONDITION(aNodeInfo, "Trying to remove null nodeinfo from manager!");
diff --git a/dom/base/nsNodeInfoManager.h b/dom/base/nsNodeInfoManager.h
--- a/dom/base/nsNodeInfoManager.h
+++ b/dom/base/nsNodeInfoManager.h
@@ -91,17 +91,17 @@
   {
     return mDocument;
   }
 
   /**
    * Gets the principal of the document this nodeinfo manager belongs to.
    */
   nsIPrincipal *DocumentPrincipal() const {
-    NS_ASSERTION(mPrincipal, "How'd that happen?");
+    MOZ_ASSERT(mPrincipal, "How'd that happen?");
     return mPrincipal;
   }
 
   void RemoveNodeInfo(mozilla::dom::NodeInfo *aNodeInfo);
 
   nsBindingManager* GetBindingManager() const
   {
     return mBindingManager;
diff --git a/dom/base/nsNodeUtils.cpp b/dom/base/nsNodeUtils.cpp
--- a/dom/base/nsNodeUtils.cpp
+++ b/dom/base/nsNodeUtils.cpp
@@ -33,46 +33,44 @@
 #include "mozilla/dom/ShadowRoot.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 using mozilla::AutoJSContext;
 
 // This macro expects the ownerDocument of content_ to be in scope as
 // |nsIDocument* doc|
-#define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)      \
-  PR_BEGIN_MACRO                                                  \
-  bool needsEnterLeave = doc->MayHaveDOMMutationObservers();      \
-  if (needsEnterLeave) {                                          \
-    nsDOMMutationObserver::EnterMutationHandling();               \
-  }                                                               \
-  nsINode* node = content_;                                       \
-  NS_ASSERTION(node->OwnerDoc() == doc, "Bogus document");        \
-  if (doc) {                                                      \
-    doc->BindingManager()->func_ params_;                         \
-  }                                                               \
-  do {                                                            \
-    nsINode::nsSlots* slots = node->GetExistingSlots();           \
-    if (slots && !slots->mMutationObservers.IsEmpty()) {          \
-      /* No need to explicitly notify the first observer first    \
-         since that'll happen anyway. */                          \
-      NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(                         \
-        slots->mMutationObservers, nsIMutationObserver,           \
-        func_, params_);                                          \
-    }                                                             \
-    ShadowRoot* shadow = ShadowRoot::FromNode(node);              \
-    if (shadow) {                                                 \
-      node = shadow->GetPoolHost();                               \
-    } else {                                                      \
-      node = node->GetParentNode();                               \
-    }                                                             \
-  } while (node);                                                 \
-  if (needsEnterLeave) {                                          \
-    nsDOMMutationObserver::LeaveMutationHandling();               \
-  }                                                               \
+#define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)                   \
+  PR_BEGIN_MACRO bool needsEnterLeave = doc->MayHaveDOMMutationObservers();    \
+  if (needsEnterLeave) {                                                       \
+    nsDOMMutationObserver::EnterMutationHandling();                            \
+  }                                                                            \
+  nsINode* node = content_;                                                    \
+  MOZ_ASSERT(node->OwnerDoc() == doc, "Bogus document");                       \
+  if (doc) {                                                                   \
+    doc->BindingManager()->func_ params_;                                      \
+  }                                                                            \
+  do {                                                                         \
+    nsINode::nsSlots* slots = node->GetExistingSlots();                        \
+    if (slots && !slots->mMutationObservers.IsEmpty()) {                       \
+      /* No need to explicitly notify the first observer first                 \
+         since that'll happen anyway. */                                       \
+      NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(slots->mMutationObservers,            \
+                                         nsIMutationObserver, func_, params_); \
+    }                                                                          \
+    ShadowRoot* shadow = ShadowRoot::FromNode(node);                           \
+    if (shadow) {                                                              \
+      node = shadow->GetPoolHost();                                            \
+    } else {                                                                   \
+      node = node->GetParentNode();                                            \
+    }                                                                          \
+  } while (node);                                                              \
+  if (needsEnterLeave) {                                                       \
+    nsDOMMutationObserver::LeaveMutationHandling();                            \
+  }                                                                            \
   PR_END_MACRO
 
 void
 nsNodeUtils::CharacterDataWillChange(nsIContent* aContent,
                                      CharacterDataChangeInfo* aInfo)
 {
   nsIDocument* doc = aContent->OwnerDoc();
   IMPL_MUTATION_NOTIFICATION(CharacterDataWillChange, aContent,
@@ -248,19 +246,19 @@
     aNode->UnsetFlags(NODE_HAS_LISTENERMANAGER);
   }
 
   if (aNode->IsElement()) {
     nsIDocument* ownerDoc = aNode->OwnerDoc();
     Element* elem = aNode->AsElement();
     ownerDoc->ClearBoxObjectFor(elem);
 
-    NS_ASSERTION(aNode->HasFlag(NODE_FORCE_XBL_BINDINGS) ||
+    MOZ_ASSERT(aNode->HasFlag(NODE_FORCE_XBL_BINDINGS) ||
                  !elem->GetXBLBinding(),
-                 "Non-forced node has binding on destruction");
+               "Non-forced node has binding on destruction");
 
     // if NODE_FORCE_XBL_BINDINGS is set, the node might still have a binding
     // attached
     if (aNode->HasFlag(NODE_FORCE_XBL_BINDINGS) &&
         ownerDoc->BindingManager()) {
       ownerDoc->BindingManager()->RemovedFromDocument(elem, ownerDoc);
     }
   }
@@ -556,17 +554,17 @@
   return NS_OK;
 }
 
 
 /* static */
 void
 nsNodeUtils::UnlinkUserData(nsINode *aNode)
 {
-  NS_ASSERTION(aNode->HasProperties(), "Call to UnlinkUserData not needed.");
+  MOZ_ASSERT(aNode->HasProperties(), "Call to UnlinkUserData not needed.");
 
   // Strong reference to the document so that deleting properties can't
   // delete the document.
   nsCOMPtr<nsIDocument> document = aNode->OwnerDoc();
   document->PropertyTable(DOM_USER_DATA)->DeleteAllPropertiesFor(aNode);
 }
 
 bool
diff --git a/dom/base/nsObjectLoadingContent.cpp b/dom/base/nsObjectLoadingContent.cpp
--- a/dom/base/nsObjectLoadingContent.cpp
+++ b/dom/base/nsObjectLoadingContent.cpp
@@ -351,18 +351,18 @@
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   nsStopPluginRunnable(nsPluginInstanceOwner* aInstanceOwner,
                        nsObjectLoadingContent* aContent)
     : mInstanceOwner(aInstanceOwner)
     , mContent(aContent)
   {
-    NS_ASSERTION(aInstanceOwner, "need an owner");
-    NS_ASSERTION(aContent, "need a nsObjectLoadingContent");
+    MOZ_ASSERT(aInstanceOwner, "need an owner");
+    MOZ_ASSERT(aContent, "need a nsObjectLoadingContent");
   }
 
   // nsRunnable
   NS_IMETHOD Run() MOZ_OVERRIDE;
 
   // nsITimerCallback
   NS_IMETHOD Notify(nsITimer* timer) MOZ_OVERRIDE;
 
@@ -593,17 +593,17 @@
     NS_NOTREACHED("expecting a spawned plugin");
     return false;
   }
   nsRefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
   if (!pluginHost) {
     NS_NOTREACHED("No pluginHost");
     return false;
   }
-  NS_ASSERTION(!mFinalListener, "overwriting a final listener");
+  MOZ_ASSERT(!mFinalListener, "overwriting a final listener");
   nsresult rv;
   nsRefPtr<nsNPAPIPluginInstance> inst;
   nsCOMPtr<nsIStreamListener> finalListener;
   rv = mInstanceOwner->GetInstance(getter_AddRefs(inst));
   NS_ENSURE_SUCCESS(rv, false);
   rv = pluginHost->NewPluginStreamListener(mURI, inst,
                                            getter_AddRefs(finalListener));
   NS_ENSURE_SUCCESS(rv, false);
@@ -612,17 +612,17 @@
 }
 
 
 bool
 nsObjectLoadingContent::IsSupportedDocument(const nsCString& aMimeType)
 {
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "must be a content");
+  MOZ_ASSERT(thisContent, "must be a content");
 
   nsCOMPtr<nsIWebNavigationInfo> info(
     do_GetService(NS_WEBNAVIGATION_INFO_CONTRACTID));
   if (!info) {
     return false;
   }
 
   nsCOMPtr<nsIWebNavigation> webNav;
@@ -735,18 +735,18 @@
 nsresult
 nsObjectLoadingContent::InstantiatePluginInstance(bool aIsLoading)
 {
   if (mInstanceOwner || mType != eType_Plugin || (mIsLoading != aIsLoading) ||
       mInstantiating) {
     // If we hit this assertion it's probably because LoadObject re-entered :(
     //
     // XXX(johns): This hackiness will go away in bug 767635
-    NS_ASSERTION(mIsLoading || !aIsLoading,
-                 "aIsLoading should only be true inside LoadObject");
+    MOZ_ASSERT(mIsLoading || !aIsLoading,
+               "aIsLoading should only be true inside LoadObject");
     return NS_OK;
   }
 
   mInstantiating = true;
   AutoSetInstantiatingToFalse autoInstantiating(this);
 
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent *>(this));
@@ -861,17 +861,17 @@
       }
     }
 
     // If we have a URI but didn't open a channel yet (eAllowPluginSkipChannel)
     // or we did load with a channel but are re-instantiating, re-open the
     // channel. OpenChannel() performs security checks, and this plugin has
     // already passed content policy in LoadObject.
     if ((mURI && !mChannelLoaded) || (mChannelLoaded && !aIsLoading)) {
-      NS_ASSERTION(!mChannel, "should not have an existing channel here");
+      MOZ_ASSERT(!mChannel, "should not have an existing channel here");
       // We intentionally ignore errors here, leaving it up to the plugin to
       // deal with not having an initial stream.
       OpenChannel();
     }
   }
 
   nsCOMPtr<nsIRunnable> ev = \
     new nsSimplePluginEvent(thisContent,
@@ -1086,23 +1086,23 @@
     }
   }
 
   // Otherwise we should be state loading, and call LoadObject with the channel
   if (mType != eType_Loading) {
     NS_NOTREACHED("Should be type loading at this point");
     return NS_BINDING_ABORTED;
   }
-  NS_ASSERTION(!mChannelLoaded, "mChannelLoaded set already?");
-  NS_ASSERTION(!mFinalListener, "mFinalListener exists already?");
+  MOZ_ASSERT(!mChannelLoaded, "mChannelLoaded set already?");
+  MOZ_ASSERT(!mFinalListener, "mFinalListener exists already?");
 
   mChannelLoaded = true;
 
   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
-  NS_ASSERTION(chan, "Why is our request not a channel?");
+  MOZ_ASSERT(chan, "Why is our request not a channel?");
 
   nsCOMPtr<nsIURI> uri;
 
   if (IsSuccessfulRequest(aRequest)) {
     chan->GetURI(getter_AddRefs(uri));
   }
 
   if (!uri) {
@@ -1420,18 +1420,17 @@
 bool
 nsObjectLoadingContent::CheckJavaCodebase()
 {
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
   nsCOMPtr<nsIScriptSecurityManager> secMan =
     nsContentUtils::GetSecurityManager();
   nsCOMPtr<nsINetUtil> netutil = do_GetNetUtil();
-  NS_ASSERTION(thisContent && secMan && netutil, "expected interfaces");
-
+  MOZ_ASSERT(thisContent && secMan && netutil, "expected interfaces");
 
   // Note that mBaseURI is this tag's requested base URI, not the codebase of
   // the document for security purposes
   nsresult rv = secMan->CheckLoadURIWithPrincipal(thisContent->NodePrincipal(),
                                                   mBaseURI, 0);
   if (NS_FAILED(rv)) {
     LOG(("OBJLC [%p]: Java codebase check failed", this));
     return false;
@@ -1461,17 +1460,17 @@
 {
   if (!aContentPolicy || !mURI) {
     NS_NOTREACHED("Doing it wrong");
     return false;
   }
 
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "Must be an instance of content");
+  MOZ_ASSERT(thisContent, "Must be an instance of content");
 
   nsIDocument* doc = thisContent->OwnerDoc();
 
   *aContentPolicy = nsIContentPolicy::ACCEPT;
   nsresult rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT,
                                           mURI,
                                           doc->NodePrincipal(),
                                           thisContent,
@@ -1499,17 +1498,17 @@
 {
   if (!aContentPolicy) {
     NS_NOTREACHED("Null out variable");
     return false;
   }
 
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "Must be an instance of content");
+  MOZ_ASSERT(thisContent, "Must be an instance of content");
 
   nsIDocument* doc = thisContent->OwnerDoc();
   
   int32_t objectType;
   switch (mType) {
     case eType_Image:
       objectType = nsIContentPolicy::TYPE_IMAGE;
       break;
@@ -1545,17 +1544,17 @@
   return true;
 }
 
 nsObjectLoadingContent::ParameterUpdateFlags
 nsObjectLoadingContent::UpdateObjectParameters(bool aJavaURI)
 {
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "Must be an instance of content");
+  MOZ_ASSERT(thisContent, "Must be an instance of content");
 
   uint32_t caps = GetCapabilities();
   LOG(("OBJLC [%p]: Updating object parameters", this));
 
   nsresult rv;
   nsAutoCString newMime;
   nsAutoString typeAttr;
   nsCOMPtr<nsIURI> newURI;
@@ -1579,18 +1578,18 @@
 
   ///
   /// Initial MIME Type
   ///
 
   if (aJavaURI || thisContent->NodeInfo()->Equals(nsGkAtoms::applet)) {
     nsAdoptingCString javaMIME = Preferences::GetCString(kPrefJavaMIME);
     newMime = javaMIME;
-    NS_ASSERTION(nsPluginHost::IsJavaMIMEType(newMime.get()),
-                 "plugin.mime.java should be recognized by IsJavaMIMEType");
+    MOZ_ASSERT(nsPluginHost::IsJavaMIMEType(newMime.get()),
+               "plugin.mime.java should be recognized by IsJavaMIMEType");
     isJava = true;
   } else {
     nsAutoString rawTypeAttr;
     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::type, rawTypeAttr);
     if (!rawTypeAttr.IsEmpty()) {
       typeAttr = rawTypeAttr;
       CopyUTF16toUTF8(rawTypeAttr, newMime);
       isJava = nsPluginHost::IsJavaMIMEType(newMime.get());
@@ -1602,18 +1601,18 @@
   ///
 
   if (caps & eSupportClassID) {
     nsAutoString classIDAttr;
     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::classid, classIDAttr);
     if (!classIDAttr.IsEmpty()) {
       // Our classid support is limited to 'java:' ids
       nsAdoptingCString javaMIME = Preferences::GetCString(kPrefJavaMIME);
-      NS_ASSERTION(nsPluginHost::IsJavaMIMEType(javaMIME.get()),
-                   "plugin.mime.java should be recognized by IsJavaMIMEType");
+      MOZ_ASSERT(nsPluginHost::IsJavaMIMEType(javaMIME.get()),
+                 "plugin.mime.java should be recognized by IsJavaMIMEType");
       if (StringBeginsWith(classIDAttr, NS_LITERAL_STRING("java:")) &&
           PluginExistsForType(javaMIME)) {
         newMime = javaMIME;
         isJava = true;
       } else {
         // XXX(johns): Our de-facto behavior since forever was to refuse to load
         // Objects who don't have a classid we support, regardless of other type
         // or uri info leads to a valid plugin.
@@ -1967,17 +1966,17 @@
 
   // Because we didn't open this channel from an initial LoadObject, we'll
   // update our parameters now, so the OnStartRequest->LoadObject doesn't
   // believe our src/type suddenly changed.
   UpdateObjectParameters();
   // But we always want to load from a channel, in this case.
   mType = eType_Loading;
   mChannel = do_QueryInterface(aChannel);
-  NS_ASSERTION(mChannel, "passed a request that is not a channel");
+  MOZ_ASSERT(mChannel, "passed a request that is not a channel");
 
   // OnStartRequest will now see we have a channel in the loading state, and
   // call into LoadObject. There's a possibility LoadObject will decide not to
   // load anything from a channel - it will call CloseChannel() in that case.
   return NS_OK;
 }
 
 // Only OnStartRequest should be passing the channel parameter
@@ -1990,17 +1989,17 @@
 
 nsresult
 nsObjectLoadingContent::LoadObject(bool aNotify,
                                    bool aForceLoad,
                                    nsIRequest *aLoadingChannel)
 {
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "must be a content");
+  MOZ_ASSERT(thisContent, "must be a content");
   nsIDocument* doc = thisContent->OwnerDoc();
   nsresult rv = NS_OK;
 
   // Sanity check
   if (!InActiveDocument(thisContent)) {
     NS_NOTREACHED("LoadObject called while not bound to an active document");
     return NS_ERROR_UNEXPECTED;
   }
@@ -2295,17 +2294,17 @@
       rv = mFrameLoader->GetDocShell(getter_AddRefs(docShell));
       if (NS_FAILED(rv)) {
         NS_NOTREACHED("Could not get DocShell from mFrameLoader?");
         mType = eType_Null;
         break;
       }
 
       nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(docShell));
-      NS_ASSERTION(req, "Docshell must be an ifreq");
+      MOZ_ASSERT(req, "Docshell must be an ifreq");
 
       nsCOMPtr<nsIURILoader>
         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID, &rv));
       if (NS_FAILED(rv)) {
         NS_NOTREACHED("Failed to get uriLoader service");
         mType = eType_Null;
         break;
       }
@@ -2333,18 +2332,18 @@
     // If we failed in the loading hunk above, switch to fallback
     LOG(("OBJLC [%p]: Loading failed, switching to fallback", this));
     mType = eType_Null;
   }
 
   // If we didn't load anything, handle switching to fallback state
   if (mType == eType_Null) {
     LOG(("OBJLC [%p]: Loading fallback, type %u", this, fallbackType));
-    NS_ASSERTION(!mFrameLoader && !mInstanceOwner,
-                 "switched to type null but also loaded something");
+    MOZ_ASSERT(!mFrameLoader && !mInstanceOwner,
+               "switched to type null but also loaded something");
 
     if (mChannel) {
       // If we were loading with a channel but then failed over, throw it away
       CloseChannel();
     }
 
     // Don't try to initialize plugins or final listener below
     doSpawnPlugin = false;
@@ -2382,18 +2381,18 @@
           // Plugins can reject their initial stream, but continue to run.
           CloseChannel();
           NS_ENSURE_TRUE(mIsLoading, NS_OK);
           rv = NS_OK;
         }
       }
     }
   } else if (finalListener) {
-    NS_ASSERTION(mType != eType_Null && mType != eType_Loading,
-                 "We should not have a final listener with a non-loaded type");
+    MOZ_ASSERT(mType != eType_Null && mType != eType_Loading,
+               "We should not have a final listener with a non-loaded type");
     mFinalListener = finalListener;
     rv = finalListener->OnStartRequest(mChannel, nullptr);
   }
 
   if (NS_FAILED(rv) && mIsLoading) {
     // Since we've already notified of our transition, we can just Unload and
     // call LoadFallback (which will notify again)
     mType = eType_Null;
@@ -2430,19 +2429,19 @@
 
 nsresult
 nsObjectLoadingContent::OpenChannel()
 {
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
   nsCOMPtr<nsIScriptSecurityManager> secMan =
     nsContentUtils::GetSecurityManager();
-  NS_ASSERTION(thisContent, "must be a content");
+  MOZ_ASSERT(thisContent, "must be a content");
   nsIDocument* doc = thisContent->OwnerDoc();
-  NS_ASSERTION(doc, "No owner document?");
+  MOZ_ASSERT(doc, "No owner document?");
 
   nsresult rv;
   mChannel = nullptr;
 
   // E.g. mms://
   if (!mURI || !CanHandleURI(mURI)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
@@ -2590,19 +2589,19 @@
                                            bool aNotify)
 {
   LOG(("OBJLC [%p]: Notifying about state change: (%u, %llx) -> (%u, %llx)"
        " (sync %i, notify %i)", this, aOldType, aOldState.GetInternalValue(),
        mType, ObjectState().GetInternalValue(), aSync, aNotify));
 
   nsCOMPtr<nsIContent> thisContent = 
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "must be a content");
-
-  NS_ASSERTION(thisContent->IsElement(), "Not an element?");
+  MOZ_ASSERT(thisContent, "must be a content");
+
+  MOZ_ASSERT(thisContent->IsElement(), "Not an element?");
 
   // XXX(johns): A good bit of the code below replicates UpdateState(true)
 
   // Unfortunately, we do some state changes without notifying
   // (e.g. in Fallback when canceling image requests), so we have to
   // manually notify object state changes.
   thisContent->AsElement()->UpdateState(false);
 
@@ -2615,17 +2614,17 @@
   if (!doc) {
     return; // Nothing to do
   }
 
   EventStates newState = ObjectState();
 
   if (newState != aOldState) {
     // This will trigger frame construction
-    NS_ASSERTION(InActiveDocument(thisContent), "Something is confused");
+    MOZ_ASSERT(InActiveDocument(thisContent), "Something is confused");
     EventStates changedBits = aOldState ^ newState;
 
     {
       nsAutoScriptBlocker scriptBlocker;
       doc->ContentStateChanged(thisContent, changedBits);
     }
     if (aSync) {
       // Make sure that frames are actually constructed immediately.
@@ -2723,17 +2722,17 @@
 
 NS_IMETHODIMP
 nsObjectLoadingContent::PluginCrashed(nsIPluginTag* aPluginTag,
                                       const nsAString& pluginDumpID,
                                       const nsAString& browserDumpID,
                                       bool submittedCrashReport)
 {
   LOG(("OBJLC [%p]: Plugin Crashed, queuing crash event", this));
-  NS_ASSERTION(mType == eType_Plugin, "PluginCrashed at non-plugin type");
+  MOZ_ASSERT(mType == eType_Plugin, "PluginCrashed at non-plugin type");
 
   PluginDestroyed();
 
   // Switch to fallback/crashed state, notify
   LoadFallback(eFallbackCrashed, true);
 
   // send nsPluginCrashedEvent
   nsCOMPtr<nsIContent> thisContent =
@@ -2808,18 +2807,19 @@
 
   // Note that returning a null plugin is expected (and happens often)
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsObjectLoadingContent::SyncStartPluginInstance()
 {
-  NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
-               "Must be able to run script in order to instantiate a plugin instance!");
+  MOZ_ASSERT(
+    nsContentUtils::IsSafeToRunScript(),
+    "Must be able to run script in order to instantiate a plugin instance!");
 
   // Don't even attempt to start an instance unless the content is in
   // the document and active
   nsCOMPtr<nsIContent> thisContent =
     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
   if (!InActiveDocument(thisContent)) {
     return NS_ERROR_FAILURE;
   }
@@ -2887,25 +2887,25 @@
   return false;
 }
 
 void
 nsObjectLoadingContent::LoadFallback(FallbackType aType, bool aNotify) {
   EventStates oldState = ObjectState();
   ObjectType oldType = mType;
 
-  NS_ASSERTION(!mInstanceOwner && !mFrameLoader && !mChannel,
-               "LoadFallback called with loaded content");
+  MOZ_ASSERT(!mInstanceOwner && !mFrameLoader && !mChannel,
+             "LoadFallback called with loaded content");
 
   //
   // Fixup mFallbackType
   //
   nsCOMPtr<nsIContent> thisContent =
   do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-  NS_ASSERTION(thisContent, "must be a content");
+  MOZ_ASSERT(thisContent, "must be a content");
 
   if (!thisContent->IsHTML() || mContentType.IsEmpty()) {
     // Don't let custom fallback handlers run outside HTML, tags without a
     // determined type should always just be alternate content
     aType = eFallbackAlternate;
   }
 
   if (thisContent->Tag() == nsGkAtoms::object &&
@@ -2958,17 +2958,17 @@
       return;
     }
 
 #if defined(XP_MACOSX)
     aInstanceOwner->HidePluginWindow();
 #endif
 
     nsRefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-    NS_ASSERTION(pluginHost, "No plugin host?");
+    MOZ_ASSERT(pluginHost, "No plugin host?");
     pluginHost->StopPluginInstance(inst);
   }
 
   aInstanceOwner->Destroy();
 
   // If we re-enter in plugin teardown UnloadObject will tear down the
   // protochain -- the current protochain could be from a new, unrelated, load.
   if (!mIsStopping) {
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -298,17 +298,17 @@
   nsPIDOMWindow *GetCurrentInnerWindow() const
   {
     MOZ_ASSERT(IsOuterWindow());
     return mInnerWindow;
   }
 
   nsPIDOMWindow *EnsureInnerWindow()
   {
-    NS_ASSERTION(IsOuterWindow(), "EnsureInnerWindow called on inner window");
+    MOZ_ASSERT(IsOuterWindow(), "EnsureInnerWindow called on inner window");
     // GetDoc forces inner window creation if there isn't one already
     GetDoc();
     return GetCurrentInnerWindow();
   }
 
   bool IsInnerWindow() const
   {
     return mIsInnerWindow;
diff --git a/dom/base/nsPlainTextSerializer.cpp b/dom/base/nsPlainTextSerializer.cpp
--- a/dom/base/nsPlainTextSerializer.cpp
+++ b/dom/base/nsPlainTextSerializer.cpp
@@ -121,24 +121,24 @@
 NS_IMETHODIMP 
 nsPlainTextSerializer::Init(uint32_t aFlags, uint32_t aWrapColumn,
                             const char* aCharSet, bool aIsCopying,
                             bool aIsWholeDocument)
 {
 #ifdef DEBUG
   // Check if the major control flags are set correctly.
   if (aFlags & nsIDocumentEncoder::OutputFormatFlowed) {
-    NS_ASSERTION(aFlags & nsIDocumentEncoder::OutputFormatted,
-                 "If you want format=flowed, you must combine it with "
-                 "nsIDocumentEncoder::OutputFormatted");
+    MOZ_ASSERT(aFlags & nsIDocumentEncoder::OutputFormatted,
+               "If you want format=flowed, you must combine it with "
+               "nsIDocumentEncoder::OutputFormatted");
   }
 
   if (aFlags & nsIDocumentEncoder::OutputFormatted) {
-    NS_ASSERTION(!(aFlags & nsIDocumentEncoder::OutputPreformatted),
-                 "Can't do formatted and preformatted output at the same time!");
+    MOZ_ASSERT(!(aFlags & nsIDocumentEncoder::OutputPreformatted),
+               "Can't do formatted and preformatted output at the same time!");
   }
 #endif
 
   mFlags = aFlags;
   mWrapColumn = aWrapColumn;
 
   // Only create a linebreaker if we will handle wrapping.
   if (MayWrap()) {
@@ -255,34 +255,35 @@
 nsPlainTextSerializer::AppendText(nsIContent* aText,
                                   int32_t aStartOffset,
                                   int32_t aEndOffset, 
                                   nsAString& aStr)
 {
   if (mIgnoreAboveIndex != (uint32_t)kNotFound) {
     return NS_OK;
   }
-    
-  NS_ASSERTION(aStartOffset >= 0, "Negative start offset for text fragment!");
+
+  MOZ_ASSERT(aStartOffset >= 0, "Negative start offset for text fragment!");
   if ( aStartOffset < 0 )
     return NS_ERROR_INVALID_ARG;
 
   NS_ENSURE_ARG(aText);
 
   nsresult rv = NS_OK;
 
   nsIContent* content = aText;
   const nsTextFragment* frag;
   if (!content || !(frag = content->GetText())) {
     return NS_ERROR_FAILURE;
   }
   
   int32_t fragLength = frag->GetLength();
   int32_t endoffset = (aEndOffset == -1) ? fragLength : std::min(aEndOffset, fragLength);
-  NS_ASSERTION(aStartOffset <= endoffset, "A start offset is beyond the end of the text fragment!");
+  MOZ_ASSERT(aStartOffset <= endoffset,
+             "A start offset is beyond the end of the text fragment!");
 
   int32_t length = endoffset - aStartOffset;
   if (length <= 0) {
     return NS_OK;
   }
 
   nsAutoString textstr;
   if (frag->Is2b()) {
@@ -393,18 +394,17 @@
     rv = DoCloseContainer(id);
     mPreformatStack.pop();
   }
 
   mElement = nullptr;
   mOutputString = nullptr;
 
   if (id == nsGkAtoms::head) {
-    NS_ASSERTION(mHeadLevel != 0,
-                 "mHeadLevel being decremented below 0");
+    MOZ_ASSERT(mHeadLevel != 0, "mHeadLevel being decremented below 0");
     --mHeadLevel;
   }
 
   return rv;
 }
 
 NS_IMETHODIMP 
 nsPlainTextSerializer::Flush(nsAString& aStr)
@@ -837,48 +837,48 @@
     if (--mULCount + mOLStackIndex == 0) {
       mFloatingLines = 1;
       mLineBreakDue = true;
     }
   }
   else if (aTag == nsGkAtoms::ol) {
     FlushLine(); // Doing this after decreasing OLStackIndex would be wrong.
     mIndent -= kIndentSizeList;
-    NS_ASSERTION(mOLStackIndex, "Wrong OLStack level!");
+    MOZ_ASSERT(mOLStackIndex, "Wrong OLStack level!");
     mOLStackIndex--;
     if (mULCount + mOLStackIndex == 0) {
       mFloatingLines = 1;
       mLineBreakDue = true;
     }
   }  
   else if (aTag == nsGkAtoms::dl) {
     mFloatingLines = 1;
     mLineBreakDue = true;
   }
   else if (aTag == nsGkAtoms::dd) {
     FlushLine();
     mIndent -= kIndentSizeDD;
   }
   else if (aTag == nsGkAtoms::span) {
-    NS_ASSERTION(mSpanLevel, "Span level will be negative!");
+    MOZ_ASSERT(mSpanLevel, "Span level will be negative!");
     --mSpanLevel;
   }
   else if (aTag == nsGkAtoms::div) {
     if (mFloatingLines < 0)
       mFloatingLines = 0;
     mLineBreakDue = true;
   }
   else if (aTag == nsGkAtoms::blockquote) {
     FlushLine();    // Is this needed?
 
     // Pop
     bool isInCiteBlockquote = PopBool(mIsInCiteBlockquote);
 
     if (isInCiteBlockquote) {
-      NS_ASSERTION(mCiteQuoteLevel, "CiteQuote level will be negative!");
+      MOZ_ASSERT(mCiteQuoteLevel, "CiteQuote level will be negative!");
       mCiteQuoteLevel--;
       mFloatingLines = 0;
       mHasWrittenCiteBlockquote = true;
     }
     else {
       mIndent -= kTabSize;
       mFloatingLines = 1;
     }
@@ -1207,49 +1207,49 @@
          )
         {
           // Space stuffing a la RFC 2646 (format=flowed).
           mCurrentLine.Append(char16_t(' '));
           
           if (MayWrap()) {
             mCurrentLineWidth += GetUnicharWidth(' ');
 #ifdef DEBUG_wrapping
-            NS_ASSERTION(GetUnicharStringWidth(mCurrentLine.get(),
-                                               mCurrentLine.Length()) ==
+            MOZ_ASSERT(GetUnicharStringWidth(mCurrentLine.get(),
+                                             mCurrentLine.Length()) ==
                          (int32_t)mCurrentLineWidth,
-                         "mCurrentLineWidth and reality out of sync!");
+                       "mCurrentLineWidth and reality out of sync!");
 #endif
           }
         }
     }
     mEmptyLines=-1;
   }
     
   mCurrentLine.Append(aLineFragment, aLineFragmentLength);
   if (MayWrap()) {
     mCurrentLineWidth += GetUnicharStringWidth(aLineFragment,
                                                aLineFragmentLength);
 #ifdef DEBUG_wrapping
-    NS_ASSERTION(GetUnicharstringWidth(mCurrentLine.get(),
-                                       mCurrentLine.Length()) ==
-                 (int32_t)mCurrentLineWidth,
-                 "mCurrentLineWidth and reality out of sync!");
+    MOZ_ASSERT(
+      GetUnicharstringWidth(mCurrentLine.get(), mCurrentLine.Length()) ==
+        (int32_t)mCurrentLineWidth,
+      "mCurrentLineWidth and reality out of sync!");
 #endif
   }
 
   linelength = mCurrentLine.Length();
 
   //  Wrap?
   if (MayWrap())
   {
 #ifdef DEBUG_wrapping
-    NS_ASSERTION(GetUnicharstringWidth(mCurrentLine.get(),
-                                  mCurrentLine.Length()) ==
-                 (int32_t)mCurrentLineWidth,
-                 "mCurrentLineWidth and reality out of sync!");
+    MOZ_ASSERT(
+      GetUnicharstringWidth(mCurrentLine.get(), mCurrentLine.Length()) ==
+        (int32_t)mCurrentLineWidth,
+      "mCurrentLineWidth and reality out of sync!");
 #endif
     // Yes, wrap!
     // The "+4" is to avoid wrap lines that only would be a couple
     // of letters too long. We give this bonus only if the
     // wrapcolumn is more than 20.
     uint32_t bonuswidth = (mWrapColumn > 20) ? 4 : 0;
 
     // XXX: Should calculate prefixwidth with GetUnicharStringWidth
@@ -1535,18 +1535,18 @@
   // Output directly while the other code path goes through AddToLine.
   if ((mPreFormatted && !mWrapColumn) || IsInPre()
       || ((mSpanLevel > 0 || mDontWrapAnyQuotes)
           && mEmptyLines >= 0 && str.First() == char16_t('>'))) {
     // No intelligent wrapping.
 
     // This mustn't be mixed with intelligent wrapping without clearing
     // the mCurrentLine buffer before!!!
-    NS_ASSERTION(mCurrentLine.IsEmpty() || IsInPre(),
-                 "Mixed wrapping data and nonwrapping data on the same line");
+    MOZ_ASSERT(mCurrentLine.IsEmpty() || IsInPre(),
+               "Mixed wrapping data and nonwrapping data on the same line");
     if (!mCurrentLine.IsEmpty()) {
       FlushLine();
     }
 
     // Put the mail quote "> " chars in, if appropriate.
     // Have to put it in before every line.
     while(bol<totLen) {
       bool outputQuotes = mAtFirstColumn;
diff --git a/dom/base/nsRange.cpp b/dom/base/nsRange.cpp
--- a/dom/base/nsRange.cpp
+++ b/dom/base/nsRange.cpp
@@ -179,18 +179,18 @@
 /* static */ bool
 nsRange::IsNodeSelected(nsINode* aNode, uint32_t aStartOffset,
                         uint32_t aEndOffset)
 {
   NS_PRECONDITION(aNode, "bad arg");
 
   FindSelectedRangeData data = { aNode, nullptr, aStartOffset, aEndOffset };
   nsINode* n = GetNextRangeCommonAncestor(aNode);
-  NS_ASSERTION(n || !aNode->IsSelectionDescendant(),
-               "orphan selection descendant");
+  MOZ_ASSERT(n || !aNode->IsSelectionDescendant(),
+             "orphan selection descendant");
   for (; n; n = GetNextRangeCommonAncestor(n->GetParentNode())) {
     RangeHashTable* ranges =
       static_cast<RangeHashTable*>(n->GetProperty(nsGkAtoms::range));
     ranges->EnumerateEntries(FindSelectedRange, &data);
     if (data.mResult) {
       return true;
     }
   }
@@ -198,17 +198,17 @@
 }
 
 /******************************************************
  * constructor/destructor
  ******************************************************/
 
 nsRange::~nsRange() 
 {
-  NS_ASSERTION(!IsInSelection(), "deleting nsRange that is in use");
+  MOZ_ASSERT(!IsInSelection(), "deleting nsRange that is in use");
 
   // Maybe we can remove Detach() -- bug 702948.
   Telemetry::Accumulate(Telemetry::DOM_RANGE_DETACHED, mIsDetached);
 
   // we want the side effects (releases and list removals)
   DoSetRange(nullptr, 0, nullptr, 0, nullptr);
 }
 
@@ -342,17 +342,17 @@
     }
   }
 }
 
 void
 nsRange::RegisterCommonAncestor(nsINode* aNode)
 {
   NS_PRECONDITION(aNode, "bad arg");
-  NS_ASSERTION(IsInSelection(), "registering range not in selection");
+  MOZ_ASSERT(IsInSelection(), "registering range not in selection");
 
   MarkDescendants(aNode);
 
   RangeHashTable* ranges =
     static_cast<RangeHashTable*>(aNode->GetProperty(nsGkAtoms::range));
   if (!ranges) {
     ranges = new RangeHashTable;
     aNode->SetProperty(nsGkAtoms::range, ranges,
@@ -361,20 +361,20 @@
   ranges->PutEntry(this);
   aNode->SetCommonAncestorForRangeInSelection();
 }
 
 void
 nsRange::UnregisterCommonAncestor(nsINode* aNode)
 {
   NS_PRECONDITION(aNode, "bad arg");
-  NS_ASSERTION(aNode->IsCommonAncestorForRangeInSelection(), "wrong node");
+  MOZ_ASSERT(aNode->IsCommonAncestorForRangeInSelection(), "wrong node");
   RangeHashTable* ranges =
     static_cast<RangeHashTable*>(aNode->GetProperty(nsGkAtoms::range));
-  NS_ASSERTION(ranges->GetEntry(this), "unknown range");
+  MOZ_ASSERT(ranges->GetEntry(this), "unknown range");
 
   if (ranges->Count() == 1) {
     aNode->ClearCommonAncestorForRangeInSelection();
     aNode->DeleteProperty(nsGkAtoms::range);
     UnmarkDescendants(aNode);
   } else {
     ranges->RemoveEntry(this);
   }
@@ -386,17 +386,17 @@
 
 void
 nsRange::CharacterDataChanged(nsIDocument* aDocument,
                               nsIContent* aContent,
                               CharacterDataChangeInfo* aInfo)
 {
   MOZ_ASSERT(mAssertNextInsertOrAppendIndex == -1,
              "splitText failed to notify insert/append?");
-  NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
+  MOZ_ASSERT(mIsPositioned, "shouldn't be notified if not positioned");
 
   nsINode* newRoot = nullptr;
   nsINode* newStartNode = nullptr;
   nsINode* newEndNode = nullptr;
   uint32_t newStartOffset = 0;
   uint32_t newEndOffset = 0;
 
   if (aInfo->mDetails &&
@@ -429,21 +429,21 @@
   }
 
   // If the changed node contains our start boundary and the change starts
   // before the boundary we'll need to adjust the offset.
   if (aContent == mStartParent &&
       aInfo->mChangeStart < static_cast<uint32_t>(mStartOffset)) {
     if (aInfo->mDetails) {
       // splitText(), aInfo->mDetails->mNextSibling is the new text node
-      NS_ASSERTION(aInfo->mDetails->mType ==
+      MOZ_ASSERT(aInfo->mDetails->mType ==
                    CharacterDataChangeInfo::Details::eSplit,
-                   "only a split can start before the end");
-      NS_ASSERTION(static_cast<uint32_t>(mStartOffset) <= aInfo->mChangeEnd + 1,
-                   "mStartOffset is beyond the end of this node");
+                 "only a split can start before the end");
+      MOZ_ASSERT(static_cast<uint32_t>(mStartOffset) <= aInfo->mChangeEnd + 1,
+                 "mStartOffset is beyond the end of this node");
       newStartOffset = static_cast<uint32_t>(mStartOffset) - aInfo->mChangeStart;
       newStartNode = aInfo->mDetails->mNextSibling;
       if (MOZ_UNLIKELY(aContent == mRoot)) {
         newRoot = IsValidBoundary(newStartNode);
       }
 
       bool isCommonAncestor = IsInSelection() && mStartParent == mEndParent;
       if (isCommonAncestor) {
@@ -465,21 +465,21 @@
 
   // Do the same thing for the end boundary, except for splitText of a node
   // with no parent then only switch to the new node if the start boundary
   // did so too (otherwise the range would end up with disconnected nodes).
   if (aContent == mEndParent &&
       aInfo->mChangeStart < static_cast<uint32_t>(mEndOffset)) {
     if (aInfo->mDetails && (aContent->GetParentNode() || newStartNode)) {
       // splitText(), aInfo->mDetails->mNextSibling is the new text node
-      NS_ASSERTION(aInfo->mDetails->mType ==
+      MOZ_ASSERT(aInfo->mDetails->mType ==
                    CharacterDataChangeInfo::Details::eSplit,
-                   "only a split can start before the end");
-      NS_ASSERTION(static_cast<uint32_t>(mEndOffset) <= aInfo->mChangeEnd + 1,
-                   "mEndOffset is beyond the end of this node");
+                 "only a split can start before the end");
+      MOZ_ASSERT(static_cast<uint32_t>(mEndOffset) <= aInfo->mChangeEnd + 1,
+                 "mEndOffset is beyond the end of this node");
       newEndOffset = static_cast<uint32_t>(mEndOffset) - aInfo->mChangeStart;
       newEndNode = aInfo->mDetails->mNextSibling;
 
       bool isCommonAncestor = IsInSelection() && mStartParent == mEndParent;
       if (isCommonAncestor && !newStartNode) {
         // The split occurs inside the range.
         UnregisterCommonAncestor(mStartParent);
         RegisterCommonAncestor(mStartParent->GetParentNode());
@@ -551,17 +551,17 @@
 }
 
 void
 nsRange::ContentAppended(nsIDocument* aDocument,
                          nsIContent*  aContainer,
                          nsIContent*  aFirstNewContent,
                          int32_t      aNewIndexInContainer)
 {
-  NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
+  MOZ_ASSERT(mIsPositioned, "shouldn't be notified if not positioned");
 
   nsINode* container = NODE_FROM(aContainer, aDocument);
   if (container->IsSelectionDescendant() && IsInSelection()) {
     nsINode* child = aFirstNewContent;
     while (child) {
       if (!child->IsDescendantOfCommonAncestorForRangeInSelection()) {
         MarkDescendants(child);
         child->SetDescendantOfCommonAncestorForRangeInSelection();
@@ -583,17 +583,17 @@
 }
 
 void
 nsRange::ContentInserted(nsIDocument* aDocument,
                          nsIContent* aContainer,
                          nsIContent* aChild,
                          int32_t aIndexInContainer)
 {
-  NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
+  MOZ_ASSERT(mIsPositioned, "shouldn't be notified if not positioned");
 
   nsINode* container = NODE_FROM(aContainer, aDocument);
 
   // Adjust position if a sibling was inserted.
   if (container == mStartParent && aIndexInContainer < mStartOffset &&
       !mStartOffsetWasIncremented) {
     ++mStartOffset;
   }
@@ -621,17 +621,17 @@
 
 void
 nsRange::ContentRemoved(nsIDocument* aDocument,
                         nsIContent* aContainer,
                         nsIContent* aChild,
                         int32_t aIndexInContainer,
                         nsIContent* aPreviousSibling)
 {
-  NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
+  MOZ_ASSERT(mIsPositioned, "shouldn't be notified if not positioned");
   MOZ_ASSERT(!mStartOffsetWasIncremented && !mEndOffsetWasIncremented &&
              mAssertNextInsertOrAppendIndex == -1,
              "splitText failed to notify insert/append?");
 
   nsINode* container = NODE_FROM(aContainer, aDocument);
   bool gravitateStart = false;
   bool gravitateEnd = false;
   bool didCheckStartParentDescendant = false;
@@ -677,27 +677,27 @@
 }
 
 void
 nsRange::ParentChainChanged(nsIContent *aContent)
 {
   MOZ_ASSERT(!mStartOffsetWasIncremented && !mEndOffsetWasIncremented &&
              mAssertNextInsertOrAppendIndex == -1,
              "splitText failed to notify insert/append?");
-  NS_ASSERTION(mRoot == aContent, "Wrong ParentChainChanged notification?");
+  MOZ_ASSERT(mRoot == aContent, "Wrong ParentChainChanged notification?");
   nsINode* newRoot = IsValidBoundary(mStartParent);
-  NS_ASSERTION(newRoot, "No valid boundary or root found!");
+  MOZ_ASSERT(newRoot, "No valid boundary or root found!");
   if (newRoot != IsValidBoundary(mEndParent)) {
     // Sometimes ordering involved in cycle collection can lead to our
     // start parent and/or end parent being disconnected from our root
     // without our getting a ContentRemoved notification.
     // See bug 846096 for more details.
-    NS_ASSERTION(mEndParent->IsInNativeAnonymousSubtree(),
-                 "This special case should happen only with "
-                 "native-anonymous content");
+    MOZ_ASSERT(mEndParent->IsInNativeAnonymousSubtree(),
+               "This special case should happen only with "
+               "native-anonymous content");
     // When that happens, bail out and set pointers to null; since we're
     // in cycle collection and unreachable it shouldn't matter.
     Reset();
     return;
   }
   // This is safe without holding a strong ref to self as long as the change
   // of mRoot is the last thing in DoSetRange.
   DoSetRange(mStartParent, mStartOffset, mEndParent, mEndOffset, newRoot);
@@ -891,17 +891,17 @@
     nsINode* newCommonAncestor = GetCommonAncestor();
     if (newCommonAncestor != oldCommonAncestor) {
       if (oldCommonAncestor) {
         UnregisterCommonAncestor(oldCommonAncestor);
       }
       if (newCommonAncestor) {
         RegisterCommonAncestor(newCommonAncestor);
       } else {
-        NS_ASSERTION(!mIsPositioned, "unexpected disconnected nodes");
+        MOZ_ASSERT(!mIsPositioned, "unexpected disconnected nodes");
         mInSelection = false;
       }
     }
   }
 
   // This needs to be the last thing this function does.  See comment
   // in ParentChainChanged.
   mRoot = aRoot;
@@ -1086,18 +1086,18 @@
   // text nodes in document, in document fragment or in attribute.
   nsINode* root = aNode->GetUncomposedDoc();
   if (root) {
     return root;
   }
 
   root = aNode->SubtreeRoot();
 
-  NS_ASSERTION(!root->IsNodeOfType(nsINode::eDOCUMENT),
-               "GetUncomposedDoc should have returned a doc");
+  MOZ_ASSERT(!root->IsNodeOfType(nsINode::eDOCUMENT),
+             "GetUncomposedDoc should have returned a doc");
 
   // We allow this because of backward compatibility.
   return root;
 }
 
 void
 nsRange::SetStart(nsINode& aNode, uint32_t aOffset, ErrorResult& aRv)
 {
@@ -2173,17 +2173,17 @@
 
 already_AddRefed<DocumentFragment>
 nsRange::CloneContents(ErrorResult& aRv)
 {
   nsCOMPtr<nsINode> commonAncestor = GetCommonAncestorContainer(aRv);
   MOZ_ASSERT(!aRv.Failed(), "GetCommonAncestorContainer() shouldn't fail!");
 
   nsCOMPtr<nsIDocument> doc = mStartParent->OwnerDoc();
-  NS_ASSERTION(doc, "CloneContents needs a document to continue.");
+  MOZ_ASSERT(doc, "CloneContents needs a document to continue.");
   if (!doc) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   // Create a new document fragment in the context of this document,
   // which might be null
 
@@ -2990,37 +2990,37 @@
 
   fontFaceList.forget(aResult);
   return NS_OK;
 }
 
 nsINode*
 nsRange::GetRegisteredCommonAncestor()
 {
-  NS_ASSERTION(IsInSelection(),
-               "GetRegisteredCommonAncestor only valid for range in selection");
+  MOZ_ASSERT(IsInSelection(),
+             "GetRegisteredCommonAncestor only valid for range in selection");
   nsINode* ancestor = GetNextRangeCommonAncestor(mStartParent);
   while (ancestor) {
     RangeHashTable* ranges =
       static_cast<RangeHashTable*>(ancestor->GetProperty(nsGkAtoms::range));
     if (ranges->GetEntry(this)) {
       break;
     }
     ancestor = GetNextRangeCommonAncestor(ancestor->GetParentNode());
   }
-  NS_ASSERTION(ancestor, "can't find common ancestor for selected range");
+  MOZ_ASSERT(ancestor, "can't find common ancestor for selected range");
   return ancestor;
 }
 
 /* static */ bool nsRange::AutoInvalidateSelection::mIsNested;
 
 nsRange::AutoInvalidateSelection::~AutoInvalidateSelection()
 {
-  NS_ASSERTION(mWasInSelection == mRange->IsInSelection(),
-               "Range got unselected in AutoInvalidateSelection block");
+  MOZ_ASSERT(mWasInSelection == mRange->IsInSelection(),
+             "Range got unselected in AutoInvalidateSelection block");
   if (!mCommonAncestor) {
     return;
   }
   mIsNested = false;
   ::InvalidateAllFrames(mCommonAncestor);
   nsINode* commonAncestor = mRange->GetRegisteredCommonAncestor();
   if (commonAncestor != mCommonAncestor) {
     ::InvalidateAllFrames(commonAncestor);
diff --git a/dom/base/nsRange.h b/dom/base/nsRange.h
--- a/dom/base/nsRange.h
+++ b/dom/base/nsRange.h
@@ -140,17 +140,17 @@
    */
   void SetInSelection(bool aInSelection)
   {
     if (mInSelection == aInSelection) {
       return;
     }
     mInSelection = aInSelection;
     nsINode* commonAncestor = GetCommonAncestor();
-    NS_ASSERTION(commonAncestor, "unexpected disconnected nodes");
+    MOZ_ASSERT(commonAncestor, "unexpected disconnected nodes");
     if (mInSelection) {
       RegisterCommonAncestor(commonAncestor);
     } else {
       UnregisterCommonAncestor(commonAncestor);
     }
   }
 
   nsINode* GetCommonAncestor() const;
diff --git a/dom/base/nsReferencedElement.cpp b/dom/base/nsReferencedElement.cpp
--- a/dom/base/nsReferencedElement.cpp
+++ b/dom/base/nsReferencedElement.cpp
@@ -195,17 +195,17 @@
 bool
 nsReferencedElement::Observe(Element* aOldElement,
                              Element* aNewElement, void* aData)
 {
   nsReferencedElement* p = static_cast<nsReferencedElement*>(aData);
   if (p->mPendingNotification) {
     p->mPendingNotification->SetTo(aNewElement);
   } else {
-    NS_ASSERTION(aOldElement == p->mElement, "Failed to track content!");
+    MOZ_ASSERT(aOldElement == p->mElement, "Failed to track content!");
     ChangeNotification* watcher =
       new ChangeNotification(p, aOldElement, aNewElement);
     p->mPendingNotification = watcher;
     nsContentUtils::AddScriptRunner(watcher);
   }
   bool keepTracking = p->IsPersistent();
   if (!keepTracking) {
     p->mWatchDocument = nullptr;
@@ -220,21 +220,21 @@
 NS_IMPL_ISUPPORTS(nsReferencedElement::DocumentLoadNotification,
                   nsIObserver)
 
 NS_IMETHODIMP
 nsReferencedElement::DocumentLoadNotification::Observe(nsISupports* aSubject,
                                                        const char* aTopic,
                                                        const char16_t* aData)
 {
-  NS_ASSERTION(PL_strcmp(aTopic, "external-resource-document-created") == 0,
-               "Unexpected topic");
+  MOZ_ASSERT(PL_strcmp(aTopic, "external-resource-document-created") == 0,
+             "Unexpected topic");
   if (mTarget) {
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aSubject);
     mTarget->mPendingNotification = nullptr;
-    NS_ASSERTION(!mTarget->mElement, "Why do we have content here?");
+    MOZ_ASSERT(!mTarget->mElement, "Why do we have content here?");
     // If we got here, that means we had Reset() called with aWatch ==
     // true.  So keep watching if IsPersistent().
     mTarget->HaveNewDocument(doc, mTarget->IsPersistent(), mRef);
     mTarget->ElementChanged(nullptr, mTarget->mElement);
   }
   return NS_OK;
 }
diff --git a/dom/base/nsScreen.cpp b/dom/base/nsScreen.cpp
--- a/dom/base/nsScreen.cpp
+++ b/dom/base/nsScreen.cpp
@@ -146,21 +146,21 @@
 }
 
 void
 nsScreen::Notify(const hal::ScreenConfiguration& aConfiguration)
 {
   ScreenOrientation previousOrientation = mOrientation;
   mOrientation = aConfiguration.orientation();
 
-  NS_ASSERTION(mOrientation == eScreenOrientation_PortraitPrimary ||
+  MOZ_ASSERT(mOrientation == eScreenOrientation_PortraitPrimary ||
                mOrientation == eScreenOrientation_PortraitSecondary ||
                mOrientation == eScreenOrientation_LandscapePrimary ||
                mOrientation == eScreenOrientation_LandscapeSecondary,
-               "Invalid orientation value passed to notify method!");
+             "Invalid orientation value passed to notify method!");
 
   if (mOrientation != previousOrientation) {
     DispatchTrustedEvent(NS_LITERAL_STRING("mozorientationchange"));
   }
 }
 
 void
 nsScreen::GetMozOrientation(nsString& aOrientation)
diff --git a/dom/base/nsScriptElement.cpp b/dom/base/nsScriptElement.cpp
--- a/dom/base/nsScriptElement.cpp
+++ b/dom/base/nsScriptElement.cpp
@@ -106,18 +106,18 @@
 }
 
 bool
 nsScriptElement::MaybeProcessScript()
 {
   nsCOMPtr<nsIContent> cont =
     do_QueryInterface((nsIScriptElement*) this);
 
-  NS_ASSERTION(cont->DebugGetSlots()->mMutationObservers.Contains(this),
-               "You forgot to add self as observer");
+  MOZ_ASSERT(cont->DebugGetSlots()->mMutationObservers.Contains(this),
+             "You forgot to add self as observer");
 
   if (mAlreadyStarted || !mDoneAddingChildren ||
       !cont->GetCrossShadowCurrentDoc() || mMalformed || !HasScriptContent()) {
     return false;
   }
 
   FreezeUriAsyncDefer();
 
diff --git a/dom/base/nsScriptLoader.cpp b/dom/base/nsScriptLoader.cpp
--- a/dom/base/nsScriptLoader.cpp
+++ b/dom/base/nsScriptLoader.cpp
@@ -530,35 +530,35 @@
         csp->LogViolationDetails(violations[i], NS_ConvertUTF8toUTF16(asciiSpec),
                                  scriptSample, aElement->GetScriptLineNumber(),
                                  nonce, scriptText);
       }
     }
   }
 
   if (!allowInlineScript) {
-    NS_ASSERTION(!violations.IsEmpty(),
-        "CSP blocked inline script but is not reporting a violation");
+    MOZ_ASSERT(!violations.IsEmpty(),
+               "CSP blocked inline script but is not reporting a violation");
    return false;
   }
   return true;
 }
 
 bool
 nsScriptLoader::ProcessScriptElement(nsIScriptElement *aElement)
 {
   // We need a document to evaluate scripts.
   NS_ENSURE_TRUE(mDocument, false);
 
   // Check to see if scripts has been turned off.
   if (!mEnabled || !mDocument->IsScriptEnabled()) {
     return false;
   }
 
-  NS_ASSERTION(!aElement->IsMalformed(), "Executing malformed script");
+  MOZ_ASSERT(!aElement->IsMalformed(), "Executing malformed script");
 
   nsCOMPtr<nsIContent> scriptContent = do_QueryInterface(aElement);
 
   // Step 12. Check that the script is not an eventhandler
   if (IsScriptEventHandler(scriptContent)) {
     return false;
   }
 
@@ -674,27 +674,28 @@
     // loading
     if (aElement->GetScriptDeferred()) {
       // We don't want to run this yet.
       // If we come here, the script is a parser-created script and it has
       // the defer attribute but not the async attribute. Since a
       // a parser-inserted script is being run, we came here by the parser
       // running the script, which means the parser is still alive and the
       // parse is ongoing.
-      NS_ASSERTION(mDocument->GetCurrentContentSink() ||
+      MOZ_ASSERT(mDocument->GetCurrentContentSink() ||
                    aElement->GetParserCreated() == FROM_PARSER_XSLT,
-          "Non-XSLT Defer script on a document without an active parser; bug 592366.");
+                 "Non-XSLT Defer script on a document without an active "
+                 "parser; bug 592366.");
       AddDeferRequest(request);
       return false;
     }
 
     if (aElement->GetParserCreated() == FROM_PARSER_XSLT) {
       // Need to maintain order for XSLT-inserted scripts
-      NS_ASSERTION(!mParserBlockingRequest,
-          "Parser-blocking scripts and XSLT scripts in the same doc!");
+      MOZ_ASSERT(!mParserBlockingRequest,
+                 "Parser-blocking scripts and XSLT scripts in the same doc!");
       mXSLTRequests.AppendElement(request);
       if (!request->mLoading) {
         // The script is available already. Run it ASAP when the event
         // loop gets a chance to spin.
         ProcessPendingRequestsAsync();
       }
       return true;
     }
@@ -703,30 +704,30 @@
       // sheets. If the script comes from the network stream, cheat for
       // performance reasons and avoid a trip through the event loop.
       if (aElement->GetParserCreated() == FROM_PARSER_NETWORK) {
         return ProcessRequest(request) == NS_ERROR_HTMLPARSER_BLOCK;
       }
       // Otherwise, we've got a document.written script, make a trip through
       // the event loop to hide the preload effects from the scripts on the
       // Web page.
-      NS_ASSERTION(!mParserBlockingRequest,
-          "There can be only one parser-blocking script at a time");
-      NS_ASSERTION(mXSLTRequests.IsEmpty(),
-          "Parser-blocking scripts and XSLT scripts in the same doc!");
+      MOZ_ASSERT(!mParserBlockingRequest,
+                 "There can be only one parser-blocking script at a time");
+      MOZ_ASSERT(mXSLTRequests.IsEmpty(),
+                 "Parser-blocking scripts and XSLT scripts in the same doc!");
       mParserBlockingRequest = request;
       ProcessPendingRequestsAsync();
       return true;
     }
     // The script hasn't loaded yet or there's a style sheet blocking it.
     // The script will be run when it loads or the style sheet loads.
-    NS_ASSERTION(!mParserBlockingRequest,
-        "There can be only one parser-blocking script at a time");
-    NS_ASSERTION(mXSLTRequests.IsEmpty(),
-        "Parser-blocking scripts and XSLT scripts in the same doc!");
+    MOZ_ASSERT(!mParserBlockingRequest,
+               "There can be only one parser-blocking script at a time");
+    MOZ_ASSERT(mXSLTRequests.IsEmpty(),
+               "Parser-blocking scripts and XSLT scripts in the same doc!");
     mParserBlockingRequest = request;
     return true;
   }
 
   // inline script
   // Is this document sandboxed without 'allow-scripts'?
   if (mDocument->GetSandboxFlags() & SANDBOXED_SCRIPTS) {
     return false;
@@ -743,47 +744,47 @@
   request->mLoading = false;
   request->mIsInline = true;
   request->mURI = mDocument->GetDocumentURI();
   request->mLineNo = aElement->GetScriptLineNumber();
 
   if (aElement->GetParserCreated() == FROM_PARSER_XSLT &&
       (!ReadyToExecuteScripts() || !mXSLTRequests.IsEmpty())) {
     // Need to maintain order for XSLT-inserted scripts
-    NS_ASSERTION(!mParserBlockingRequest,
-        "Parser-blocking scripts and XSLT scripts in the same doc!");
+    MOZ_ASSERT(!mParserBlockingRequest,
+               "Parser-blocking scripts and XSLT scripts in the same doc!");
     mXSLTRequests.AppendElement(request);
     return true;
   }
   if (aElement->GetParserCreated() == NOT_FROM_PARSER) {
-    NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
-        "A script-inserted script is inserted without an update batch?");
+    MOZ_ASSERT(!nsContentUtils::IsSafeToRunScript(),
+               "A script-inserted script is inserted without an update batch?");
     nsContentUtils::AddScriptRunner(new nsScriptRequestProcessor(this,
                                                                  request));
     return false;
   }
   if (aElement->GetParserCreated() == FROM_PARSER_NETWORK &&
       !ReadyToExecuteScripts()) {
-    NS_ASSERTION(!mParserBlockingRequest,
-        "There can be only one parser-blocking script at a time");
+    MOZ_ASSERT(!mParserBlockingRequest,
+               "There can be only one parser-blocking script at a time");
     mParserBlockingRequest = request;
-    NS_ASSERTION(mXSLTRequests.IsEmpty(),
-        "Parser-blocking scripts and XSLT scripts in the same doc!");
+    MOZ_ASSERT(mXSLTRequests.IsEmpty(),
+               "Parser-blocking scripts and XSLT scripts in the same doc!");
     return true;
   }
   // We now have a document.written inline script or we have an inline script
   // from the network but there is no style sheet that is blocking scripts.
   // Don't check for style sheets blocking scripts in the document.write
   // case to avoid style sheet network activity affecting when
   // document.write returns. It's not really necessary to do this if
   // there's no document.write currently on the call stack. However,
   // this way matches IE more closely than checking if document.write
   // is on the call stack.
-  NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
-      "Not safe to run a parser-inserted script?");
+  MOZ_ASSERT(nsContentUtils::IsSafeToRunScript(),
+             "Not safe to run a parser-inserted script?");
   return ProcessRequest(request) == NS_ERROR_HTMLPARSER_BLOCK;
 }
 
 namespace {
 
 class NotifyOffThreadScriptLoadCompletedRunnable : public nsRunnable
 {
   nsRefPtr<nsScriptLoadRequest> mRequest;
@@ -890,18 +891,18 @@
 
   unused << runnable.forget();
   return NS_OK;
 }
 
 nsresult
 nsScriptLoader::ProcessRequest(nsScriptLoadRequest* aRequest, void **aOffThreadToken)
 {
-  NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
-               "Processing requests when running scripts is unsafe.");
+  MOZ_ASSERT(nsContentUtils::IsSafeToRunScript(),
+             "Processing requests when running scripts is unsafe.");
 
   if (!aOffThreadToken) {
     nsresult rv = AttemptAsyncScriptParse(aRequest);
     if (rv != NS_ERROR_FAILURE)
       return rv;
   }
 
   NS_ENSURE_ARG(aRequest);
@@ -1024,17 +1025,17 @@
 {
   nsCOMPtr<nsIDocument> master = mDocument->MasterDocument();
   nsPIDOMWindow *pwin = master->GetInnerWindow();
   if (!pwin) {
     return nullptr;
   }
 
   nsCOMPtr<nsIScriptGlobalObject> globalObject = do_QueryInterface(pwin);
-  NS_ASSERTION(globalObject, "windows must be global objects");
+  MOZ_ASSERT(globalObject, "windows must be global objects");
 
   // and make sure we are setup for this type of script.
   nsresult rv = globalObject->EnsureScriptEnvironment();
   if (NS_FAILED(rv)) {
     return nullptr;
   }
 
   return globalObject.forget();
@@ -1090,17 +1091,17 @@
   nsCOMPtr<nsIContent> scriptContent(do_QueryInterface(aRequest->mElement));
   nsIDocument* ownerDoc = scriptContent->OwnerDoc();
   if (ownerDoc != mDocument) {
     // Willful violation of HTML5 as of 2010-12-01
     return NS_ERROR_FAILURE;
   }
 
   // Get the script-type to be used by this element.
-  NS_ASSERTION(scriptContent, "no content - what is default script-type?");
+  MOZ_ASSERT(scriptContent, "no content - what is default script-type?");
 
   nsCOMPtr<nsIScriptGlobalObject> globalObject = GetScriptGlobalObject();
   if (!globalObject) {
     return NS_ERROR_FAILURE;
   }
 
   // Make sure context is a strong reference since we access it after
   // we've executed a script, which may cause all other references to
@@ -1405,17 +1406,17 @@
 NS_IMETHODIMP
 nsScriptLoader::OnStreamComplete(nsIStreamLoader* aLoader,
                                  nsISupports* aContext,
                                  nsresult aStatus,
                                  uint32_t aStringLen,
                                  const uint8_t* aString)
 {
   nsScriptLoadRequest* request = static_cast<nsScriptLoadRequest*>(aContext);
-  NS_ASSERTION(request, "null request in stream complete handler");
+  MOZ_ASSERT(request, "null request in stream complete handler");
   NS_ENSURE_TRUE(request, NS_ERROR_FAILURE);
 
   nsresult rv = PrepareLoadedRequest(request, aLoader, aStatus, aStringLen,
                                      aString);
   if (NS_FAILED(rv)) {
     /*
      * Handle script not loading error because source was a tracking URL.
      * We make a note of this script node by including it in a dedicated
@@ -1478,17 +1479,17 @@
   // evaluation.
   if (!mDocument) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // If the load returned an error page, then we need to abort
   nsCOMPtr<nsIRequest> req;
   nsresult rv = aLoader->GetRequest(getter_AddRefs(req));
-  NS_ASSERTION(req, "StreamLoader's request went away prematurely");
+  MOZ_ASSERT(req, "StreamLoader's request went away prematurely");
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(req);
   if (httpChannel) {
     bool requestSucceeded;
     rv = httpChannel->GetRequestSucceeded(&requestSucceeded);
     if (NS_SUCCEEDED(rv) && !requestSucceeded) {
       return NS_ERROR_NOT_AVAILABLE;
@@ -1515,36 +1516,36 @@
   if (aStringLen) {
     // Check the charset attribute to determine script charset.
     nsAutoString hintCharset;
     if (!aRequest->IsPreload()) {
       aRequest->mElement->GetScriptCharset(hintCharset);
     } else {
       nsTArray<PreloadInfo>::index_type i =
         mPreloads.IndexOf(aRequest, 0, PreloadRequestComparator());
-      NS_ASSERTION(i != mPreloads.NoIndex, "Incorrect preload bookkeeping");
+      MOZ_ASSERT(i != mPreloads.NoIndex, "Incorrect preload bookkeeping");
       hintCharset = mPreloads[i].mCharset;
     }
     rv = ConvertToUTF16(channel, aString, aStringLen, hintCharset, mDocument,
                         aRequest->mScriptTextBuf, aRequest->mScriptTextLength);
 
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   // This assertion could fire errorously if we ran out of memory when
   // inserting the request in the array. However it's an unlikely case
   // so if you see this assertion it is likely something else that is
   // wrong, especially if you see it more than once.
-  NS_ASSERTION(mDeferRequests.Contains(aRequest) ||
+  MOZ_ASSERT(mDeferRequests.Contains(aRequest) ||
                mAsyncRequests.Contains(aRequest) ||
                mNonAsyncExternalScriptInsertedRequests.Contains(aRequest) ||
-               mXSLTRequests.Contains(aRequest)  ||
+               mXSLTRequests.Contains(aRequest) ||
                mPreloads.Contains(aRequest, PreloadRequestComparator()) ||
                mParserBlockingRequest,
-               "aRequest should be pending!");
+             "aRequest should be pending!");
 
   // Mark this as loaded
   aRequest->mLoading = false;
 
   return NS_OK;
 }
 
 void
diff --git a/dom/base/nsScriptNameSpaceManager.cpp b/dom/base/nsScriptNameSpaceManager.cpp
--- a/dom/base/nsScriptNameSpaceManager.cpp
+++ b/dom/base/nsScriptNameSpaceManager.cpp
@@ -162,18 +162,19 @@
                                          const nsAString *aKey)
 {
   PL_DHashTableRemove(aTable, aKey);
 }
 
 nsGlobalNameStruct*
 nsScriptNameSpaceManager::GetConstructorProto(const nsGlobalNameStruct* aStruct)
 {
-  NS_ASSERTION(aStruct->mType == nsGlobalNameStruct::eTypeExternalConstructorAlias,
-               "This function only works on constructor aliases!");
+  MOZ_ASSERT(aStruct->mType ==
+               nsGlobalNameStruct::eTypeExternalConstructorAlias,
+             "This function only works on constructor aliases!");
   if (!aStruct->mAlias->mProto) {
     GlobalNameMapEntry *proto =
       static_cast<GlobalNameMapEntry *>
                  (PL_DHashTableLookup(&mGlobalNames,
                                       &aStruct->mAlias->mProtoName));
 
     if (PL_DHASH_ENTRY_IS_BUSY(proto)) {
       aStruct->mAlias->mProto = &proto->mGlobalName;
@@ -434,20 +435,20 @@
 
   // If a external constructor is already defined with aClassName we
   // won't overwrite it.
 
   if (s->mType == nsGlobalNameStruct::eTypeExternalConstructor) {
     return NS_OK;
   }
 
-  NS_ASSERTION(s->mType == nsGlobalNameStruct::eTypeNotInitialized ||
+  MOZ_ASSERT(s->mType == nsGlobalNameStruct::eTypeNotInitialized ||
                s->mType == nsGlobalNameStruct::eTypeNewDOMBinding ||
                s->mType == nsGlobalNameStruct::eTypeInterface,
-               "Whaaa, JS environment name clash!");
+             "Whaaa, JS environment name clash!");
 
   s->mType = nsGlobalNameStruct::eTypeClassConstructor;
   s->mDOMClassInfoID = aDOMClassInfoID;
   s->mChromeOnly = aPrivileged;
   s->mAllowXBL = aXBLAllowed;
 
   return NS_OK;
 }
@@ -487,20 +488,20 @@
 
   // If an external constructor is already defined with aClassName we
   // won't overwrite it.
 
   if (s->mType == nsGlobalNameStruct::eTypeExternalConstructor) {
     return NS_OK;
   }
 
-  NS_ASSERTION(s->mType == nsGlobalNameStruct::eTypeNotInitialized ||
+  MOZ_ASSERT(s->mType == nsGlobalNameStruct::eTypeNotInitialized ||
                s->mType == nsGlobalNameStruct::eTypeNewDOMBinding ||
                s->mType == nsGlobalNameStruct::eTypeInterface,
-               "Whaaa, JS environment name clash!");
+             "Whaaa, JS environment name clash!");
 
   s->mType = nsGlobalNameStruct::eTypeExternalClassInfoCreator;
   s->mCID = aCID;
 
   return NS_OK;
 }
 
 nsresult
@@ -520,20 +521,21 @@
   // won't overwrite it.
 
   if (s->mType == nsGlobalNameStruct::eTypeClassConstructor ||
       s->mType == nsGlobalNameStruct::eTypeExternalClassInfo) {
     return NS_OK;
   }
 
   // XXX Should we bail out here?
-  NS_ASSERTION(s->mType == nsGlobalNameStruct::eTypeNotInitialized ||
+  MOZ_ASSERT(s->mType == nsGlobalNameStruct::eTypeNotInitialized ||
                s->mType == nsGlobalNameStruct::eTypeNewDOMBinding ||
                s->mType == nsGlobalNameStruct::eTypeExternalClassInfoCreator,
-               "Someone tries to register classinfo data for a class that isn't new or external!");
+             "Someone tries to register classinfo data for a class that isn't "
+             "new or external!");
 
   s->mData = new nsExternalDOMClassInfoData;
   NS_ENSURE_TRUE(s->mData, NS_ERROR_OUT_OF_MEMORY);
 
   s->mType = nsGlobalNameStruct::eTypeExternalClassInfo;
   s->mData->mName = aName;
   s->mData->mNameUTF16 = className;
   if (aConstructorFptr)
diff --git a/dom/base/nsStyleLinkElement.cpp b/dom/base/nsStyleLinkElement.cpp
--- a/dom/base/nsStyleLinkElement.cpp
+++ b/dom/base/nsStyleLinkElement.cpp
@@ -250,19 +250,19 @@
   }
   return false;
 }
 
 // Called when aElement has had a <style scoped> child removed.
 static void
 UpdateIsElementInStyleScopeFlagOnSubtree(Element* aElement)
 {
-  NS_ASSERTION(aElement->IsElementInStyleScope(),
-               "only call UpdateIsElementInStyleScopeFlagOnSubtree on a "
-               "subtree that has IsElementInStyleScope boolean flag set");
+  MOZ_ASSERT(aElement->IsElementInStyleScope(),
+             "only call UpdateIsElementInStyleScopeFlagOnSubtree on a "
+             "subtree that has IsElementInStyleScope boolean flag set");
 
   if (HasScopedStyleSheetChild(aElement)) {
     return;
   }
 
   aElement->ClearIsElementInStyleScope();
 
   nsIContent* n = aElement->GetNextNode(aElement);
@@ -396,17 +396,17 @@
   GetStyleSheetInfo(title, type, media, &isScoped, &isAlternate);
 
   if (!type.LowerCaseEqualsLiteral("text/css")) {
     return NS_OK;
   }
 
   Element* scopeElement = isScoped ? thisContent->GetParentElement() : nullptr;
   if (scopeElement) {
-    NS_ASSERTION(isInline, "non-inline style must not have scope element");
+    MOZ_ASSERT(isInline, "non-inline style must not have scope element");
     scopeElement->SetIsElementInStyleScopeFlagOnSubtree(true);
   }
 
   bool doneLoading = false;
   nsresult rv = NS_OK;
   if (isInline) {
     nsAutoString text;
     if (!nsContentUtils::GetNodeTextContent(thisContent, false, text)) {
diff --git a/dom/base/nsTextFragment.cpp b/dom/base/nsTextFragment.cpp
--- a/dom/base/nsTextFragment.cpp
+++ b/dom/base/nsTextFragment.cpp
@@ -285,18 +285,18 @@
   mState.mLength = aLength;
 
   return true;
 }
 
 void
 nsTextFragment::CopyTo(char16_t *aDest, int32_t aOffset, int32_t aCount)
 {
-  NS_ASSERTION(aOffset >= 0, "Bad offset passed to nsTextFragment::CopyTo()!");
-  NS_ASSERTION(aCount >= 0, "Bad count passed to nsTextFragment::CopyTo()!");
+  MOZ_ASSERT(aOffset >= 0, "Bad offset passed to nsTextFragment::CopyTo()!");
+  MOZ_ASSERT(aCount >= 0, "Bad count passed to nsTextFragment::CopyTo()!");
 
   if (aOffset < 0) {
     aOffset = 0;
   }
 
   if (uint32_t(aOffset + aCount) > GetLength()) {
     aCount = mState.mLength - aOffset;
   }
diff --git a/dom/base/nsTextFragment.h b/dom/base/nsTextFragment.h
--- a/dom/base/nsTextFragment.h
+++ b/dom/base/nsTextFragment.h
@@ -41,17 +41,17 @@
 
   /**
    * Default constructor. Initialize the fragment to be empty.
    */
   nsTextFragment()
     : m1b(nullptr), mAllBits(0)
   {
     MOZ_COUNT_CTOR(nsTextFragment);
-    NS_ASSERTION(sizeof(FragmentBits) == 4, "Bad field packing!");
+    MOZ_ASSERT(sizeof(FragmentBits) == 4, "Bad field packing!");
   }
 
   ~nsTextFragment();
 
   /**
    * Change the contents of this fragment to be a copy of the
    * the argument fragment, or to "" if unable to allocate enough memory.
    */
@@ -75,26 +75,26 @@
     return mState.mIsBidi;
   }
 
   /**
    * Get a pointer to constant char16_t data.
    */
   const char16_t *Get2b() const
   {
-    NS_ASSERTION(Is2b(), "not 2b text"); 
+    MOZ_ASSERT(Is2b(), "not 2b text");
     return m2b;
   }
 
   /**
    * Get a pointer to constant char data.
    */
   const char *Get1b() const
   {
-    NS_ASSERTION(!Is2b(), "not 1b text"); 
+    MOZ_ASSERT(!Is2b(), "not 1b text");
     return (const char *)m1b;
   }
 
   /**
    * Get the length of the fragment. The length is the number of logical
    * characters, not the number of bytes to store the characters.
    */
   uint32_t GetLength() const
@@ -192,17 +192,17 @@
   void CopyTo(char16_t *aDest, int32_t aOffset, int32_t aCount);
 
   /**
    * Return the character in the text-fragment at the given
    * index. This always returns a char16_t.
    */
   char16_t CharAt(int32_t aIndex) const
   {
-    NS_ASSERTION(uint32_t(aIndex) < mState.mLength, "bad index");
+    MOZ_ASSERT(uint32_t(aIndex) < mState.mLength, "bad index");
     return mState.mIs2b ? m2b[aIndex] : static_cast<unsigned char>(m1b[aIndex]);
   }
 
   struct FragmentBits {
     // uint32_t to ensure that the values are unsigned, because we
     // want 0/1, not 0/-1!
     // Making these bool causes Windows to not actually pack them,
     // which causes crashes because we assume this structure is no more than
diff --git a/dom/base/nsTextNode.cpp b/dom/base/nsTextNode.cpp
--- a/dom/base/nsTextNode.cpp
+++ b/dom/base/nsTextNode.cpp
@@ -36,18 +36,18 @@
   nsAttributeTextNode(already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo,
                       int32_t aNameSpaceID,
                       nsIAtom* aAttrName) :
     nsTextNode(aNodeInfo),
     mGrandparent(nullptr),
     mNameSpaceID(aNameSpaceID),
     mAttrName(aAttrName)
   {
-    NS_ASSERTION(mNameSpaceID != kNameSpaceID_Unknown, "Must know namespace");
-    NS_ASSERTION(mAttrName, "Must have attr name");
+    MOZ_ASSERT(mNameSpaceID != kNameSpaceID_Unknown, "Must know namespace");
+    MOZ_ASSERT(mAttrName, "Must have attr name");
   }
 
   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
                               nsIContent* aBindingParent,
                               bool aCompileEventHandlers) MOZ_OVERRIDE;
   virtual void UnbindFromTree(bool aDeep = true,
                               bool aNullParent = true) MOZ_OVERRIDE;
 
@@ -71,17 +71,17 @@
 
   // Public method for the event to run
   void UpdateText() {
     UpdateText(true);
   }
 
 private:
   virtual ~nsAttributeTextNode() {
-    NS_ASSERTION(!mGrandparent, "We were not unbound!");
+    MOZ_ASSERT(!mGrandparent, "We were not unbound!");
   }
 
   // Update our text to our parent's current attr value
   void UpdateText(bool aNotify);
 
   // This doesn't need to be a strong pointer because it's only non-null
   // while we're bound to the document tree, and it points to an ancestor
   // so the ancestor must be bound to the document tree the whole time
@@ -232,17 +232,17 @@
 {
   NS_PRECONDITION(aParent && aParent->GetParent(),
                   "This node can't be a child of the document or of the document root");
 
   nsresult rv = nsTextNode::BindToTree(aDocument, aParent,
                                        aBindingParent, aCompileEventHandlers);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  NS_ASSERTION(!mGrandparent, "We were already bound!");
+  MOZ_ASSERT(!mGrandparent, "We were already bound!");
   mGrandparent = aParent->GetParent();
   mGrandparent->AddMutationObserver(this);
 
   // Note that there is no need to notify here, since we have no
   // frame yet at this point.
   UpdateText(false);
 
   return NS_OK;
@@ -278,17 +278,17 @@
     nsCOMPtr<nsIRunnable> ev = NS_NewRunnableMethod(this, update);
     nsContentUtils::AddScriptRunner(ev);
   }
 }
 
 void
 nsAttributeTextNode::NodeWillBeDestroyed(const nsINode* aNode)
 {
-  NS_ASSERTION(aNode == static_cast<nsINode*>(mGrandparent), "Wrong node!");
+  MOZ_ASSERT(aNode == static_cast<nsINode*>(mGrandparent), "Wrong node!");
   mGrandparent = nullptr;
 }
 
 void
 nsAttributeTextNode::UpdateText(bool aNotify)
 {
   if (mGrandparent) {
     nsAutoString attrValue;
diff --git a/dom/base/nsTraversal.cpp b/dom/base/nsTraversal.cpp
--- a/dom/base/nsTraversal.cpp
+++ b/dom/base/nsTraversal.cpp
@@ -19,17 +19,17 @@
 nsTraversal::nsTraversal(nsINode *aRoot,
                          uint32_t aWhatToShow,
                          const NodeFilterHolder &aFilter) :
     mRoot(aRoot),
     mWhatToShow(aWhatToShow),
     mFilter(aFilter),
     mInAcceptNode(false)
 {
-    NS_ASSERTION(aRoot, "invalid root in call to nsTraversal constructor");
+  MOZ_ASSERT(aRoot, "invalid root in call to nsTraversal constructor");
 }
 
 nsTraversal::~nsTraversal()
 {
     /* destructor code */
 }
 
 /*
diff --git a/dom/base/nsTreeSanitizer.cpp b/dom/base/nsTreeSanitizer.cpp
--- a/dom/base/nsTreeSanitizer.cpp
+++ b/dom/base/nsTreeSanitizer.cpp
@@ -1129,17 +1129,17 @@
           }
         }
         break;
       }
       case mozilla::css::Rule::STYLE_RULE: {
         // For style rules, we will just look for and remove the
         // -moz-binding properties.
         nsRefPtr<mozilla::css::StyleRule> styleRule = do_QueryObject(rule);
-        NS_ASSERTION(styleRule, "Must be a style rule");
+        MOZ_ASSERT(styleRule, "Must be a style rule");
         nsAutoString decl;
         bool sanitized = SanitizeStyleRule(styleRule, decl);
         didSanitize = sanitized || didSanitize;
         if (!sanitized) {
           styleRule->GetCssText(decl);
         }
         aSanitized.Append(decl);
       }
@@ -1386,18 +1386,18 @@
         node->RemoveFromParent();
         node = next;
         continue;
       }
       if (nsGkAtoms::style == localName) {
         // If styles aren't allowed, style elements got pruned above. Even
         // if styles are allowed, non-HTML, non-SVG style elements got pruned
         // above.
-        NS_ASSERTION(ns == kNameSpaceID_XHTML || ns == kNameSpaceID_SVG,
-            "Should have only HTML or SVG here!");
+        MOZ_ASSERT(ns == kNameSpaceID_XHTML || ns == kNameSpaceID_SVG,
+                   "Should have only HTML or SVG here!");
         nsAutoString styleText;
         if (!nsContentUtils::GetNodeTextContent(node, false, styleText)) {
           NS_RUNTIMEABORT("OOM");
         }
         nsAutoString sanitizedStyle;
         nsCOMPtr<nsIURI> baseURI = node->GetBaseURI();
         if (SanitizeStyleSheet(styleText,
                                sanitizedStyle,
@@ -1437,20 +1437,19 @@
           if (rv.Failed()) {
             break;
           }
         }
         node->RemoveFromParent();
         node = next;
         continue;
       }
-      NS_ASSERTION(ns == kNameSpaceID_XHTML ||
-                   ns == kNameSpaceID_SVG ||
+      MOZ_ASSERT(ns == kNameSpaceID_XHTML || ns == kNameSpaceID_SVG ||
                    ns == kNameSpaceID_MathML,
-          "Should have only HTML, MathML or SVG here!");
+                 "Should have only HTML, MathML or SVG here!");
       if (ns == kNameSpaceID_XHTML) {
         SanitizeAttributes(elt,
                            sAttributesHTML,
                            (nsIAtom***)kURLAttributesHTML,
                            false, mAllowStyles,
                            (nsGkAtoms::img == localName) &&
                            !mCidEmbedsOnly);
       } else if (ns == kNameSpaceID_SVG) {
@@ -1466,17 +1465,17 @@
                            (nsIAtom***)kURLAttributesMathML,
                            true,
                            false,
                            false);
       }
       node = node->GetNextNode(aRoot);
       continue;
     }
-    NS_ASSERTION(!node->GetFirstChild(), "How come non-element node had kids?");
+    MOZ_ASSERT(!node->GetFirstChild(), "How come non-element node had kids?");
     nsIContent* next = node->GetNextNonChildNode(aRoot);
     if (!mAllowComments && node->IsNodeOfType(nsINode::eCOMMENT)) {
       node->RemoveFromParent();
     }
     node = next;
   }
 }
 
diff --git a/dom/base/nsWindowRoot.cpp b/dom/base/nsWindowRoot.cpp
--- a/dom/base/nsWindowRoot.cpp
+++ b/dom/base/nsWindowRoot.cpp
@@ -95,20 +95,20 @@
 }
 
 NS_IMETHODIMP
 nsWindowRoot::AddEventListener(const nsAString& aType,
                                nsIDOMEventListener *aListener,
                                bool aUseCapture, bool aWantsUntrusted,
                                uint8_t aOptionalArgc)
 {
-  NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
-               "Won't check if this is chrome, you want to set "
-               "aWantsUntrusted to false or make the aWantsUntrusted "
-               "explicit by making optional_argc non-zero.");
+  MOZ_ASSERT(!aWantsUntrusted || aOptionalArgc > 1,
+             "Won't check if this is chrome, you want to set "
+             "aWantsUntrusted to false or make the aWantsUntrusted "
+             "explicit by making optional_argc non-zero.");
 
   EventListenerManager* elm = GetOrCreateListenerManager();
   NS_ENSURE_STATE(elm);
   elm->AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted);
   return NS_OK;
 }
 
 void
@@ -130,20 +130,20 @@
 
 NS_IMETHODIMP
 nsWindowRoot::AddSystemEventListener(const nsAString& aType,
                                      nsIDOMEventListener *aListener,
                                      bool aUseCapture,
                                      bool aWantsUntrusted,
                                      uint8_t aOptionalArgc)
 {
-  NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
-               "Won't check if this is chrome, you want to set "
-               "aWantsUntrusted to false or make the aWantsUntrusted "
-               "explicit by making optional_argc non-zero.");
+  MOZ_ASSERT(!aWantsUntrusted || aOptionalArgc > 1,
+             "Won't check if this is chrome, you want to set "
+             "aWantsUntrusted to false or make the aWantsUntrusted "
+             "explicit by making optional_argc non-zero.");
 
   return NS_AddSystemEventListener(this, aType, aListener, aUseCapture,
                                    aWantsUntrusted);
 }
 
 EventListenerManager*
 nsWindowRoot::GetOrCreateListenerManager()
 {
diff --git a/dom/base/nsXHTMLContentSerializer.cpp b/dom/base/nsXHTMLContentSerializer.cpp
--- a/dom/base/nsXHTMLContentSerializer.cpp
+++ b/dom/base/nsXHTMLContentSerializer.cpp
@@ -52,17 +52,17 @@
 
 nsXHTMLContentSerializer::nsXHTMLContentSerializer()
   : mIsHTMLSerializer(false)
 {
 }
 
 nsXHTMLContentSerializer::~nsXHTMLContentSerializer()
 {
-  NS_ASSERTION(mOLStateStack.IsEmpty(), "Expected OL State stack to be empty");
+  MOZ_ASSERT(mOLStateStack.IsEmpty(), "Expected OL State stack to be empty");
 }
 
 NS_IMETHODIMP
 nsXHTMLContentSerializer::Init(uint32_t aFlags, uint32_t aWrapColumn,
                               const char* aCharSet, bool aIsCopying,
                               bool aRewriteEncodingDeclaration)
 {
   // The previous version of the HTML serializer did implicit wrapping
@@ -393,34 +393,35 @@
     }
     else {
       isJS = IsJavaScript(aContent, attrName, namespaceID, valueStr);
     }
 
     SerializeAttr(prefixStr, nameStr, valueStr, aStr, !isJS);
 
     if (addNSAttr) {
-      NS_ASSERTION(!prefixStr.IsEmpty(),
-                   "Namespaced attributes must have a prefix");
+      MOZ_ASSERT(!prefixStr.IsEmpty(),
+                 "Namespaced attributes must have a prefix");
       SerializeAttr(xmlnsStr, prefixStr, uriStr, aStr, true);
       PushNameSpaceDecl(prefixStr, uriStr, aOriginalElement);
     }
   }
 }
 
 
 void 
 nsXHTMLContentSerializer::AppendEndOfElementStart(nsIContent *aOriginalElement,
                                                   nsIAtom * aName,
                                                   int32_t aNamespaceID,
                                                   nsAString& aStr)
 {
   // this method is not called by nsHTMLContentSerializer
   // so we don't have to check HTML element, just XHTML
-  NS_ASSERTION(!mIsHTMLSerializer, "nsHTMLContentSerializer shouldn't call this method !");
+  MOZ_ASSERT(!mIsHTMLSerializer,
+             "nsHTMLContentSerializer shouldn't call this method !");
 
   if (kNameSpaceID_XHTML != aNamespaceID) {
     nsXMLContentSerializer::AppendEndOfElementStart(aOriginalElement, aName,
                                                     aNamespaceID, aStr);
     return;
   }
 
   nsIContent* content = aOriginalElement;
@@ -494,17 +495,18 @@
     }
   }
 }
 
 void
 nsXHTMLContentSerializer::AfterElementEnd(nsIContent * aContent,
                                           nsAString& aStr)
 {
-  NS_ASSERTION(!mIsHTMLSerializer, "nsHTMLContentSerializer shouldn't call this method !");
+  MOZ_ASSERT(!mIsHTMLSerializer,
+             "nsHTMLContentSerializer shouldn't call this method !");
 
   int32_t namespaceID = aContent->GetNameSpaceID();
   nsIAtom *name = aContent->Tag();
 
   // this method is not called by nsHTMLContentSerializer
   // so we don't have to check HTML element, just XHTML
   if (kNameSpaceID_XHTML == namespaceID && name == nsGkAtoms::body) {
     --mInBody;
@@ -551,29 +553,30 @@
   return true;
 }
 
 bool
 nsXHTMLContentSerializer::CheckElementEnd(nsIContent * aContent,
                                           bool & aForceFormat,
                                           nsAString& aStr)
 {
-  NS_ASSERTION(!mIsHTMLSerializer, "nsHTMLContentSerializer shouldn't call this method !");
+  MOZ_ASSERT(!mIsHTMLSerializer,
+             "nsHTMLContentSerializer shouldn't call this method !");
 
   aForceFormat = !(mFlags & nsIDocumentEncoder::OutputIgnoreMozDirty) &&
                  aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::mozdirty);
 
   nsIAtom *name = aContent->Tag();
   int32_t namespaceID = aContent->GetNameSpaceID();
 
   // this method is not called by nsHTMLContentSerializer
   // so we don't have to check HTML element, just XHTML
   if (namespaceID == kNameSpaceID_XHTML) {
     if (mIsCopying && name == nsGkAtoms::ol) {
-      NS_ASSERTION((!mOLStateStack.IsEmpty()), "Cannot have an empty OL Stack");
+      MOZ_ASSERT((!mOLStateStack.IsEmpty()), "Cannot have an empty OL Stack");
       /* Though at this point we must always have an state to be deleted as all 
       the OL opening tags are supposed to push an olState object to the stack*/
       if (!mOLStateStack.IsEmpty()) {
         mOLStateStack.RemoveElementAt(mOLStateStack.Length() -1);
       }
     }
 
     if (HasNoChildren(aContent)) {
diff --git a/dom/base/nsXMLContentSerializer.cpp b/dom/base/nsXMLContentSerializer.cpp
--- a/dom/base/nsXMLContentSerializer.cpp
+++ b/dom/base/nsXMLContentSerializer.cpp
@@ -137,18 +137,19 @@
   if (!content || !(frag = content->GetText())) {
     return NS_ERROR_FAILURE;
   }
 
   int32_t fragLength = frag->GetLength();
   int32_t endoffset = (aEndOffset == -1) ? fragLength : std::min(aEndOffset, fragLength);
   int32_t length = endoffset - aStartOffset;
 
-  NS_ASSERTION(aStartOffset >= 0, "Negative start offset for text fragment!");
-  NS_ASSERTION(aStartOffset <= endoffset, "A start offset is beyond the end of the text fragment!");
+  MOZ_ASSERT(aStartOffset >= 0, "Negative start offset for text fragment!");
+  MOZ_ASSERT(aStartOffset <= endoffset,
+             "A start offset is beyond the end of the text fragment!");
 
   if (length <= 0) {
     // XXX Zero is a legal value, maybe non-zero values should be an
     // error.
     return NS_OK;
   }
     
   if (frag->Is2b()) {
@@ -518,20 +519,20 @@
       // 2) We're looking at an existing default namespace decl on aElement (so
       //    we can't create a new default namespace decl for this URI)
       // then generate a new prefix.  Note that we do NOT generate new prefixes
       // if we happen to have aPrefix == decl->mPrefix == "" and mismatching
       // URIs when |decl| doesn't have aElement as its owner.  In that case we
       // can simply push the new namespace URI as the default namespace for
       // aElement.
       if (!aPrefix.IsEmpty() || decl.mOwner == aElement) {
-        NS_ASSERTION(!aURI.IsEmpty(),
-                     "Not allowed to add a xmlns attribute with an empty "
-                     "namespace name unless it declares the default "
-                     "namespace.");
+        MOZ_ASSERT(!aURI.IsEmpty(),
+                   "Not allowed to add a xmlns attribute with an empty "
+                   "namespace name unless it declares the default "
+                   "namespace.");
 
         GenerateNewPrefix(aPrefix);
         // Now we need to validate our new prefix/uri combination; check it
         // against the full namespace stack again.  Note that just restarting
         // the while loop is ok, since we haven't changed aURI, so the
         // closestURIMatch and uriMatch state is not affected.
         index = count - 1;
         haveSeenOurPrefix = false;
@@ -860,18 +861,18 @@
     aContent->GetAttr(namespaceID, attrName, valueStr);
 
     nsDependentAtomString nameStr(attrName);
     bool isJS = IsJavaScript(aContent, attrName, namespaceID, valueStr);
 
     SerializeAttr(prefixStr, nameStr, valueStr, aStr, !isJS);
     
     if (addNSAttr) {
-      NS_ASSERTION(!prefixStr.IsEmpty(),
-                   "Namespaced attributes must have a prefix");
+      MOZ_ASSERT(!prefixStr.IsEmpty(),
+                 "Namespaced attributes must have a prefix");
       SerializeAttr(xmlnsStr, prefixStr, uriStr, aStr, true);
       PushNameSpaceDecl(prefixStr, uriStr, aOriginalElement);
     }
   }
 }
 
 NS_IMETHODIMP 
 nsXMLContentSerializer::AppendElementStart(Element* aElement,
@@ -1002,17 +1003,18 @@
   aElement->NodeInfo()->GetPrefix(tagPrefix);
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
 #ifdef DEBUG
   bool debugNeedToPushNamespace =
 #endif
   ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
-  NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
+  MOZ_ASSERT(!debugNeedToPushNamespace,
+             "Can't push namespaces in closing tag!");
 
   if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
 
     bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
 
     if (mColPos && lineBreakBeforeClose) {
       AppendNewLineToString(aStr);
     }
diff --git a/dom/base/nsXMLHttpRequest.cpp b/dom/base/nsXMLHttpRequest.cpp
--- a/dom/base/nsXMLHttpRequest.cpp
+++ b/dom/base/nsXMLHttpRequest.cpp
@@ -739,18 +739,18 @@
 
   if (mResponseCharset != mResponseXML->GetDocumentCharacterSet()) {
     mResponseCharset = mResponseXML->GetDocumentCharacterSet();
     mResponseText.Truncate();
     mResponseBodyDecodedPos = 0;
     mDecoder = EncodingUtils::DecoderForEncoding(mResponseCharset);
   }
 
-  NS_ASSERTION(mResponseBodyDecodedPos < mResponseBody.Length(),
-               "Unexpected mResponseBodyDecodedPos");
+  MOZ_ASSERT(mResponseBodyDecodedPos < mResponseBody.Length(),
+             "Unexpected mResponseBodyDecodedPos");
   aRv = AppendToResponseText(mResponseBody.get() + mResponseBodyDecodedPos,
                              mResponseBody.Length() - mResponseBodyDecodedPos);
   if (aRv.Failed()) {
     return;
   }
 
   mResponseBodyDecodedPos = mResponseBody.Length();
   
@@ -1474,18 +1474,18 @@
 }
 
 void
 nsXMLHttpRequest::DispatchProgressEvent(DOMEventTargetHelper* aTarget,
                                         const nsAString& aType,
                                         bool aLengthComputable,
                                         int64_t aLoaded, int64_t aTotal)
 {
-  NS_ASSERTION(aTarget, "null target");
-  NS_ASSERTION(!aType.IsEmpty(), "missing event type");
+  MOZ_ASSERT(aTarget, "null target");
+  MOZ_ASSERT(!aType.IsEmpty(), "missing event type");
 
   if (NS_FAILED(CheckInnerWindowCorrectness()) ||
       (!AllowUploadProgress() && aTarget == mUpload)) {
     return;
   }
 
   bool dispatchLoadend = aType.EqualsLiteral(LOAD_STR) ||
                          aType.EqualsLiteral(ERROR_STR) ||
@@ -1841,32 +1841,32 @@
     xmlHttpRequest->mResponseBody.Append(fromRawSegment,count);
     if (count > 0 && xmlHttpRequest->mResponseBody.Length() == previousLength) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
   } else if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_TEXT ||
              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_JSON ||
              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
-    NS_ASSERTION(!xmlHttpRequest->mResponseXML,
-                 "We shouldn't be parsing a doc here");
+    MOZ_ASSERT(!xmlHttpRequest->mResponseXML,
+               "We shouldn't be parsing a doc here");
     xmlHttpRequest->AppendToResponseText(fromRawSegment, count);
   }
 
   if (xmlHttpRequest->mState & XML_HTTP_REQUEST_PARSEBODY) {
     // Give the same data to the parser.
 
     // We need to wrap the data in a new lightweight stream and pass that
     // to the parser, because calling ReadSegments() recursively on the same
     // stream is not supported.
     nsCOMPtr<nsIInputStream> copyStream;
     rv = NS_NewByteInputStream(getter_AddRefs(copyStream), fromRawSegment, count);
 
     if (NS_SUCCEEDED(rv) && xmlHttpRequest->mXMLParserStreamListener) {
-      NS_ASSERTION(copyStream, "NS_NewByteInputStream lied");
+      MOZ_ASSERT(copyStream, "NS_NewByteInputStream lied");
       nsresult parsingResult = xmlHttpRequest->mXMLParserStreamListener
                                   ->OnDataAvailable(xmlHttpRequest->mChannel,
                                                     xmlHttpRequest->mContext,
                                                     copyStream, toOffset, count);
 
       // No use to continue parsing if we failed here, but we
       // should still finish reading the stream
       if (NS_FAILED(parsingResult)) {
@@ -1897,17 +1897,17 @@
 
   nsAutoCString contentType;
   mChannel->GetContentType(contentType);
 
   mDOMFile = File::CreateFromFile(GetOwner(), file, EmptyString(),
                                   NS_ConvertASCIItoUTF16(contentType));
 
   mBlobSet = nullptr;
-  NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
+  MOZ_ASSERT(mResponseBody.IsEmpty(), "mResponseBody should be empty");
   return true;
 }
 
 NS_IMETHODIMP
 nsXMLHttpRequest::OnDataAvailable(nsIRequest *request,
                                   nsISupports *ctxt,
                                   nsIInputStream *inStr,
                                   uint64_t sourceOffset,
@@ -2189,17 +2189,17 @@
   if (request != mChannel) {
     // Can this still happen?
     return NS_OK;
   }
 
   mWaitingForOnStopRequest = false;
 
   if (mRequestObserver) {
-    NS_ASSERTION(mFirstStartRequestSeen, "Inconsistent state!");
+    MOZ_ASSERT(mFirstStartRequestSeen, "Inconsistent state!");
     mFirstStartRequestSeen = false;
     mRequestObserver->OnStopRequest(request, ctxt, status);
   }
 
   // make sure to notify the listener if we were aborted
   // XXX in fact, why don't we do the cleanup below in this case??
   // XML_HTTP_REQUEST_UNSENT is for abort calls.  See OnStartRequest above.
   if ((mState & XML_HTTP_REQUEST_UNSENT) ||
@@ -2241,18 +2241,18 @@
       }
       // Smaller files may be written in cache map instead of separate files.
       // Also, no-store response cannot be written in persistent cache.
       nsAutoCString contentType;
       mChannel->GetContentType(contentType);
       mResponseBlob = mBlobSet->GetBlobInternal(GetOwner(), contentType);
       mBlobSet = nullptr;
     }
-    NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
-    NS_ASSERTION(mResponseText.IsEmpty(), "mResponseText should be empty");
+    MOZ_ASSERT(mResponseBody.IsEmpty(), "mResponseBody should be empty");
+    MOZ_ASSERT(mResponseText.IsEmpty(), "mResponseText should be empty");
   } else if (NS_SUCCEEDED(status) &&
              ((mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
                !mIsMappedArrayBuffer) ||
               mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER)) {
     // set the capacity down to the actual length, to realloc back
     // down to the actual size
     if (!mArrayBufferBuilder.setCapacity(mArrayBufferBuilder.length())) {
       // this should never happen!
@@ -2286,18 +2286,18 @@
     return NS_OK;
   }
 
   if (!mResponseXML) {
     ChangeStateToDone();
     return NS_OK;
   }
   if (mIsHtml) {
-    NS_ASSERTION(!(mState & XML_HTTP_REQUEST_SYNCLOOPING),
-      "We weren't supposed to support HTML parsing with XHR!");
+    MOZ_ASSERT(!(mState & XML_HTTP_REQUEST_SYNCLOOPING),
+               "We weren't supposed to support HTML parsing with XHR!");
     nsCOMPtr<EventTarget> eventTarget = do_QueryInterface(mResponseXML);
     EventListenerManager* manager =
       eventTarget->GetOrCreateListenerManager();
     manager->AddEventListenerByType(new nsXHRParseEndListener(this),
                                     NS_LITERAL_STRING("DOMContentLoaded"),
                                     TrustedEventsAtSystemGroupBubble());
     return NS_OK;
   }
@@ -2850,17 +2850,17 @@
       }
 
       mUploadComplete = false;
 
       // We want to use a newer version of the upload channel that won't
       // ignore the necessary headers for an empty Content-Type.
       nsCOMPtr<nsIUploadChannel2> uploadChannel2(do_QueryInterface(httpChannel));
       // This assertion will fire if buggy extensions are installed
-      NS_ASSERTION(uploadChannel2, "http must support nsIUploadChannel2");
+      MOZ_ASSERT(uploadChannel2, "http must support nsIUploadChannel2");
       if (uploadChannel2) {
           uploadChannel2->ExplicitSetUploadStream(postDataStream, contentType,
                                                  mUploadTotal, method, false);
       }
       else {
         // http channel doesn't support the new nsIUploadChannel2. Emulate
         // as best we can using nsIUploadChannel
         if (contentType.IsEmpty()) {
@@ -2936,18 +2936,18 @@
 
   if (mIsAnon) {
     AddLoadFlags(mChannel, nsIRequest::LOAD_ANONYMOUS);
   }
   else {
     AddLoadFlags(mChannel, nsIChannel::LOAD_EXPLICIT_CREDENTIALS);
   }
 
-  NS_ASSERTION(listener != this,
-               "Using an object as a listener that can't be exposed to JS");
+  MOZ_ASSERT(listener != this,
+             "Using an object as a listener that can't be exposed to JS");
 
   // Bypass the network cache in cases where it makes no sense:
   // POST responses are always unique, and we provide no API that would
   // allow our consumers to specify a "cache key" to access old POST
   // responses, so they are not worth caching.
   if (method.EqualsLiteral("POST")) {
     AddLoadFlags(mChannel,
         nsIRequest::LOAD_BYPASS_CACHE | nsIRequest::INHIBIT_CACHING);
@@ -3098,17 +3098,17 @@
 NS_IMETHODIMP
 nsXMLHttpRequest::SetRequestHeader(const nsACString& header,
                                    const nsACString& value)
 {
   // Step 1 and 2
   if (!(mState & XML_HTTP_REQUEST_OPENED)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
-  NS_ASSERTION(mChannel, "mChannel must be valid if we're OPENED.");
+  MOZ_ASSERT(mChannel, "mChannel must be valid if we're OPENED.");
 
   // Step 3
   // Make sure we don't store an invalid header name in mCORSUnsafeHeaders
   if (!NS_IsValidHTTPToken(header)) {
     return NS_ERROR_DOM_SYNTAX_ERR;
   }
 
   // Check that we haven't already opened the channel. We can't rely on
@@ -3509,18 +3509,18 @@
   }
   OnRedirectVerifyCallback(NS_OK);
   return NS_OK;
 }
 
 void
 nsXMLHttpRequest::OnRedirectVerifyCallback(nsresult result)
 {
-  NS_ASSERTION(mRedirectCallback, "mRedirectCallback not set in callback");
-  NS_ASSERTION(mNewRedirectChannel, "mNewRedirectChannel not set in callback");
+  MOZ_ASSERT(mRedirectCallback, "mRedirectCallback not set in callback");
+  MOZ_ASSERT(mNewRedirectChannel, "mNewRedirectChannel not set in callback");
 
   if (NS_SUCCEEDED(result)) {
     mChannel = mNewRedirectChannel;
 
     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
     if (httpChannel) {
       // Ensure all original headers are duplicated for the new channel (bug #553888)
       for (uint32_t i = mModifiedRequestHeaders.Length(); i > 0; ) {
@@ -3667,17 +3667,17 @@
     return NS_OK;
   }
 
   // Now give mNotificationCallbacks (if non-null) a chance to return the
   // desired interface.
   if (mNotificationCallbacks) {
     rv = mNotificationCallbacks->GetInterface(aIID, aResult);
     if (NS_SUCCEEDED(rv)) {
-      NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
+      MOZ_ASSERT(*aResult, "Lying nsIInterfaceRequestor implementation!");
       return rv;
     }
   }
 
   if (mState & XML_HTTP_REQUEST_BACKGROUND) {
     nsCOMPtr<nsIInterfaceRequestor> badCertHandler(do_CreateInstance(NS_BADCERTHANDLER_CONTRACTID, &rv));
 
     // Ignore failure to get component, we may not have all its dependencies
diff --git a/dom/base/nsXMLHttpRequest.h b/dom/base/nsXMLHttpRequest.h
--- a/dom/base/nsXMLHttpRequest.h
+++ b/dom/base/nsXMLHttpRequest.h
@@ -463,17 +463,17 @@
     }
   }
   void Send(JSContext* /*aCx*/, nsFormData& aFormData, ErrorResult& aRv)
   {
     aRv = Send(RequestBody(aFormData));
   }
   void Send(JSContext* aCx, nsIInputStream* aStream, ErrorResult& aRv)
   {
-    NS_ASSERTION(aStream, "Null should go to string version");
+    MOZ_ASSERT(aStream, "Null should go to string version");
     nsCOMPtr<nsIXPConnectWrappedJS> wjs = do_QueryInterface(aStream);
     if (wjs) {
       JSObject* data = wjs->GetJSObject();
       if (!data) {
         aRv.Throw(NS_ERROR_DOM_TYPE_ERR);
         return;
       }
       JS::Rooted<JS::Value> dataAsValue(aCx, JS::ObjectValue(*data));
