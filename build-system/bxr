# HG changeset patch
# Parent f458a0db34e85a56100c1e65ffae528dc6f17452
# User Gregory Szorc <gps@mozilla.com>
Build Cross Reference tool

diff --git a/build/pymake/pymake/data.py b/build/pymake/pymake/data.py
--- a/build/pymake/pymake/data.py
+++ b/build/pymake/pymake/data.py
@@ -8,16 +8,48 @@
 
 if sys.version_info[0] < 3:
     str_type = basestring
 else:
     str_type = str
 
 _log = logging.getLogger('pymake.data')
 
+
+class ExpansionContext(object):
+    '''Instances of this type can be used as an alternative to full Makefile
+    instances when performing variable expansion.
+
+    When the Makefile is accessed or modified, the callback is invoked.
+    The first passed argument is the type of action being performed. The
+    second is the attribute being operated on. The third, if defined, is
+    the new value for the attribute.
+    '''
+
+    GET_ATTRIBUTE    = 1
+    SET_ATTRRIBUTE   = 2
+    DELETE_ATTRIBUTE = 3
+
+    __slots__ = ( '_callback' )
+
+    def __init__(self, callback=None):
+        '''Construct an instance that will invoke the specified method when
+        data is accessed.'''
+        object.__setattr__(self, '_callback', callback)
+
+    def __getattr__(self, name):
+        return self._callback(ExpansionContext.GET_ATTRIBUTE, name)
+
+    def __setattr__(self, name, value):
+        return self._callback(ExpansionContext.SET_ATTRIBUTE, name, value=value)
+
+    def __delattr__(self, name):
+        return self._callback(ExpansionContext.DELETE_ATTRIBUTE, name)
+
+
 class DataError(util.MakeError):
     pass
 
 class ResolutionError(DataError):
     """
     Raised when dependency resolution fails, either due to recursion or to missing
     prerequisites.This is separately catchable so that implicit rule search can try things
     without having to commit.
diff --git a/python/mozbuild/mozbuild/frontend/mach_commands.py b/python/mozbuild/mozbuild/frontend/mach_commands.py
--- a/python/mozbuild/mozbuild/frontend/mach_commands.py
+++ b/python/mozbuild/mozbuild/frontend/mach_commands.py
@@ -10,16 +10,26 @@
     Command
 )
 
 from mozbuild.base import MachCommandBase
 
 
 @CommandProvider
 class MozbuildFileCommands(MachCommandBase):
+    @Command('bxr', category='build-dev',
+        description='Run the Build Cross Reference (BXR) tool.')
+    @CommandArgument('filename', help='Filename to write to.')
+    def bxr(self, filename, load_all=True):
+        from mozbuild.frontendbs.bxr import generate_bxr
+
+        with open(filename, 'wb') as fh:
+            generate_bxr(self.topsrcdir, self.settings, self.log_manager,
+                fh, load_all=load_all)
+
     @Command('mozbuild-reference', category='build-dev',
         description='View reference documentation on mozbuild files.')
     @CommandArgument('symbol', default=None, nargs='*',
         help='Symbol to view help on. If not specified, all will be shown.')
     @CommandArgument('--name-only', '-n', default=False, action='store_true',
         help='Print symbol names only.')
     def reference(self, symbol, name_only=False):
         # mozbuild.sphinx imports some Sphinx modules, so we need to be sure
diff --git a/python/mozbuild/mozbuild/frontendbs/__init__.py b/python/mozbuild/mozbuild/frontendbs/__init__.py
new file mode 100644
diff --git a/python/mozbuild/mozbuild/frontendbs/bxr.py b/python/mozbuild/mozbuild/frontendbs/bxr.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/frontendbs/bxr.py
@@ -0,0 +1,597 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# This file contains functionality for the Build Cross Reference (BXR) tool.
+
+import hashlib
+import mako
+import mako.template
+import uuid
+
+import pymake.parser
+
+from mozbuild.frontendbs.frontend import BuildFrontend
+
+# This is our mako HTML template. Scroll down to see which variables are
+# available.
+HTML_TEMPLATE = """
+<!DOCTYPE html>
+<html>
+  <head>
+    <title>BXR - Build Cross Reference</title>
+  </head>
+  <body>
+    <h1>Build Cross Reference</h1>
+    <p>This document contains information about the build system.</p>
+
+    <section id="index">
+    <h1>Index</h1>
+    <ul>
+      <li><a href="#makefiles">Makefiles</a></li>
+      <li><a href="#variables">Variables</a></li>
+      <li><a href="#targets">Targets</a></li>
+      <li><a href="#commands">Commands</a></li>
+      <li><a href="#shell">Shell Invocations</a></li>
+      <li><a href="#filesystem">Filesystem Statements</a></li>
+      <li><a href="#targetspecific">Target-Specific Statements</a></li>
+    </ul>
+    </section>
+
+    <section id="makefiles">
+    <h1>Makefiles</h1>
+    <p>This section documents the various Makefiles which were consulted to
+    build this page.</p>
+
+    <table border="1">
+      <tr>
+        <th>Path</th>
+        <th>Rules</th>
+        <th>Pattern Rules</th>
+        <th>Doublecolon Rules</th>
+      </tr>
+      % for path in sorted(makefiles.keys()):
+        <% makefile = makefiles[path] %>
+        <tr>
+          <td>${makefile_link(path)}</td>
+          <td>${len(makefile['rules'])}</td>
+          <td>${len(makefile['pattern_rules'])}</td>
+          <td>${makefile['doublecolon_count']}</td>
+        </tr>
+      % endfor
+    </table>
+
+    <h2>Included Makefiles</h2>
+    <p>The following Makefiles are included from others.</p>
+
+    <table border="1">
+      <tr>
+        <th>Path</th>
+        <th>Count</th>
+      </tr>
+      % for path, v in includes.iteritems():
+        <tr>
+          <td>${path | h}</td>
+          <td>${len(v)}</td>
+        </tr>
+      % endfor
+    </table>
+
+    <h2>Makefile Info</h2>
+    <p>This section contains detailed information on every Makefile.</p>
+
+    % for path in sorted(makefiles.keys()):
+      <% makefile = makefiles[path] %>
+      <div id="${makefile['id']}" class="makefile">
+        <h4>${makefile_path(path) | h}</h4>
+        <div>
+          <strong>Source</strong>:
+          <a href="${makefile_repo_link(path, 'hg') | h}">Mercurial</a>,
+          <a href="${makefile_repo_link(path, 'github') | h}">GitHub</a>
+        </div>
+        % if len(makefile['rules']) > 0:
+        <table border="1">
+          <tr>
+            <th>Target Name(s)</th>
+            <th>Doublecolon</th>
+            <th>Prerequisites</th>
+            <th>Conditions</th>
+            <th>Commands</th>
+          </tr>
+          % for rule in makefile['rules']:
+            <tr>
+              <td>${rule['target'] | h}
+              <a href="${makefile_repo_link(path, 'hg', rule['line']) | h}">HG</a> |
+              <a href="${makefile_repo_link(path, 'github', rule['line']) | h}">GitHub</a>
+              </td>
+
+              % if rule['doublecolon']:
+                  <td><strong>YES</strong</td>
+              % else:
+                  <td>No</td>
+              % endif
+
+              <td>
+                % if len(rule['prerequisites']) > 0:
+                <ul>
+                  % for prereq in rule['prerequisites']:
+                    <li>${prereq | h}</li>
+                  % endfor
+                </ul>
+                % endif
+              </td>
+
+              <td>
+              % if len(rule['conditions']) > 0:
+                <ul>
+                % for c in rule['conditions']:
+                  <li>${c | h}</li>
+                % endfor
+                </ul>
+              % endif
+              </td>
+
+              <td>
+                % for command in rule['commands']:
+                  ${command.lstrip()}<br />
+                % endfor
+              </td>
+            </tr>
+          % endfor
+        </table>
+        % endif
+      </div>
+    % endfor
+    </section>
+
+    <section id="variables">
+    <h1>Variables</h1>
+
+    <h2>Variable List</h2>
+    <p>The master list of all variables follows. These variables can appear in
+    Makefiles or inside included .mk files.</p>
+
+    <table border="1">
+      <caption>Variable File Counts</caption>
+      <tr>
+        <th>Name</th>
+        <th>Set</th>
+        <th>Referenced</th>
+        <th>Used in ifdef</th>
+      </tr>
+      % for name in sorted(variables.keys()):
+        <% variable = variables[name] %>
+        <tr>
+          <td>
+            <a href="#${variable['id']}">${name | h}</a>
+            <small>${mxr_link(name, '(MXR)')}</small></td>
+          <td>${len(variable['set_paths'])}</td>
+          <td>${len(variable['referenced_paths'])}</td>
+          <td>${len(variable['ifdef_paths'])}</td>
+        </tr>
+      % endfor
+    </table>
+
+    <h2>Variables by File Frequency</h2>
+    <table border="1">
+      <caption>Variables by File Frequency</caption>
+      <tr>
+        <th>Variable</th>
+        <th>Count</th>
+      </tr>
+      % for k, v in variables_by_makefile_count:
+        <tr>
+          <td><a href="#${variables[k]['id']}">${k | h}</a></td>
+          <td>${v}</td>
+        </tr>
+      % endfor
+    </table>
+
+    <h2>Variables Used in ifdefs</h2>
+    <table border="1">
+      <caption>Variables used in ifdefs</caption>
+      <tr>
+        <th>Name</th>
+        <th># Makefiles</th>
+      </tr>
+      % for name in sorted(variables.keys()):
+        <% variable = variables[name] %>
+        % if len(variable['ifdef_paths']) > 0:
+          <tr>
+            <td><a href="#${variable['id']}">${name | h}</a></td>
+            <td>${len(variable['ifdef_paths'])}</td>
+          </tr>
+        % endif
+      % endfor
+    </table>
+
+    <h2>Variable Info</h2>
+    <p>Information about each encountered variable follows.</p>
+
+    % for name in sorted(variables.keys()):
+      <% variable = variables[name] %>
+      <div id="${variable['id']}" class="variable">
+        <h4>${name | h}</h4>
+
+        <table border="1">
+          <tr>
+            <th>Makefile</th>
+            <th>Set</th>
+            <th>Referenced</th>
+            <th>Used as ifdef</th>
+          </tr>
+          % for path in sorted(variable['all_paths']):
+          <tr>
+            <td>${makefile_link(path)}</td>
+            <td>
+              % if path in variable['set_paths']:
+                Yes
+              % else:
+                No
+              % endif
+            </td>
+            <td>
+              % if path in variable['referenced_paths']:
+                Yes
+              % else:
+                No
+              % endif
+            </td>
+            <td>
+              % if path in variable['ifdef_paths']:
+                Yes
+              % else:
+                No
+              % endif
+            </td>
+          </tr>
+          % endfor
+        </table>
+      </div>
+    % endfor
+    </section>
+
+    <section id="targets">
+      <h1>Targets</h1>
+      <table border="1">
+        <tr>
+          <th>Target</th>
+          <th>Makefiles</th>
+        </tr>
+        % for target in sorted(targets.keys()):
+          <% data = targets[target] %>
+          <tr>
+            <td>${target | h}</td>
+            <td>
+              % if len(data['paths']) > 0:
+                <ul>
+                % for path in sorted(data['paths']):
+                  <li>${makefile_link(path)}</li>
+                % endfor
+                </ul>
+              % endif
+            </td>
+          </tr>
+        % endfor
+      </table>
+    </section>
+
+    <section id="commands">
+      <h1>Commands</h1>
+      <table border="1">
+        <tr>
+          <th>Command</th>
+          <th>Makefile(s)</th>
+        </tr>
+        % for command in sorted(commands.keys()):
+          <% data = commands[command] %>
+          <tr>
+            <td>${command | h}</td>
+            <td>
+              % if len(data['used_paths']) > 0:
+                <ul>
+                  % for path in sorted(data['used_paths']):
+                    <li>${makefile_link(path)}</li>
+                  % endfor
+                </ul>
+              % endif
+            </td>
+          </tr>
+        % endfor
+      </table>
+    </section>
+
+    <section id="shell">
+      <h1>Shell Invocations</h1>
+      <table border="1">
+        <caption>Listing of shell invocations in Makefiles</caption>
+        <tr>
+          <th>File</th>
+          <th>Statement</th>
+        </tr>
+        % for path in sorted(shell_statements.keys()):
+          % for statement in shell_statements[path]:
+            <tr>
+              <td>${makefile_link(path)}</td>
+              <td><pre>${statement[0] | h}</pre></td>
+            </tr>
+          % endfor
+        % endfor
+      </table>
+    </section>
+
+    <section id="filesystem">
+      <h1>Filesystem Statements</h1>
+      <table border="1">
+        <caption>Listing of make statements dependent on filesystem</caption>
+        <tr>
+          <th>File</th>
+          <th>Statement</th>
+        </tr>
+        % for path in sorted(filesystem_statements.keys()):
+          % for statement in filesystem_statements[path]:
+            <tr>
+              <td>${makefile_link(path)}</td>
+              <td><pre>${statement[0] | h}</pre></td>
+            </tr>
+          % endfor
+        % endfor
+      </table>
+    </section>
+
+    <section id="targetspecific">
+      <h1>Target-Specific Statements</h1>
+      <table border="1">
+        <caption>Target-specific variable assignments.</caption>
+        <tr>
+          <th>File</th>
+          <th>Target</th>
+          <th>Variable</th>
+        </tr>
+        % for path in sorted(target_specific_variables.keys()):
+          % for target, exp in target_specific_variables[path]:
+            <tr>
+              <td>${makefile_link(path)}</td>
+              <td>${target | h}</pre></td>
+              <td><pre>${exp | h}</pre></td>
+            </tr>
+          % endfor
+        % endfor
+      </table>
+    </section>
+  </body>
+</html>
+
+<%def name="makefile_path(path)", buffered="True">
+    <% objdir = object_directory %>
+    % if path[0:len(objdir)] == objdir:
+        ${path[len(objdir)+1:]}
+    % else:
+        ${path}
+    % endif
+</%def>
+
+<%def name="makefile_link(path)", buffered="True">
+    <% id = makefiles[path]['id'] %>
+    <a href="#${id}">${makefile_path(path) | h}</a>
+</%def>
+
+<%def name="makefile_repo_link(path, flavor, line=None)", buffered="True">
+    <%
+    objdir = object_directory
+    newpath = path
+    if path[0:len(objdir)] == objdir:
+        newpath = path[len(objdir)+1:]
+
+    if newpath[-8:] == 'Makefile':
+        newpath += '.in'
+
+    uri = None
+
+    if flavor == 'hg':
+        uri = 'https://hg.mozilla.org/mozilla-central/file/default/%s' % newpath
+
+        if line is not None:
+            uri += '#l%s' % line
+    elif flavor == 'github':
+        uri = 'https://github.com/mozilla/mozilla-central/blob/master/%s' % newpath
+
+        if line is not None:
+            uri += '#L%s' % line
+    else:
+        raise 'Unknown flavor: %s' % flavor
+    %>
+    ${uri}
+</%def>
+
+<%def name="mxr_link(term, text)", buffered="True">
+  <a href="https://mxr.mozilla.org/mozilla-central/search?string=${term | h}&amp;case=on">${text | h}</a>
+</%def>
+"""
+
+def generate_bxr(topsrcdir, settings, log_manager, fh, load_all=False):
+    """Generate the BXR HTML and write to the specified file handle."""
+    frontend = BuildFrontend(topsrcdir, settings, log_manager)
+
+    if load_all:
+        frontend.load_all_input_files()
+    else:
+        frontend.load_autoconf_input_files()
+
+    def get_variable_value(name):
+        return {
+            'id':               hashlib.sha1(name).hexdigest(),
+            'set_paths':        set(),
+            'ifdef_paths':      set(),
+            'referenced_paths': set(),
+        }
+
+    makefiles = {}             # Path to dictionary of metadata
+    variables = {}             # Name to dictionary of metadata
+    targets = {}               # Expansion str to dictionary of metadata
+    includes = {}              # Expansion str to list of tuples
+    commands = {}              # Expansion str to dictionary of metadata
+    shell_statements = {}      # Path to list of tuples
+    filesystem_statements = {} # Path to list of tuples
+    target_specific_variables = {} # Path to list of tuples
+
+    for m in frontend.makefiles.makefiles():
+        key = m.filename
+
+        if key.startswith(frontend.topsrcdir):
+            key = key[len(frontend.topsrcdir) + 1:]
+
+        try:
+            statements = m.statements
+        except pymake.parser.SyntaxError as e:
+            print(e)
+            continue
+
+        metadata = makefiles.get(key, None)
+        if metadata is None:
+            metadata = {
+                'id':                    hashlib.sha1(key).hexdigest(),
+                'rules':                 [],
+                'pattern_rules':         [],
+                'includes':              [],
+                'doublecolon_count':     0,
+                'shell_statements':      [],
+                'filesystem_statements': [],
+            }
+
+        for statement, conditions, name, value, type in statements.variable_assignments():
+            vdata = variables.get(name, None)
+            if vdata is None:
+                vdata = get_variable_value(name)
+
+            vdata['set_paths'].add(key)
+            variables[name] = vdata
+
+            if statement.statement.targetexp is not None:
+                lst = target_specific_variables.get(key, [])
+
+                lst.append((statement.statement.targetexp.to_source(),
+                    str(statement)))
+
+                target_specific_variables[key] = lst
+
+        for statement, conditions, target, prerequisites, cmds in statements.rules():
+            target_str = str(target)
+            metadata['rules'].append({
+                'target': target_str,
+                'conditions': [str(c) for c in conditions],
+                'prerequisites': prerequisites.split(),
+                'commands': [str(c) for c in cmds],
+                'line': statement.location.line,
+                'doublecolon': statement.has_doublecolon,
+            })
+
+            metadata['doublecolon_count'] += 1
+
+            for targ in target.split():
+                target_data = targets.get(targ, None)
+                if target_data is None:
+                    target_data = {
+                        'id': hashlib.sha1(target_str).hexdigest(),
+                        'paths': set(),
+                    }
+
+                target_data['paths'].add(key)
+                targets[targ] = target_data
+
+            for command in cmds:
+                cmd = command.command_name
+                if cmd is not None:
+                    command_data = commands.get(cmd, None)
+                    if command_data is None:
+                        command_data = {
+                            'id': hashlib.sha1(cmd).hexdigest(),
+                            'used_paths': set(),
+                        }
+
+                    command_data['used_paths'].add(key)
+                    commands[cmd] = command_data
+
+        for statement, conditions, target, pattern, prerequisites, cmds in statements.static_pattern_rules():
+            metadata['pattern_rules'].append((
+                str(target),
+                conditions,
+                str(pattern),
+                prerequisites,
+                cmds
+            ))
+
+            metadata['doublecolon_count'] += 1
+
+        for statement, conditions, path in statements.includes():
+            s = str(path)
+
+            metadata['includes'].append((s, conditions, statement.required, statement.location))
+
+            include = includes.get(s, [])
+            include.append((s, conditions, statement.required, statement.location))
+            includes[s] = include
+
+        for statement, conditions, name, expected in statements.ifdefs():
+            vdata = variables.get(name, None)
+            if vdata is None:
+                vdata = get_variable_value(name)
+
+            vdata['ifdef_paths'].add(key)
+            variables[name] = vdata
+
+        for expansion in statements.variable_references():
+            name = str(expansion)
+            vdata = variables.get(name, None)
+            if vdata is None:
+                vdata = get_variable_value(name)
+
+            vdata['referenced_paths'].add(key)
+            variables[name] = vdata
+
+        for statement, conditions in statements.shell_dependent_statements():
+            t = (str(statement), statement.location.line)
+            metadata['shell_statements'].append(t)
+
+            sdata = shell_statements.get(key, [])
+            sdata.append(t)
+            shell_statements[key] = sdata
+
+        for statement, conditions in statements.filesystem_dependent_statements():
+            t = (str(statement), statement.location.line)
+            metadata['filesystem_statements'].append(t)
+
+            sdata = filesystem_statements.get(key, [])
+            sdata.append(t)
+            filesystem_statements[key] = sdata
+
+        makefiles[key] = metadata
+
+    for k, v in variables.iteritems():
+        v['all_paths'] = v['set_paths'] | v['ifdef_paths'] | v['referenced_paths']
+
+    variables_by_file_count = [(k, len(v['all_paths'])) for (k, v) in
+                               sorted(variables.iteritems(),
+                                      reverse=True,
+                                      key=lambda(k, v): (len(v['all_paths']), k)
+                               )]
+
+    try:
+        t = mako.template.Template(HTML_TEMPLATE)
+        print >>fh, t.render(
+            source_directory=frontend.topsrcdir,
+            object_directory=frontend.topobjdir,
+            makefiles=makefiles,
+            variables=variables,
+            targets=targets,
+            includes=includes,
+            commands=commands,
+            shell_statements=shell_statements,
+            filesystem_statements=filesystem_statements,
+            variables_by_makefile_count=variables_by_file_count,
+            target_specific_variables=target_specific_variables
+        )
+    except:
+        print >>fh, mako.exceptions.html_error_template().render()
+        raise Exception('Error when rendering template. See file for full error.')
+
diff --git a/python/mozbuild/mozbuild/frontendbs/data.py b/python/mozbuild/mozbuild/frontendbs/data.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/frontendbs/data.py
@@ -0,0 +1,251 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# This file contains classes to hold metadata for build tree concepts.
+# The classes in this file should be data-driven and dumb containers.
+
+import os.path
+
+
+class TreeInfo(object):
+    """This class represents an entire build tree.
+
+    It is a dumb container. Logic for putting stuff in the container and doing
+    things with the content lives elsewhere.
+    """
+
+    __slots__ = (
+        # Dictionary of path/namespace to set of filenames
+        'exports',
+
+        # Set of directories containing IDL files
+        'idl_directories',
+
+        # Dictionary of filenames to metadata
+        'idl_sources',
+
+        # Dictionary of filenames to metadata
+        'jar_manifests',
+
+        # Dictionary of libraries. Keys are unique library names. Values are
+        # dictionaries with additional metadata.
+        'libraries',
+
+        # Path to output/object directory
+        'object_directory',
+
+        # Set of directories containing sources
+        'source_directories',
+
+        # Main/top source directory
+        'top_source_directory',
+
+        # Dictionary of XPIDL modules to metadata
+        'xpidl_modules',
+    )
+
+    def __init__(self):
+        self.exports              = {}
+        self.idl_directories      = set()
+        self.idl_sources          = {}
+        self.jar_manifests        = {}
+        self.libraries            = {}
+        self.object_directory     = None
+        self.source_directories   = set()
+        self.top_source_directory = None
+        self.xpidl_modules        = {}
+
+class MakefileDerivedObject(object):
+    """Abstract class for something that was derived from a Makefile."""
+
+    __slots__ = (
+        'directory',        # Directory containing this Makefile
+        'source_dir',       # Source directory for this Makefile
+        'top_source_dir',   # The top source code directory
+        'used_variables',   # Keeps track of variables consulted to build this object
+        'exclusive_variables', # Variables exclusive to our data object.
+        'vpath',            # List of VPATH entries for this Makefile. The
+                            # VPATH is order dependent, so we store a list,
+                            # not a set.
+    )
+
+    def __init__(self, makefile):
+        assert(makefile is not None)
+
+        self.directory = makefile.directory
+        self.source_dir = None
+        self.top_source_dir = None
+        self.used_variables = set()
+        self.exclusive_variables = set()
+        self.vpath = []
+
+        if makefile.has_own_variable('srcdir'):
+            self.source_dir = makefile.get_variable_string('srcdir')
+
+        if makefile.has_own_variable('topsrcdir'):
+            self.top_source_dir = makefile.get_variable_string('topsrcdir')
+
+        if makefile.has_own_variable('VPATH'):
+            self.vpath = makefile.get_variable_split('VPATH')
+
+class LibraryInfo(MakefileDerivedObject):
+    """Represents a library in the Mozilla build system.
+
+    A library is likely a C or C++ static or shared library.
+    """
+
+    __slots__ = (
+        # C compilation.
+        'c_sources', # C source files.
+        'c_flags', # C compiler_flags
+        'compile_cflags',
+
+        # C++ compilation.
+        'cpp_sources', # C++ source files.
+        'compile_cxxflags', # Full C++ compiler flags.
+        'cxx_flags', # C++ compiler flags
+
+        # Objective-C compilation.
+        'objc_sources', # Objective-C source files.
+        'objc_compile_flags',
+
+        # Objective-C++ compilation.
+        'objcpp_sources',
+        'objcpp_compile_flags',
+
+        # General compilation.
+        # TODO consider recording per-source flags always rather than separate
+        # global and per-file values.
+        'source_specific_flags',
+
+        'export_library',  # Whether to export the library
+        'name', # The name of the library
+        'pic', # Whether to generate position-independent code
+        'is_component', # Whether the library is a component, whatever that means
+        'is_shared', # Whether the library is shared
+        'is_static', # Whether the library is static
+        'shared_library_libs', # Set of static libraries to link in when building
+                               # a shared library
+        'short_libname', # This doesn't appear to be used anywhere
+                         # significant, but we capture it anyway.
+        'use_static_libs', # Compile against static libraries
+    )
+
+    def __init__(self, makefile):
+        """Create a new library instance."""
+        MakefileDerivedObject.__init__(self, makefile)
+
+        self.c_sources = set()
+        self.c_flags = set()
+        self.cpp_sources = set()
+        self.cxx_flags = set()
+
+        self.objc_sources = set()
+        self.objcpp_sources = set()
+
+        self.source_specific_flags = {}
+
+        self.export_library = None
+        self.pic = None
+        self.is_component = None
+        self.is_shared = None
+        self.is_static = None
+        self.shared_library_libs = set()
+        self.short_libname = None
+        self.use_static_libs = None
+
+
+class ExportsInfo(MakefileDerivedObject):
+    """Represents a set of objects to export, typically headers.
+
+    Files to be exported and tracked in the filenames member. It is a list of
+    dicts. Each dict contains the following keys:
+
+        source -- str filename to be exported
+        dest -- str destination relative path
+    """
+
+    __slots__ = (
+        'filenames', # list of dicts containing metadata.
+        'output_directories', # set of str of output directory leafs.
+    )
+
+    def __init__(self, makefile):
+        MakefileDerivedObject.__init__(self, makefile)
+
+        self.filenames = []
+        self.output_directories = set()
+
+class XPIDLInfo(MakefileDerivedObject):
+    """Holds information related to XPIDL files."""
+
+    __slots__ = (
+        'module', # Name of XPIDL module.
+        'sources', # Set of source IDL filenames.
+        'write_manifest', # Whether to write manifest file.
+        'link_together', # Whether to link together into a final XPT.
+    )
+
+    def __init__(self, makefile):
+        MakefileDerivedObject.__init__(self, makefile)
+
+        self.module  = None
+        self.sources = set()
+        self.write_manifest = True
+        self.link_together = True
+
+class TestInfo(MakefileDerivedObject):
+    """Represents info relevant to testing."""
+
+    __slots__ = (
+        'browser_test_files',   # Set of files used for browser tests
+        'chrome_test_files',    # Set of files used for chrome tests
+        'test_files',           # Set of regular test files
+        'xpcshell_test_dirs',   # Set of directories holding xpcshell tests
+    )
+
+    def __init__(self, makefile):
+        MakefileDerivedObject.__init__(self, makefile)
+
+        self.browser_test_files = set()
+        self.chrome_test_files  = set()
+        self.test_files         = set()
+        self.xpcshell_test_dirs = set()
+
+class UsedVariableInfo(MakefileDerivedObject):
+    """Non-abstract version of MakefileDerivedObject.
+
+    This is used simply for variable tracking purposes.
+    """
+
+    def __init__(self, makefile):
+        MakefileDerivedObject.__init__(self, makefile)
+
+class MiscInfo(MakefileDerivedObject):
+    """Used to track misc info that isn't captured well anywhere else."""
+
+    __slots__ = (
+        'chrome_dependencies', # Set of extra dependencies for the chrome target
+        'defines',             # Set of DEFINES for JarMaker and other things
+        'extra_components',    # Set of extra components, whatever they are
+        'extra_js_module',     # Set of extra JavaScript modules
+        'garbage',             # Set of extra things to clean up
+        'included_files',      # List of files included by the Makefile
+        'is_gre_module',       # Whether the Makefile is a GRE module and has prefs
+        'platform_dirs',       # Set of directories only compiled on the current
+                               # platform.
+    )
+
+    def __init__(self, makefile):
+        MakefileDerivedObject.__init__(self, makefile)
+
+        self.chrome_dependencies = set()
+        self.defines             = set()
+        self.extra_components    = set()
+        self.extra_js_module     = set()
+        self.garbage             = set()
+        self.included_files      = None
+        self.is_gre_module       = None
+        self.platform_dirs       = set()
+
diff --git a/python/mozbuild/mozbuild/frontendbs/frontend.py b/python/mozbuild/mozbuild/frontendbs/frontend.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/frontendbs/frontend.py
@@ -0,0 +1,432 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# This file contains code for managing the "frontend" files of the Mozilla
+# build system.
+
+import os
+import sys
+import traceback
+import xpidl
+
+from . import data
+
+from ..base import MozbuildObject
+
+from .makefile import (
+    MakefileCollection,
+    StatementCollection,
+)
+from .mozillamakefile import MozillaMakefile
+#from mozbuild.backend.utils import substitute_makefile
+
+# Constants for identifying build file types
+BUILD_FILE_MAKE_TEMPLATE = 1
+BUILD_FILE_MAKEFILE = 2
+BUILD_FILE_MK = 3
+BUILD_FILE_CONFIGURE_INPUT = 4
+BUILD_FILE_OTHER_IN = 5
+
+# These relative paths are not managed by us, so we can ignore them
+EXTERNALLY_MANAGED_PATHS = (
+    'js/src',
+    'nsprpub',
+)
+
+IGNORE_BUILD_FILES = (
+    # Uses order-only prerequisites, which PyMake can't handle.
+    # Bug 703843 tracks fixing.
+    'build/unix/elfhack/Makefile.in',
+
+    # EXPORTS_$(binding_include_path) foo isn't handled properly.
+    'dom/bindings/Makefile.in',
+
+    # Trips over $(error) in CPPSRCS assignment.
+    'xpcom/reflect/xptcall/src/md/unix/Makefile.in',
+
+    # Requires GYP generation.
+    'media/webrtc/trunk/Makefile.in',
+    'media/webrtc/trunk/testing/Makefile.in',
+
+    # L10NBASEDIR not defined by autoconf.
+    'extensions/spellcheck/locales/Makefile.in',
+    'toolkit/locales/Makefile.in',
+    'browser/locales/Makefile.in',
+)
+
+CONFIGURE_IGNORE_FILES = (
+    'js/src/config.log',
+    'js/src/unallmakefiles',
+    'nsprpub/config.log',
+    'config.cache',
+    'config.log',
+    'unallmakefiles',
+)
+
+class BuildFrontend(MozbuildObject):
+    """Provides an interface to the build config files in a source tree.
+
+    This is used to load the input files which will be used to generate files
+    for a build backend.
+    """
+
+    def __init__(self, topsrcdir, settings, log_manager):
+        MozbuildObject.__init__(self, topsrcdir, settings, log_manager)
+
+        self.makefiles = MakefileCollection(self.topsrcdir, self.topobjdir)
+        self.autoconf = None
+
+        # Files contributing to the frontend config.
+        self.input_files = set()
+
+        # We add loaded Python modules because the code here contributes
+        # to the frontend config as well.
+        # TODO make conditional on a setting.
+        if True:
+            for name, module in sys.modules.iteritems():
+                if not name.startswith('mozbuild') or not module:
+                    continue
+
+                self.input_files.add(module.__file__)
+
+    @property
+    def autoconf_output_files(self):
+        """The output files managed by autoconf.
+
+        This is basically a parser for unallmakefiles from the object
+        directory.
+
+        It is a generator of str which correlate to the relative paths of
+        output files in the object directory.
+
+        TODO extract data from config.status
+        """
+        unallmakefiles = os.path.join(self.topobjdir, 'unallmakefiles')
+
+        output_files = None
+
+        with open(unallmakefiles, 'rb') as fh:
+            output_files = sorted(fh.read().strip().split(' '))
+
+        return output_files
+
+    @property
+    def autoconf_input_files(self):
+        """The input files as reported by autoconf.
+
+        This converts the output of autoconf_output_files into the source
+        filenames.
+        """
+        return ['%s.in' % p for p in self.autoconf_output_files]
+
+    @property
+    def all_input_files(self):
+        """The comprehensive set of input files.
+
+        This crawls the filesystem and finds every input file.
+        """
+        it = BuildFrontend.get_frontend_files(
+            self.topsrcdir,
+            ignore_relative=EXTERNALLY_MANAGED_PATHS,
+            ignore_full=[self.topobjdir])
+
+        for (relative, name, cat) in it:
+            if cat == BUILD_FILE_MAKE_TEMPLATE:
+                if name == 'Makefile.in':
+                    yield os.path.join(relative, name)
+
+    def load_autoconf_input_files(self):
+        """Loads all autoconf reported config files into this instance.
+
+        This loads the subset of config files that autoconf says is active. It
+        may be incomplete.
+        """
+        self.load_autoconf_file()
+
+        for relative in self.autoconf_input_files:
+            self.load_input_file(relative)
+
+    def load_all_input_files(self):
+        self.load_autoconf_file()
+
+        for relative in self.all_input_files:
+            self.load_input_file(relative)
+
+    def load_and_traverse_makefile(self, relative):
+        """Loads a Makefile.in and traverse into children.
+
+        This looks at the DIRS variables in a Makefile.in to determine paths to
+        other Makefile.in's.
+        """
+        relative_path = os.path.join(relative, 'Makefile.in')
+        source_path = os.path.join(self.topsrcdir, relative_path)
+
+        if relative_path in IGNORE_BUILD_FILES:
+            return None
+
+        self.input_files.add(source_path)
+        output_directory = os.path.join(self.topobjdir, relative)
+        m = MozillaMakefile(source_path, relative, output_directory)
+        self.makefiles.add(m)
+        m.env['DONT_LOAD_RULES'] = '1'
+        substitute_makefile(m, self)
+
+        def process_dir(d):
+            reldir = os.path.normpath(os.path.join(relative, d))
+
+            self.load_and_traverse_makefile(reldir)
+
+        read_vars = ['DIRS', 'PARALLEL_DIRS', 'TOOL_DIRS', 'TEST_DIRS']
+        for var in read_vars:
+            for d in m.get_variable_split(var):
+                process_dir(d)
+
+        return m
+
+    def load_input_file(self, relative):
+        """Load an input from the source directory at the specified path."""
+        assert not os.path.isabs(relative)
+
+        if not relative.endswith('Makefile.in'):
+            return None
+
+        if relative in IGNORE_BUILD_FILES:
+            return None
+
+        path = os.path.join(self.topsrcdir, relative)
+        self.input_files.add(path)
+
+        reldir = os.path.dirname(relative)
+
+        output_directory = os.path.join(self.topobjdir, reldir).rstrip(os.sep)
+        m = MozillaMakefile(path, reldir, output_directory)
+        self.makefiles.add(m)
+
+        return m
+
+    def load_autoconf_file(self):
+        path = os.path.join(self.topobjdir, 'config', 'autoconf.mk')
+        self.input_files.add(path)
+
+        self.autoconf = BuildFrontend.convert_autoconf_to_dict(path)
+
+    def get_tree_info(self):
+        """Obtains a TreeInfo instance for the parsed build configuration.
+
+        The returned object represents the currently configured build. It can
+        be used to generate files for other build backends.
+        """
+        tree = data.TreeInfo()
+        tree.top_source_directory = self.topsrcdir
+        tree.object_directory = self.topobjdir
+
+        # TODO This is hacky and should be made more robust.
+        autoconf_filename = os.path.join(self.topobjdir, 'config', 'autoconf.mk')
+        variables = BuildFrontend.convert_autoconf_to_dict(autoconf_filename)
+        variables['top_srcdir'] = self.topsrcdir
+        variables['configure_input'] = 'Generated by Build Splendid'
+
+        # Extract data from Makefile.in's.
+        for makefile in self.makefiles.makefiles():
+            # Substitute values from autoconf.mk.
+            variables['srcdir'] = os.path.dirname(makefile.filename)
+
+            makefile.perform_substitutions(variables, raise_on_missing=True)
+
+            # Skip over files that cause us pain. For now, this is just things
+            # with $(shell), as that can cause weirdness.
+            if len(list(makefile.statements.shell_dependent_statements())) > 0:
+                continue
+
+            try:
+                self._load_makefile_into_tree(tree, makefile)
+            except Exception as e:
+                print 'Error loading %s' % makefile.filename
+                traceback.print_exc()
+
+        # Load data from JAR manifests.
+        # TODO look for jar.mn, parse, and load.
+
+        return tree
+
+    def _load_makefile_into_tree(self, tree, makefile):
+        """Loads an individual MozillaMakefile instance into a TreeInfo.
+
+        This is basically a proxy between the MozillaMakefile data extraction
+        interface and TreeInfo.
+        """
+        own_variables = makefile.get_own_variable_names(include_conditionals=True)
+
+        # Prune out lowercase variables, which are defiend as local.
+        lowercase_variables = set([v for v in own_variables if v.islower()])
+
+        used_variables = set()
+
+        # Iterate over all the pieces of information extracted from the
+        # Makefile, normalize them, and add them to the TreeInfo.
+        for obj in makefile.get_data_objects():
+            used_variables |= obj.used_variables
+
+            if obj.source_dir is not None:
+                tree.source_directories.add(obj.source_dir)
+
+            if isinstance(obj, data.XPIDLInfo):
+                # TODO
+                pass
+
+            elif isinstance(obj, data.ExportsInfo):
+                # TODO
+                pass
+
+            elif isinstance(obj, data.LibraryInfo):
+                name = obj.name
+
+                if name in tree.libraries:
+                    raise Exception('Library aready defined: %s' % name)
+
+                def normalize_include(path):
+                    if os.path.isabs(path):
+                        return path
+
+                    return os.path.normpath(os.path.join(obj.directory,
+                        path))
+
+                includes = []
+                for path in obj.includes:
+                    includes.append(normalize_include(path))
+                for path in obj.local_includes:
+                    includes.append(normalize_include(path))
+
+                tree.libraries[name] = {
+                    'c_flags': obj.c_flags,
+                    'cpp_sources': obj.cpp_sources,
+                    'cxx_flags': obj.cxx_flags,
+                    'defines': obj.defines,
+                    'includes': includes,
+                    'pic': obj.pic,
+                    'is_static': obj.is_static,
+                    'source_dir': obj.source_dir,
+                    'output_dir': obj.directory,
+                }
+
+            elif isinstance(obj, data.MiscInfo):
+                if obj.included_files is not None:
+                    for path in obj.included_files:
+                        pass
+                        #v = self.included_files.get(path, set())
+                        #v.add(makefile.filename)
+                        #self.included_files[path] = v
+
+        # Set math \o/
+        unused_variables = own_variables - used_variables - lowercase_variables
+        for var in unused_variables:
+            # TODO report unhandled variables in tree
+            pass
+
+    def parse_idl_file(self, filename, directories):
+        idl_data = open(filename, 'rb').read()
+        p = xpidl.IDLParser()
+        idl = p.parse(idl_data, filename=filename)
+
+        idl.resolve(directories, p)
+
+        return {
+            'filename': filename,
+            'dependencies': [os.path.normpath(dep) for dep in idl.deps],
+        }
+
+    @staticmethod
+    def convert_autoconf_to_dict(path):
+        """Convert the autoconf file at the specified path to a dictionary
+        of name-value pairs.
+
+        This assumes that our autoconf files don't have complex logic. It will
+        raise if they do.
+        """
+        d = {}
+
+        allowed_types = (
+            StatementCollection.VARIABLE_ASSIGNMENT_SIMPLE,
+            StatementCollection.VARIABLE_ASSIGNMENT_RECURSIVE
+        )
+
+        statements = StatementCollection(filename=path)
+
+        # We evaluate ifeq's because the config files /should/ be
+        # static. We don't rewrite these, so there is little risk.
+        statements.strip_false_conditionals(evaluate_ifeq=True)
+
+        for statement, conditions, name, value, type in statements.variable_assignments():
+            if len(conditions):
+                raise Exception(
+                    'Conditional variable assignment encountered (%s) in autoconf file: %s' % (
+                        name, statement.location ))
+
+            if name in d:
+                if type not in allowed_types:
+                    raise Exception('Variable assigned multiple times in autoconf file: %s' % name)
+
+            d[name] = value
+
+        return d
+
+    @staticmethod
+    def get_frontend_files(path, ignore_relative=None, ignore_full=None):
+        """Find all build files in the directory tree under the given path.
+
+        This is a generator of tuples. Each tuple is of the form:
+
+          ( reldir, filename, type )
+
+        Where reldir is the relative directory from the path argument,
+        filename is the str of the build filename, and type is a
+        BUILD_FILE_* constant.
+
+        Arguments:
+
+          path - Path to directory to recurse.
+          ignore_relative - Iterable of relative directory names to ignore.
+          ignore_full - Iterable of full paths to ignore.
+        """
+        assert(os.path.isabs(path))
+
+        if ignore_relative is None:
+            ignore_relative = []
+
+        if ignore_full is None:
+            ignore_full = []
+
+        for root, dirs, files in os.walk(path):
+            relative = root[len(path)+1:]
+
+            # Filter out ignored directories
+            ignored = False
+            for ignore in ignore_relative:
+                if relative.startswith(ignore):
+                    ignored = True
+                    break
+
+            if ignored:
+                continue
+
+            for ignore in ignore_full:
+                if root.startswith(ignore):
+                    ignored = True
+                    break
+
+            if ignored:
+                continue
+
+            for name in files:
+                if name == 'configure.in':
+                    yield (relative, name, BUILD_FILE_CONFIGURE_INPUT)
+                elif name[-6:] == '.mk.in' or name == 'Makefile.in':
+                    yield (relative, name, BUILD_FILE_MAKE_TEMPLATE)
+                elif name[-3:] == '.in':
+                    yield (relative, name, BUILD_FILE_OTHER_IN)
+                elif name == 'Makefile':
+                    yield (relative, name, BUILD_FILE_MAKEFILE)
+                elif name[-3:] == '.mk':
+                    yield (relative, name, BUILD_FILE_MK)
+
diff --git a/python/mozbuild/mozbuild/frontendbs/makefile.py b/python/mozbuild/mozbuild/frontendbs/makefile.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/frontendbs/makefile.py
@@ -0,0 +1,2124 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# This file contains classes for interacting with Makefiles. There are a number
+# of classes that wrap PyMake's classes with useful APIs. This functionality
+# could likely be merged into PyMake if there is desire for doing that. It was
+# developed outside of PyMake so development wouldn't be dependent on changes
+# being merged into PyMake.
+#
+# None of the functionality in this file should be Mozilla-specific. It should
+# be reusable for any Makefile.
+
+from . import data
+
+import collections
+import os
+import pymake.data
+import pymake.parser
+import pymake.parserdata
+import re
+import StringIO
+
+class Expansion(object):
+    """Represents an individual Makefile/PyMake expansion.
+
+    An expansion is a parsed representation of Makefile text. It contains
+    pointers to string literals, functions, other variables, etc.
+    """
+
+    # Classes in this set are for functions which are deterministic. i.e.
+    # for a given set of input arguments, the output will always be the same
+    # regardless of the state of the computer, the filesystem, etc. This list
+    # is used for static analysis and false condition elimination.
+    DETERMINISTIC_FUNCTION_CLASSES = (
+        pymake.functions.SubstFunction,
+        pymake.functions.PatSubstFunction,
+        pymake.functions.StripFunction,
+        pymake.functions.FindstringFunction,
+        pymake.functions.FilterFunction,
+        pymake.functions.FilteroutFunction,
+        pymake.functions.SortFunction,
+        pymake.functions.WordFunction,
+        pymake.functions.WordlistFunction,
+        pymake.functions.WordsFunction,
+        pymake.functions.FirstWordFunction,
+        pymake.functions.LastWordFunction,
+        pymake.functions.DirFunction,
+        pymake.functions.NotDirFunction,
+        pymake.functions.SuffixFunction,
+        pymake.functions.BasenameFunction,
+        pymake.functions.AddSuffixFunction,
+        pymake.functions.AddPrefixFunction,
+        pymake.functions.JoinFunction,
+        pymake.functions.IfFunction,
+        pymake.functions.OrFunction,
+        pymake.functions.AndFunction,
+        pymake.functions.ForEachFunction,
+        pymake.functions.ErrorFunction,
+        pymake.functions.WarningFunction,
+        pymake.functions.InfoFunction,
+    )
+
+    # Classes in this set rely on the filesystem and thus may change during
+    # run-time.
+    FILESYSTEM_FUNCTION_CLASSES = (
+        pymake.functions.WildcardFunction,
+        pymake.functions.RealpathFunction,
+        pymake.functions.AbspathFunction
+    )
+
+    NONDETERMINISTIC_FUNCTION_CLASSES = (
+        # This /might/ be safe depending on the circumstances, but it would be
+        # too difficult to implement.
+        pymake.functions.CallFunction,
+
+        # This is a weird one because the value inside might be non-idempotent.
+        # We could probably support it, but it would require work.
+        pymake.functions.ValueFunction,
+
+        # This transforms the Makefile. We aren't willing to support this for
+        # static analysis yet.
+        pymake.functions.EvalFunction,
+
+        # Run-time deterministic.
+        pymake.functions.OriginFunction,
+
+        # Variables could come from environment. Therefore it is a run-time
+        # deterministic.
+        pymake.functions.FlavorFunction,
+
+        # For obvious reasons.
+        pymake.functions.ShellFunction,
+
+        # variable references aren't always deterministic because the variable
+        # behind it might not be deterministic.
+        pymake.functions.VariableRef,
+        pymake.functions.SubstitutionRef,
+    )
+
+    __slots__ = (
+        # Holds the low-level expansion
+        'expansion',
+
+        '_is_static_string',
+    )
+
+    def __init__(self, expansion=None, s=None, location=None):
+        """Initialize from an existing PyMake expansion or text"""
+
+        self._is_static_string = None
+
+        if expansion and s:
+            raise Exception('Both expansion and string value must not be defined.')
+
+        if expansion is not None:
+            assert(isinstance(expansion,
+                   (pymake.data.Expansion, pymake.data.StringExpansion)))
+            self.expansion = expansion
+        elif s is not None:
+            assert(location is not None)
+
+            data = pymake.parser.Data.fromstring(s, location)
+            self.expansion = pymake.parser.parsemakesyntax(
+                data, 0, (), pymake.parser.iterdata)[0]
+        else:
+            raise Exception('One of expansion or s must be passed')
+
+    def __str__(self):
+        return Expansion.to_str(self.expansion)
+
+    def difference(self, other):
+        """Determine the difference between this and another Expansions.
+
+        Returns None if there is no functional difference. Otherwise, return
+        a tuple of:
+
+          ( why, our_expansion, their_expansion )
+
+        Where why is a str describing what is different.
+        """
+        assert(isinstance(other, Expansion))
+        is_our_exp = isinstance(self.expansion, pymake.data.Expansion)
+        is_other_exp = isinstance(self.expansion, pymake.data.Expansion)
+
+        if is_our_exp != is_other_exp:
+            return ('Expansions not of same type', self, other)
+
+        if not is_our_exp and not is_other_exp:
+            assert(isinstance(self.expansion, pymake.data.StringExpansion))
+            assert(isinstance(other.expansion, pymake.data.StringExpansion))
+
+            if self.expansion.s != other.expansion.s:
+                if self.expansion.s.strip() == other.expansion.s.strip():
+                    return ('StringExpansion content not identical (whitespace)', self, other)
+                else:
+                    return ('StringExpansion content not identical', self, other)
+            else:
+                return None
+
+        us = collections.deque(self.expansion)
+        them = collections.deque(other.expansion)
+        # and after all we're only ordinary men
+
+        while len(us) > 0 and len(them) > 0:
+            ours, ours_is_func = us.popleft()
+            theirs, theirs_is_func = them.popleft()
+
+            if ours_is_func != theirs_is_func:
+                return ('Type of expansion not the same', ours, theirs)
+
+            if ours_is_func:
+                if type(ours) != type(theirs):
+                    return ('Type of function not identical', ours, theirs)
+
+                # Sadly, VariableRef and SubstitutionRef need to be handled as
+                # one-offs because they don't follow the typical Function class
+                # API.
+                if isinstance(ours, pymake.functions.VariableRef):
+                    diff = Expansion(ours.vname).difference(Expansion(theirs.vname))
+                    if diff is not None:
+                        return diff
+                    continue
+
+                if isinstance(ours, pymake.functions.SubstitutionRef):
+                    diff = Expansion(ours.vname).difference(Expansion(theirs.vname))
+                    if diff is not None:
+                        return diff
+
+                    diff = Expansion(ours.substfrom).difference(Expansion(theirs.substfrom))
+                    if diff is not None:
+                        return diff
+
+                    diff = Expansion(ours.substto).difference(Expansion(theirs.substto))
+                    if diff is not None:
+                        return diff
+
+                    continue
+
+                if len(ours) != len(theirs):
+                    return ('Length of function arguments not identical', ours, theirs)
+
+                for offset in range(0, len(ours)):
+                    diff = Expansion(ours[offset]).difference(Expansion(theirs[offset]))
+                    if diff is not None:
+                        return diff
+
+                continue
+
+            else:
+                assert(isinstance(ours, str))
+                assert(isinstance(theirs, str))
+
+                if ours != theirs:
+                    message = 'Expansion member string content not identical'
+                    if ours.strip() == theirs.strip():
+                        message += ' (whitespace)'
+
+                    return (
+                        message,
+                        Expansion(s=ours, location=self.location),
+                        Expansion(s=theirs, location=other.location)
+                    )
+
+                continue
+
+        return None
+
+
+    def split(self):
+        """Split this expansion into words and return the list."""
+        s = str(self).strip()
+        if len(s) > 1:
+            return s.split(' ')
+        else:
+            return []
+
+    @property
+    def location(self):
+        """Obtain the pymake.parserdata.Location for this expansion."""
+        return self.expansion.loc
+
+    @property
+    def is_static_string(self):
+        """Indicates whether the expansion is a static string.
+
+        A static string is defined as an expansion that consists of no elements
+        beside strongly typed strings."""
+        if self._is_static_string is None:
+            if isinstance(self.expansion, pymake.data.StringExpansion):
+                self._is_static_string = True
+                return True
+
+            assert(isinstance(self.expansion, pymake.data.Expansion))
+
+            for e, is_func in self.expansion:
+                if is_func:
+                    self._is_static_string = False
+                    return False
+
+            self._is_static_string = True
+
+        return self._is_static_string
+
+    def is_filesystem_dependent(self):
+        """Indicates whether this expansion is dependent on the state of the
+        filesystem."""
+        for f in self.functions(descend=True):
+            if isinstance(f, Expansion.FILESYSTEM_FUNCTION_CLASSES):
+                return True
+
+        return False
+
+    def is_shell_dependent(self):
+        """Indicates whether this expansion is dependent on the output of a
+        shell command."""
+        for f in self.functions(descend=True):
+            if isinstance(f, pymake.functions.ShellFunction):
+                return True
+
+        return False
+
+    def functions(self, descend=False):
+        """A generator for functions in this expansion.
+
+        Each returned item is a pymake.functions.Function instance.
+
+        Arguments:
+
+        descend -- If True, descend and find inner functions.
+        """
+        if isinstance(self.expansion, pymake.data.Expansion):
+            for e, is_func in self.expansion:
+                if is_func:
+                    yield e
+
+                    if descend:
+                        if isinstance(e, (pymake.functions.VariableRef, pymake.functions.SubstitutionRef)):
+                            continue
+
+                        for i in range(0, len(e)):
+                            for f in Expansion(e[i]).functions(descend=True):
+                                yield f
+
+    def variable_references(self, descend=False):
+        """Generator for all variable references in this expansion.
+
+        Returns Expansion instances which represent the variable name. These
+        Expansions will typically be static strings representing the variable
+        names, but it is possible for them to reference other variables.
+
+        Arguments:
+
+        descend -- If True, descend into child expansions and find references.
+        """
+        for f in self.functions(descend=descend):
+            if not isinstance(f, pymake.functions.VariableRef):
+                continue
+
+            yield Expansion(f.vname, location=f.loc)
+
+    def is_deterministic(self, variables=None, missing_is_deterministic=True):
+        """Returns whether the expansion is determinstic.
+
+        A deterministic expansion is one whose value is always guaranteed.
+        If variables are not provided, a deterministic expansion is one that
+        consists of only string data or transformations on strings. If any
+        variables are encounted, the expansion will be non-deterministic by
+        the nature of Makefiles, since the variables could come from the
+        execution environment or command line arguments. But, we assume
+        the current state as defined by the arguments is what will occur
+        during real execution. If you wish to override this, set the
+        appropriate arguments.
+        """
+
+        # The simple case is a single string
+        if isinstance(self.expansion, pymake.data.StringExpansion):
+            return True
+
+        assert(isinstance(self.expansion, pymake.data.Expansion))
+
+        for e, is_func in self.expansion:
+            # A simple string is always deterministic.
+            if not is_func:
+                continue
+
+            if isinstance(e, Expansion.DETERMINISTIC_FUNCTION_CLASSES):
+                for i in range(0, len(e)):
+                    child = Expansion(expansion=e[i])
+                    if not child.is_deterministic(variables=variables):
+                        return False
+
+                # If we got here, all child expansions were evaluated and we
+                # are deterministic.
+                continue
+
+            # We don't have a deterministic function. So, we perform deeper
+            # inspection on some of these.
+
+            if isinstance(e, pymake.functions.VariableRef) and variables is not None:
+                if isinstance(e.vname, pymake.data.StringExpansion):
+                    name = e.vname.s
+
+                    flavor, source, value = variables.get(name, expand=True)
+
+                    # The variable wasn't defined.
+                    if flavor is None:
+                        if missing_is_deterministic:
+                            continue
+                        else:
+                            return False
+
+                    # We found a variable! If it is simple, that means it
+                    # depends on nothing else. And, the variable should be
+                    # captured by the current context, so we can assume it is
+                    # deterministic.
+                    if flavor == pymake.data.Variables.FLAVOR_SIMPLE:
+                        continue
+
+                    # Else, we evaluate the expansion on its own.
+                    v_exp = Expansion(expansion=value)
+                    if not v_exp.is_deterministic(variables=variables,
+                            missing_is_deterministic=missing_is_deterministic):
+                        return False
+
+                    continue
+
+                # We don't bother with more complicated expansions.
+                else:
+                    return False
+
+
+            return False
+
+        return True
+
+    @staticmethod
+    def to_str(e, error_on_function=False, escape_variables=False):
+        """Convert an expansion to a string.
+
+        This effectively converts a string back to the form it was defined as
+        in the Makefile. This is different from the resolvestr() method on
+        Expansion classes because it doesn't actually expand variables.
+
+        If error_on_function is True, an Exception will be raised if a
+        function is encountered. This provides an easy mechanism to
+        conditionally convert expansions only if they contain static data.
+
+        If escape_variables is True, individual variable sigil elements will
+        be escaped (i.e. '$' -> '$$').
+        """
+        if isinstance(e, pymake.data.StringExpansion):
+            if escape_variables:
+                return e.s.replace('$', '$$')
+
+            return e.s
+        elif isinstance(e, pymake.data.Expansion):
+            parts = []
+            for ex, is_func in e:
+                if is_func:
+                    if error_on_function:
+                        raise Exception('Unable to perform expansion due to function presence: %s' % ex)
+
+                    parts.append(Expansion.function_to_string(ex))
+                else:
+                    if escape_variables:
+                        parts.append(ex.replace('$','$$'))
+                    else:
+                        parts.append(ex)
+
+            return ''.join(parts)
+        else:
+            raise Exception('Unhandled expansion type: %s' % e)
+
+    @staticmethod
+    def to_list(e):
+        """Convert an expansion to a list.
+
+        This is similar to expansion_to_string() except it returns a list."""
+        s = Expansion.to_str(e).strip()
+
+        if s == '':
+            return []
+        else:
+            return s.split(' ')
+
+    @staticmethod
+    def is_static_string(e):
+        """Returns whether the expansion consists of only string data."""
+
+        if isinstance(e, pymake.data.StringExpansion):
+            return True
+        elif isinstance(e, pymake.data.Expansion):
+            for ex, is_func in e:
+                if is_func:
+                    return False
+
+                assert(isinstance(ex, str))
+
+            return True
+        else:
+            raise Exception('Unhandled expansion type: %s' % e)
+
+    @staticmethod
+    def function_to_string(ex):
+        """Convert a PyMake function instance to a string."""
+        if isinstance(ex, pymake.functions.AbspathFunction):
+            return '$(abspath %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.AddPrefixFunction):
+            return '$(addprefix %s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1])
+            )
+
+        elif isinstance(ex, pymake.functions.AddSuffixFunction):
+            return '$(addsuffix %s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1])
+            )
+
+        elif isinstance(ex, pymake.functions.BasenameFunction):
+            return '$(basename %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.CallFunction):
+            return '$(call %s)' % ','.join(
+                [Expansion.to_str(e) for e in ex])
+
+        elif isinstance(ex, pymake.functions.DirFunction):
+            return '$(dir %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.ErrorFunction):
+            return '$(error %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.EvalFunction):
+            return '$(eval %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.FilterFunction):
+            return '$(filter %s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1])
+            )
+
+        elif isinstance(ex, pymake.functions.FilteroutFunction):
+            return '$(filter-out %s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1])
+            )
+
+        elif isinstance(ex, pymake.functions.FindstringFunction):
+            return '$(findstring %s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1])
+            )
+
+        elif isinstance(ex, pymake.functions.FirstWordFunction):
+            return '$(firstword %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.ForEachFunction):
+            return '$(foreach %s,%s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1]),
+                Expansion.to_str(ex[2])
+            )
+
+        elif isinstance(ex, pymake.functions.IfFunction):
+            return '$(if %s)' % ','.join(
+                [Expansion.to_str(e) for e in ex])
+
+        elif isinstance(ex, pymake.functions.NotDirFunction):
+            return '$(notdir %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.OrFunction):
+            return '$(or %s)' % ','.join(
+                [Expansion.to_str(e) for e in ex])
+
+        elif isinstance(ex, pymake.functions.PatSubstFunction):
+            return '$(patsubst %s,%s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1]),
+                Expansion.to_str(ex[2])
+            )
+
+        elif isinstance(ex, pymake.functions.ShellFunction):
+            return '$(shell %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.SortFunction):
+            return '$(sort %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.StripFunction):
+            return '$(strip %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.SubstitutionRef):
+            return '$(%s:%s=%s)' % (
+                Expansion.to_str(ex.vname),
+                Expansion.to_str(ex.substfrom),
+                Expansion.to_str(ex.substto)
+            )
+
+        elif isinstance(ex, pymake.functions.SubstFunction):
+            return '$(subst %s,%s,%s)' % (
+                Expansion.to_str(ex[0]),
+                Expansion.to_str(ex[1]),
+                Expansion.to_str(ex[2])
+            )
+
+        elif isinstance(ex, pymake.functions.WarningFunction):
+            return '$(warning %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.WildcardFunction):
+            return '$(wildcard %s)' % Expansion.to_str(ex[0])
+
+        elif isinstance(ex, pymake.functions.VariableRef):
+            if isinstance(ex.vname, pymake.data.StringExpansion):
+                # AFAICT, there is no way to determine if a variable ref is
+                # special and doesn't have parens. So, we need to hard code
+                # this manually.
+                if ex.vname.s in Statement.AUTOMATIC_VARIABLES:
+                    return '$%s' % ex.vname.s
+
+                return '$(%s)' % ex.vname.s
+            else:
+                return '$(%s)' % Expansion.to_str(ex.vname)
+
+        else:
+            raise Exception('Unhandled function type: %s' % ex)
+
+
+class Statement(object):
+    """Holds information about an individual PyMake statement.
+
+    This is a wrapper around classes in pymake.parserdata that provides
+    useful features for low-level statement inspection and interaction.
+
+    All parser output from pymake.parserdata is an instance of this class or
+    is an instance of a class derived from this one.
+
+    We have overloaded a lot of functionality in this base class. The object
+    model would be better if each statement type stood in its own class. The
+    main reason it wasn't done this way is laziness. Consumers should not rely
+    on many classes being rolled into the generic Statement class forever.
+    """
+
+    __slots__ = (
+        # The actual statement
+        'statement',
+    )
+
+    # All of the possible output classes from the PyMake parser. Not all derive
+    # from pymake.parserdata.Statement, but we treat them all like they do.
+    ALL_PARSERDATA_STATEMENT_CLASSES = (
+        pymake.parserdata.Rule,
+        pymake.parserdata.StaticPatternRule,
+        pymake.parserdata.Command,
+        pymake.parserdata.SetVariable,
+        pymake.parserdata.EqCondition,
+        pymake.parserdata.IfdefCondition,
+        pymake.parserdata.ElseCondition,
+        pymake.parserdata.ConditionBlock,
+        pymake.parserdata.Include,
+        pymake.parserdata.VPathDirective,
+        pymake.parserdata.ExportDirective,
+        pymake.parserdata.UnexportDirective,
+        pymake.parserdata.EmptyDirective,
+    )
+
+    # Classes that contain a single expansion.
+    SINGLE_EXPANSION_CLASSES = (
+        pymake.parserdata.Command,
+        pymake.parserdata.EmptyDirective,
+        pymake.parserdata.ExportDirective,
+        pymake.parserdata.IfdefCondition,
+        pymake.parserdata.Include,
+        pymake.parserdata.VPathDirective,
+    )
+
+    # Variables that are automatically available in Makefiles.
+    AUTOMATIC_VARIABLES = set(['@', '%', '<', '?', '^', '+', '|', '*'])
+
+    def __init__(self, statement):
+        assert(isinstance(statement, Statement.ALL_PARSERDATA_STATEMENT_CLASSES))
+
+        self.statement = statement
+
+    def __eq__(self, other):
+        return self.difference(other) is None
+
+    def __str__(self):
+        """Convert this statement back to its Makefile representation."""
+        if self.is_command:
+            return self.command_string
+        elif self.is_condition:
+            return ConditionBlock.condition_str(self)
+        elif self.is_empty_directive:
+            return str(Expansion(self.statement.exp))
+        elif self.is_export:
+            return 'export %s' % Expansion(self.statement.exp)
+        elif self.is_include:
+            return 'include %s' % Expansion(self.statement.exp)
+        elif self.is_rule:
+            # We jump through hoops to preserve whitespace
+            sep = self.target_separator
+
+            dep_str = Expansion.to_str(self.statement.depexp)
+            if len(dep_str) > 0 and dep_str[0] not in (' ', '\t'):
+                sep += ' '
+
+            return '\n%s%s%s' % (
+                Expansion.to_str(self.statement.targetexp),
+                sep,
+                dep_str
+            )
+        elif self.is_set_variable:
+            return self.setvariable_string
+        elif self.is_static_pattern_rule:
+            sep = self.target_separator
+            pattern = Expansion.to_str(self.statement.patternexp)
+            dep = Expansion.to_str(self.statement.depexp)
+
+            if len(pattern) > 0 and pattern[0] not in (' ', '\t'):
+                sep += ' '
+
+            return ('\n%s%s%s:%s' % (
+                Expansion.to_str(self.statement.targetexp),
+                sep,
+                pattern,
+                dep
+            ))
+        elif self.is_vpath:
+            return 'vpath %s' % Expansion(self.statement.exp)
+        else:
+            raise Exception('Unhandled statement type: %s' % self.statement)
+
+    def __repr__(self):
+        s = None
+        if self.is_condition:
+            s = str(self.statement)
+        else:
+            fd = StringIO.StringIO()
+            self.statement.dump(fd, '')
+            s = fd.getvalue()
+
+        return '<%s>' % s
+
+    # The following are simple tests for the type of statement
+    @property
+    def is_rule(self):
+        return isinstance(self.statement, pymake.parserdata.Rule)
+
+    @property
+    def is_static_pattern_rule(self):
+        return isinstance(self.statement, pymake.parserdata.StaticPatternRule)
+
+    @property
+    def is_command(self):
+        return isinstance(self.statement, pymake.parserdata.Command)
+
+    @property
+    def is_set_variable(self):
+        return isinstance(self.statement, pymake.parserdata.SetVariable)
+
+    @property
+    def is_ifeq(self):
+        return isinstance(self.statement, pymake.parserdata.EqCondition)
+
+    @property
+    def is_ifdef(self):
+        return isinstance(self.statement, pymake.parserdata.IfdefCondition)
+
+    @property
+    def is_else(self):
+        return isinstance(self.statement, pymake.parserdata.ElseCondition)
+
+    @property
+    def is_condition_block(self):
+        return False
+
+    @property
+    def is_include(self):
+        return isinstance(self.statement, pymake.parserdata.Include)
+
+    @property
+    def is_vpath(self):
+        return isinstance(self.statement, pymake.parserdata.VPathDirective)
+
+    @property
+    def is_export(self):
+        return isinstance(self.statement, pymake.parserdata.ExportDirective)
+
+    @property
+    def is_unexport(self):
+        return isinstance(self.statement, pymake.parserdata.UnExportDirective)
+
+    @property
+    def is_empty_directive(self):
+        return isinstance(self.statement, pymake.parserdata.EmptyDirective)
+
+    @property
+    def is_condition(self):
+        return isinstance(self.statement, pymake.parserdata.Condition)
+
+
+    # Accessors available to all statements
+    def lines(self):
+        """Returns an iterator of str representing the statement transformed
+        to Makefile syntax."""
+        yield str(self)
+
+    @property
+    def location(self):
+        """Returns the best pymake.parserdata.Location instance for this
+        instance.
+
+        May return None if a suitable location is not available.
+        """
+
+        # Expansions is a generator, so we can't subscript.
+        for e in self.expansions:
+            return e.location
+
+        return None
+
+    def difference(self, other):
+        """Determines the difference between this and another Statement.
+
+        We define equivalence to mean the composition of the statement is
+        equivalent. We do not test things like locations or the expanded value
+        of variables, etc.
+
+        Practically speaking, if two statement appears on consecutive lines
+        and the first does not have any side-effects, then the two statements
+        are equivalent.
+
+        If there is no difference, None is returned. If there is a difference,
+        returns a tuple of:
+
+          ( why, our_expansion, their_expansion )
+
+        Where why is a str explaining the difference and the expansion members
+        can be Expansion instances that caused the disagreement.
+        """
+        if not isinstance(other, Statement):
+            return ('Other type is not a Statement', None, None)
+
+        if type(self.statement) != type(other.statement):
+            return ('pymake statement type not identical', None, None)
+
+        our_expansions = collections.deque(self.expansions)
+        other_expansions = collections.deque(other.expansions)
+
+        while len(our_expansions) > 0 and len(other_expansions) > 0:
+            ours = our_expansions.popleft()
+            theirs = other_expansions.popleft()
+
+            difference = ours.difference(theirs)
+            if difference is None:
+                continue
+
+            return difference
+
+        if len(our_expansions) == 0 and len(other_expansions) == 0:
+            return None
+
+        ret_ours = None
+        ret_theirs = None
+        if len(our_expansions) > 0:
+            ret_ours = our_expansions.popleft()
+
+        if len(their_expansions) > 0:
+            ret_theirs = other_expansions.popleft()
+
+        return ('Length of expansions not equivalent', ret_ours, ret_theirs)
+
+    @property
+    def expansions(self):
+        """Returns an iterator over all expansions in this statement.
+
+        Each returned item is an Expansion instance.
+        """
+        if isinstance(self.statement, Statement.SINGLE_EXPANSION_CLASSES):
+            yield Expansion(expansion=self.statement.exp)
+        elif self.is_ifeq:
+            yield Expansion(expansion=self.statement.exp1)
+            yield Expansion(expansion=self.statement.exp2)
+        elif self.is_rule:
+            yield Expansion(expansion=self.statement.targetexp)
+            yield Expansion(expansion=self.statement.depexp)
+        elif self.is_static_pattern_rule:
+            yield Expansion(expansion=self.statement.targetexp)
+            yield Expansion(expansion=self.statement.patternexp)
+            yield Expansion(expansion=self.statement.depexp)
+        elif self.is_set_variable:
+            if self.statement.targetexp is not None:
+                yield Expansion(expansion=self.statement.targetexp)
+
+            yield Expansion(expansion=self.statement.vnameexp)
+            yield Expansion(s=self.statement.value, location=self.statement.valueloc)
+        elif self.is_else:
+            return
+        else:
+            raise Exception('Unhandled statement type: %s' % self)
+
+    def variable_references(self, descend=False):
+        """A generator for variables referenced in this statement.
+
+        Each returned item is an Expansion instance.
+
+        Arguments:
+
+        descend -- If True, descend into expansions contained within primary
+                   expansions.
+        """
+        for e in self.expansions:
+            for v in e.variable_references(descend=descend): yield v
+
+    def are_expansions_deterministic(self, variables=None):
+        """Determines whether the expansions in this statement are
+        deterministic."""
+
+        # TODO figure out what to do about target expansions. Resolving
+        # these expansions results in access to Makefile.gettarget()
+        if self.is_set_variable and self.statement.targetexp is not None:
+            return False
+
+        for e in self.expansions:
+            if not e.is_deterministic(variables=variables):
+                return False
+
+        return True
+
+    # Statement-specific accessors and methods. If invoked on the wrong
+    # statement type, expect an assertion failure.
+
+    @property
+    def command_string(self):
+        """Converts a command expansion back into its string form.
+
+        Commands are interesting beasts for a couple of reasons.
+
+        First, they can be multi-line. A tab character is inserted at the
+        beginning of each line.
+
+        There also might be variable references inside the command.
+        To the shell, $foo is correct. However, to Makefiles, we need
+        $$foo.
+        """
+        assert(self.is_command)
+
+        s = Expansion.to_str(self.statement.exp, escape_variables=True)
+
+        return '\n'.join(['\t%s' % line for line in s.split('\n')])
+
+    @property
+    def command_name(self):
+        """Obtain the name of the command being executed.
+
+        Returns a str or None if the command is empty or doesn't appear to be a
+        command.
+        """
+        assert(self.is_command)
+
+        words = Expansion(self.statement.exp).split()
+        if len(words) == 0:
+            return None
+
+        command = words[0]
+        if command.find('=') != -1:
+            return None
+
+        return command.lstrip('@#-+(')
+
+    @property
+    def has_doublecolon(self):
+        """Returns whether the rule has a double-colon."""
+        assert(self.is_rule or self.is_static_pattern_rule)
+
+        return self.statement.doublecolon
+
+    @property
+    def target(self):
+        """The expansion for the rule target."""
+        assert(self.is_rule or self.is_static_pattern_rule)
+
+        return Expansion(self.statement.targetexp)
+
+    @property
+    def pattern(self):
+        """The expansion for this static rule pattern."""
+        assert(self.is_static_pattern_rule);
+
+        return Expansion(self.statement.patternexp)
+
+    @property
+    def prerequisites(self):
+        """The expansion for the rule prerequisites."""
+        assert(self.is_rule or self.is_static_pattern_rule);
+
+        return Expansion(self.statement.depexp)
+
+    @property
+    def target_separator(self):
+        """Returns the colon separator after the target for rules."""
+        assert(self.is_rule or self.is_static_pattern_rule)
+
+        if self.has_doublecolon:
+            return '::'
+        else:
+            return ':'
+
+    @property
+    def expected_condition(self):
+        """For condition statements, returns the expected condition of the test
+        for the branch under the statement to be executed."""
+        assert(self.is_ifeq or self.is_ifdef)
+
+        return self.statement.expected
+
+    @property
+    def required(self):
+        """Whether the statement is required."""
+        assert(self.is_include)
+
+        return self.statement.required
+
+    @property
+    def token(self):
+        """Returns the token for this statement."""
+        assert(self.is_set_variable)
+
+        return self.statement.token
+
+    @property
+    def setvariable_string(self):
+        """Converts a SetVariable statement to a string.
+
+        SetVariable statements are a little funky. In the common case, they
+        have the form "foo = bar". If they have a target expression, there
+        is the form "targ: foo = bar". And, for multi-line variables, you
+        use the define directive. It ia all pretty funky.
+        """
+
+        assert(self.is_set_variable)
+
+        value = self.value.replace('#', '\\#')
+
+        if self.statement.targetexp is not None:
+            return '%s: %s %s %s' % (
+                    Expansion.to_str(self.statement.targetexp),
+                    self.vname,
+                    self.token,
+                    value
+                )
+
+        # Now we have the common case. But, it could be multiline.
+        multiline = value.count('\n') > 0
+
+        if multiline:
+            # According to 6.8 of the Make manual, the equals is optional.
+            return 'define %s\n%s\nendef\n' % (self.vname, value)
+        else:
+            sep = self.token
+            if len(value) and value[0] not in (' ', '\t'):
+                sep += ' '
+            return ('%s %s%s' % (self.vname, sep, value))
+
+    @property
+    def value(self):
+        """Returns the value of this statement."""
+        assert(self.is_set_variable)
+
+        return self.statement.value
+
+    @property
+    def value_expansion(self):
+        """Returns the value of this SetVariable statement as an expansion.
+
+        By default, variable values are stored as strings. They can be
+        upgraded to expansions upon request."""
+        assert(self.is_set_variable)
+
+        data = pymake.parser.Data.fromstring(self.statement.value, self.statement.valueloc)
+        return Expansion(expansion=pymake.parser.parsemakesyntax(data, 0, (),
+                         pymake.parser.iterdata)[0])
+
+    @property
+    def vname(self):
+        """Returns the variable name as an expansion."""
+        assert(self.is_set_variable)
+
+        return Expansion(self.statement.vnameexp)
+
+class ConditionBlock(Statement):
+    """Represents a condition block statement.
+
+    The condition block is a collection of conditions and statements inside
+    those conditions. The structure mimics that of
+    pymake.parserdata.ConditionBlock. However, we provide some higher-level
+    APIs."""
+
+    __slots__ = (
+        # Array of tuples of ( condition statement, [ statements ] )
+        'conditions',
+    )
+
+    def __init__(self, statement):
+        assert(isinstance(statement, pymake.parserdata.ConditionBlock))
+
+        Statement.__init__(self, statement)
+
+        self.conditions = []
+
+        for condition, statements in statement:
+            wrapped = []
+            for s in statements:
+                if isinstance(s, pymake.parserdata.ConditionBlock):
+                    wrapped.append(ConditionBlock(s))
+                else:
+                    wrapped.append(Statement(s))
+            self.conditions.append((Statement(condition), wrapped))
+
+    def __str__(self):
+        """Convert the condition block back to its Makefile representation."""
+        return '\n'.join(self.lines())
+
+    def __iter__(self):
+        return iter(self.conditions)
+
+    def __len__(self):
+        return len(self.conditions)
+
+    def __getitem__(self, i):
+        return self.conditions[i]
+
+    @property
+    def is_condition_block(self):
+        return True
+
+    @property
+    def is_ifdef_only(self):
+        """Is the condition block composed only of ifdef statements?"""
+        for condition, statements in self:
+            if condition.is_ifeq:
+                return False
+
+            assert(condition.is_ifdef or condition.is_else)
+
+        return True
+
+    @property
+    def has_ifeq(self):
+        """Does the condition block have any ifeq components?"""
+        return not self.is_ifdef_only
+
+    @property
+    def expansions(self):
+        """A generator for expansions in the conditions block."""
+        for condition, statements in self:
+            for e in condition.expansions: yield e
+            for s in statements:
+                for e in s.expansions: yield e
+
+    def lines(self):
+        """Returns an iterable of str representing the Makefile of lines
+        composing this condition block."""
+        index = 0
+        for condition, statements in self:
+            yield ConditionBlock.condition_str(condition, index)
+            index += 1
+
+            for statement in statements:
+                yield str(statement)
+
+        yield 'endif'
+
+    def determine_condition(self, makefile, allow_nondeterministic=False):
+        """Evaluate conditions in this block and determine which one executes.
+
+        Possible return values:
+          int -- Index of the condition that evaluated to True.
+          None -- Unable to determine condition.
+          False -- The condition didn't evaluate to True.
+
+        False should only be returned on condition blocks consisting of one
+        condition.
+
+        None will likely be returned if a non-deterministic expansion is seen
+        in a condition.
+
+        Arguments:
+
+        makefile -- Makefile context for execution.
+        allow_nondeterministic -- If a nondeterministic expansion is seen,
+                                  try to evaluate it. This is very dangerous.
+        """
+        for i in range(0, len(self)):
+            condition = self.conditions[i][0]
+
+            if condition.is_ifdef:
+                if condition.statement.evaluate(makefile):
+                    return i
+
+            elif condition.is_ifeq:
+                deterministic = condition.are_expansions_deterministic(makefile.variables)
+
+                if deterministic:
+                    if condition.statement.evaluate(makefile):
+                        return i
+                    else:
+                        continue
+
+                if not allow_nondeterministic:
+                    return None
+
+            # If we get to the else condition, all other branches must have
+            # evaluated to False.
+            elif condition.is_else:
+                assert(i == len(self) - 1)
+                return i
+
+            else:
+                raise Exception('Unexpected condition type: %s' % type(condition.statement))
+
+        assert(len(self) == 1)
+        return False
+
+    @staticmethod
+    def condition_str(statement, index=None):
+        """Convert a condition to a string representation.
+
+        The index argument defines the index of this condition inside a
+        condition block. If the index is greater than 0, an else will be
+        added to the representation.
+        """
+
+        prefix = ''
+        if (statement.is_ifdef or statement.is_ifeq) and index > 0:
+            prefix = 'else '
+
+        if statement.is_ifdef:
+            s = Expansion(statement.statement.exp)
+
+            if statement.expected_condition:
+                return '%sifdef %s' % ( prefix, s )
+            else:
+                return '%sifndef %s' % ( prefix, s )
+
+        elif statement.is_ifeq:
+            s = ','.join([
+                Expansion.to_str(statement.statement.exp1).strip(),
+                Expansion.to_str(statement.statement.exp2).strip()
+            ])
+
+            if statement.expected_condition:
+                return '%sifeq (%s)' % ( prefix, s )
+            else:
+                return '%sifneq (%s)' % ( prefix, s )
+
+        elif statement.is_else:
+            return 'else'
+        else:
+            raise Exception('Unhandled condition type: %s' % statement.statement)
+
+    def evaluation_is_deterministic(self, variables=None,
+                                    missing_is_deterministic=True):
+        """Returns whether evaluation of this condition block is determinstic.
+
+        Evaluation is considered deterministic if all conditions are
+        deterministic. Note that an else condition is always determinstic, so
+        for simple ifeq..else..end, if the ifeq is determinstic, the whole
+        thing is deterministic.
+        """
+        pass
+
+class StatementCollection(object):
+    """Mid-level API for interacting with Makefile statements.
+
+    This is effectively a wrapper around PyMake's parser output. It can
+    be used to extract data from low-level parser output. It can even perform
+    basic manipulation of Makefiles.
+
+    If you want to perform static analysis of Makefiles or want to poke around
+    at what's inside, this is the class to use or extend.
+    """
+
+    VARIABLE_ASSIGNMENT_SIMPLE = 1
+    VARIABLE_ASSIGNMENT_RECURSIVE = 2
+    VARIABLE_ASSIGNMENT_APPEND = 3
+    VARIABLE_ASSIGNMENT_CONDITIONAL = 4
+
+    __slots__ = (
+         # String filename we loaded from. A filename must be associated with
+         # a Makefile for things to work properly.
+        'filename',
+
+        # Directory the Makefile runs in. By default, this is set to the
+        # directory of the filename. However, it is completely valid for
+        # instantiators to override this with something else. A use case would
+        # be if the contents are being read from one location but should
+        # appear as if it is loaded from elsewhere. This is useful for
+        # tricking filesystem functions into working, for example.
+        'directory',
+
+        # List of our normalized statements. Each element is a Statement
+        # or derived class.
+        '_statements',
+    )
+
+    def __init__(self, filename=None, buf=None, directory=None):
+        """Construct a set of statements.
+
+        If buf is defined, filename must all be defined. If buf is defined,
+        statements will be read from that string. Else, statements will be
+        read from the passed filename.
+        """
+        if buf is not None:
+            assert(filename is not None)
+            self._load_raw_statements(pymake.parser.parsestring(buf, filename))
+        elif filename:
+            self._load_raw_statements(pymake.parser.parsefile(filename))
+        else:
+            raise Exception('Invalid arguments given to constructor')
+
+        self.filename  = filename
+
+        if directory is not None:
+            self.directory = directory
+        else:
+            self.directory = os.path.dirname(filename)
+
+    def lines(self):
+        """Emit lines that constitute a Makefile for this collection.
+
+        To generate the Makefile representation of this instance, simply:
+
+          '\n'.join(foo.lines())
+
+        Or,
+
+          for line in foo.lines():
+            print >>fh, line
+        """
+        for statement in self._statements:
+            for line in statement.lines(): yield line
+
+    def difference(self, other):
+        """Obtain the difference between this instance and another one.
+
+        This is a helper method to identify where/how two supposedly
+        equivalent Makefiles differ.
+
+        If the two instances are functionally equivalent, None is returned.
+        If they are different, a dictionary is returned with the form:
+          {
+            'index': 6, # Numeric index of statements at which things were
+                        # different
+            'ours': Statement,   # Our statement that didn't match
+            'theirs': Statement, # Their statement that didn't match
+            'our_expansion': Expansion, # Our expansion that didn't match
+            'their_expansion': Expansion, # Their expansion that didn't match
+            'why': 'X was Y', # str explaining why they were different
+          }
+        """
+        assert(isinstance(other, StatementCollection))
+        our_statements = collections.deque(self.expanded_statements(suppress_condition_blocks=True))
+        other_statements = collections.deque(other.expanded_statements(suppress_condition_blocks=True))
+
+        error = {
+            'index': -1,
+            'our_line': -1,
+            'their_line': -1,
+            'why': 'Unknown',
+        }
+
+        while len(our_statements) > 0 and len(other_statements) > 0:
+            error['index'] += 1
+            ours = our_statements.popleft()[0]
+            theirs = other_statements.popleft()[0]
+
+            # Pure laziness
+            error['ours'] = ours
+            error['theirs'] = theirs
+
+            difference = ours.difference(theirs)
+            if difference is None:
+                continue
+
+            error['why'] = difference[0]
+            error['our_expansion'] = difference[1]
+            error['their_expansion'] = difference[2]
+            return error
+
+        if len(our_statements) == 0 and len(other_statements) == 0:
+            return None
+
+        error['why'] = 'statement lengths did not agree'
+        return error
+
+    def expanded_statements(self, suppress_condition_blocks=False):
+        """Returns an iterator over the statements in this collection.
+
+        Each returned item is a tuple of:
+
+            ( Statement, [conditions] )
+
+        Each Statement is the Statement instance being returned. The 2nd
+        member is a list of conditions that must be satisfied for this
+        statement to be evaluated. Each element is merely a reference to
+        a Statement that was emitted previously. In other words, this is a
+        convenient repackaging to make less stateful consumption easier.
+        An emitted condition does not contain itself on the preconditions
+        stack.
+
+        Condition blocks are emitted as a Statement first followed by all
+        of their individual statements, starting with the condition for
+        the first branch.
+
+        It is possible to detect the end of a condition block by noting when
+        len(conditions) decreases. A new branch in the same condition block
+        is entered when entry[0].is_condition is True. The implementation of
+        various methods in this class demonstrate this technique and can be
+        used as a reference.
+
+        Arguments:
+
+        suppress_condition_blocks -- If True, the Condition Block statement
+                                     will not be emitted. However, everything
+                                     else is the same.
+        """
+        condition_stack = []
+
+        def emit_statements(statements):
+            for statement in statements:
+                emit = True
+                if statement.is_condition_block and suppress_condition_blocks:
+                    emit = False
+
+                if emit:
+                    yield (statement, condition_stack)
+
+                if statement.is_condition_block:
+                    for condition, inner in statement:
+                        yield (condition, condition_stack)
+                        condition_stack.append(condition)
+
+                        for t in emit_statements(inner):
+                            yield t
+
+                        condition_stack.pop()
+
+        for t in emit_statements(self._statements): yield t
+
+        assert(len(condition_stack) == 0)
+
+    def expansions(self):
+        """A generator for all Expansions in this collection.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions, expansion )
+
+        Where expansion is an Expansion and statement is the Statement it
+        belongs to.
+        """
+        statements = self.expanded_statements(suppress_condition_blocks=True)
+        for statement, conditions in statements:
+            # Condition blocks expand to their child elements. The child
+            # elements come after, so we ignore to avoid double output.
+            if statement.is_condition_block:
+                continue
+
+            for expansion in statement.expansions:
+                yield (statement, conditions, expansion)
+
+    def ifdefs(self):
+        """A generator of ifdef metadata in this collection.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions, name, expected )
+
+        The first member is the underlying Statement instance. name is a str
+        of the variable being checked for definintion. expected is the boolean
+        indicating the expected evaluation for the condition to be satisfied.
+        Finally, conditions is a list of conditions that must be satisfied for
+        this statement to be evaluated.
+
+        Please note that "name" is a str, not an Expansion. This is because
+        ifdef statements operate on variable names, not variables themselves.
+
+        name and expected can be accessed from the underlying Statement, of
+        course. They are provided explicitly for convenience.
+        """
+        statements = self.expanded_statements(suppress_condition_blocks=True)
+        for statement, conditions in statements:
+            if not statement.is_ifdef:
+                continue
+
+            yield (statement,
+                   conditions,
+                   str(list(statement.expansions)[0]),
+                   statement.statement.expected)
+
+    def includes(self):
+        """A generator of includes metadata.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions, path )
+
+        The first member is the underlying Statement. The second is a list
+        of conditions that must be satisfied for this statement to be executed.
+        Finally, we have the path Expansion for this statement. It is up
+        to the caller to expand the expansion.
+        """
+        for statement, conditions in self.expanded_statements():
+            if not statement.is_include:
+                continue
+
+            yield (statement, conditions, list(statement.expansions)[0])
+
+    def variable_assignments(self):
+        """A generator of variable assignments.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions, name, value, type )
+
+        The first member is the underlying Statement. The second is the list
+        of conditions that must be satisfied for this statement to execute.
+        The 3rd, or name, or is the variable name, as a str. The 4th is the
+        value, as a str. The 5th is the type of variable assignment/reference.
+        This will be one of the VARIABLE_ASSIGNMENT_* constants from this
+        class.
+        """
+        for statement, conditions in self.expanded_statements():
+            if not statement.is_set_variable:
+                continue
+
+            vname = statement.vname
+
+            type = None
+            token = statement.token
+            if token == '=':
+                type = StatementCollection.VARIABLE_ASSIGNMENT_RECURSIVE
+            elif token == ':=':
+                type = StatementCollection.VARIABLE_ASSIGNMENT_SIMPLE
+            elif token == '+=':
+                type = StatementCollection.VARIABLE_ASSIGNMENT_APPEND
+            elif token == '?=':
+                type = StatementCollection.VARIABLE_ASSIGNMENT_CONDITIONAL
+            else:
+                raise Exception('Unhandled variable assignment token: %' % token)
+
+            yield (statement, conditions, str(vname), statement.value, type)
+
+    def unconditional_variable_assignments(self):
+        """This is a convenience method to return variables that are assigned
+        to unconditionally. It is simply a filter over variable_assignments()
+        which filters out entries where len(entry[1]) == 0.
+
+        Each returned item is a tuple of:
+
+          ( statement, name, value, type )
+
+        The members have the same meaning as variable_assignments().
+        """
+
+        for t in self.variable_assignments():
+            if len(t) > 0:
+                pass
+
+            yield (t[0], t[2], t[3], t[4])
+
+    def target_specific_variable_assignments(self):
+        """Obtain variable assignments that are target-specific.
+
+        This is a convenience method that filters variable_assignments().
+
+        This yields the same values as variable_assignments().
+        """
+        for t in self.variable_assignments():
+            if t[0].statement.targetexp is None:
+                continue
+
+            yield t
+
+    def variable_references(self):
+        """Generator for references to variables.
+
+        Returns Expansion instances that expand to the name of the variable.
+        """
+        for statement, conditions in self.expanded_statements():
+            for v in statement.variable_references(descend=True): yield v
+
+    def all_rules(self):
+        """A generator for all rules in this instance.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions, target, prerequisites, commands, pattern )
+
+        statement is the underlying Statement instance and conditions is the
+        list of conditions that must be satisfied for this rule to be
+        evaluated.
+
+        target is the Expansion for the target of this rule. Next is
+        prerequisite, which is an Expansion of the prerequisites for this
+        rule. Finally, we have commands, which is a list of the command
+        Statement instances that will be evaluated for this rule.
+
+        If the rule is a regular rule, pattern will be None. If the rule is a
+        static pattern rule, it will be an expansions.
+        """
+
+        # Commands are associated with rules until another rule comes along.
+        # So, we keep track of the current rule and add commands to it as we
+        # encounter commands. When we see a new rule, we flush the last rule.
+        # When we're done, if we have a rule, we flush it.
+        current_rule = None
+        for statement, conditions in self.expanded_statements():
+            if statement.is_rule or statement.is_static_pattern_rule:
+                if current_rule:
+                    yield current_rule
+
+            if statement.is_rule:
+                current_rule = (statement,
+                                conditions,
+                                statement.target,
+                                statement.prerequisites,
+                                [],
+                                None)
+            elif statement.is_static_pattern_rule:
+                current_rule = (statement,
+                                conditions,
+                                statement.target,
+                                statement.prerequisites,
+                                [],
+                                statement.pattern)
+            elif statement.is_command:
+                assert(current_rule is not None)
+                current_rule[4].append(statement)
+
+        if current_rule is not None:
+            yield current_rule
+
+    def rules(self):
+        """A generator for rules in this instance.
+
+        Each returned item is a tuple of:
+
+            ( statement, conditions, target, prerequisite, commands )
+
+        Please note this only returns regular rules and not static pattern
+        rules.
+        """
+        for t in self.all_rules():
+            if t[5] is not None:
+                continue
+
+            yield (t[0], t[1], t[2], t[3], t[4])
+
+    def static_pattern_rules(self):
+        """A generator for static pattern rules.
+
+        Each returned item is a tuple of:
+          ( statement, conditions, target, pattern, prerequisites, commands )
+
+        The values have the same meaning as those in rule(). However, we have
+        added pattern, which is an Expansion of the pattern for the rule.
+        """
+        for t in self.all_rules():
+            if t[5] is None:
+                continue
+
+            yield t
+
+    # Here is where we start defining more esoteric methods dealing with static
+    # analysis and modification.
+
+    def filesystem_dependent_statements(self):
+        """A generator for statements that directly depend on the state of
+        the filesystem.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions )
+        """
+        statements = self.expanded_statements(suppress_condition_blocks=True)
+        for statement, conditions in statements:
+            for expansion in statement.expansions:
+                if expansion.is_filesystem_dependent():
+                    yield (statement, conditions)
+                    break
+
+    def shell_dependent_statements(self):
+        """A generator for statements that directly depend on the execution of
+        a shell command.
+
+        Each returned item is a tuple of:
+
+          ( statement, conditions )
+
+        This excludes rules, which are implicitly dependent on the output of
+        an external command.
+        """
+        statements = self.expanded_statements(suppress_condition_blocks=True)
+        for statement, conditions in statements:
+            for expansion in statement.expansions:
+                if expansion.is_shell_dependent():
+                    yield (statement, conditions)
+                    break
+
+    def strip_false_conditionals(self, evaluate_ifeq=False):
+        """Rewrite the raw statement list with false conditional branches
+        filtered out.
+
+        This is very dangerous and is prone to unexpected behavior if not used
+        properly.
+
+        The underlying problem is Makefiles are strongly dependent on the
+        run-time environment. There are functions that inspect the filesystem
+        or call out to shells. The results of these functions could change
+        as a Makefile is being evaluated. Even if you are simply looking at
+        variable values, a variable could be provided by an environment
+        variable or command line argument.
+
+        This function assumes that no extra variables will be provided at
+        run-time and that the state passed in is what will be there when the
+        Makefile actually runs.
+
+        The implementation of this function is still horribly naive. A more
+        appropriate solution would involve variable tainting, where any
+        detected modification in non-deterministic statements would taint
+        future references, making them also non-deterministic.
+
+        Arguments:
+        evaluate_ifeq  -- Test ifeq conditions
+        """
+
+        variables = pymake.data.Variables()
+
+        def callback(action, name, value=None):
+            if action != pymake.data.ExpansionContext.GET_ATTRIBUTE:
+                raise Exception('Non-get action not supported')
+
+            if name == 'variables':
+                return variables
+
+            # We should never get here because we should detect
+            # non-deterministic functions before we ever resolve a variable.
+            raise AttributeError('Explicitly disallowed access to attribute: %s' % name)
+
+        context = pymake.data.ExpansionContext(callback)
+
+        # List of ([evaluations], taken_branch_index)
+        # Each evaluation is True if it evaluated to true, False if
+        # it evaluated to False, or None if it could not be evaluated
+        # or was not evaluated because a previous branch was taken.
+        condition_block_stack = []
+
+        i = 0
+        while i < len(self._statements):
+            statement = self._statements[i]
+            if statement.is_condition_block:
+                branch = None
+
+                if statement.is_ifdef_only:
+                    branch = statement.determine_condition(context)
+                elif evaluate_ifeq:
+                    branch = statement.determine_condition(
+                        context, allow_nondeterministic=False)
+                # Else, we can't evaluate. Keep default branch of None.
+
+                if branch is None:
+                    i += 1
+                    continue
+
+                if branch is False:
+                    del self._statements[i]
+                    self._clear_caches()
+                    continue
+
+                # We replace the condition block with the statements that
+                # are inside the active branch.
+                active, active_statements = statement[branch]
+                self._statements[i:i + 1] = active_statements
+                self._clear_caches()
+
+                # We don't increment the index because the new statement at the
+                # current index (the first statement in the taken branch) could
+                # be condition block itself.
+                continue
+
+            elif statement.is_set_variable:
+                if statement.are_expansions_deterministic(variables):
+                    statement.statement.execute(context, None)
+                else:
+                    # TODO we need a better implementation for dealing with
+                    # non-deterministic variables.
+                    pass
+
+                i += 1
+                continue
+
+            elif statement.is_include:
+                # TODO evaluate data in included file
+                    #filename = s.expansion.resolvestr(context, variables).strip()
+
+                    # The directory to included files is the (possibly virtual)
+                    # directory of the current file plus the path from the
+                    # Makefile
+
+                    #normalized = os.path.join(self.directory, filename)
+
+                    #if os.path.exists(normalized):
+                    #    included = StatementCollection(
+                    #        filename=normalized,
+                    #        directory=self.directory)
+
+                        #temp = []
+                        #parse_statements(included.statements, temp)
+                    #elif s.statement.required:
+                    #    print 'DOES NOT EXISTS: %s' % normalized
+
+                i += 1
+                continue
+
+            else:
+                i += 1
+                continue
+
+    def _load_raw_statements(self, statements):
+        """Loads PyMake's parser output into this container."""
+
+        self._statements = []
+
+        for statement in statements:
+            if isinstance(statement, pymake.parserdata.ConditionBlock):
+                self._statements.append(ConditionBlock(statement))
+            else:
+                self._statements.append(Statement(statement))
+
+    def _clear_caches(self):
+        """Clears the instance of any cached data."""
+        pass
+
+class Makefile(object):
+    """A high-level API for a Makefile.
+
+    This provides a convenient bridge between StatementCollection,
+    pymake.data.Makefile, and raw file operations.
+
+    From an API standpoint, interaction between the 3 is a bit fuzzy. Read
+    the docs for caveats.
+    """
+    __slots__ = (
+        'filename', # Filename of the Makefile
+        'directory', # Directory holding the Makefile
+        'env', # Environment variables to pass into constructed Makefile.
+        '_makefile', # PyMake Makefile instance
+        '_statements', # StatementCollection for this file.
+        '_lines', # List of lines containing (modified) Makefile lines
+        '_resolved_variable_strings', # Cache of values of resolved variables.
+    )
+
+    RE_SUB = re.compile(r"@([a-zA-Z0-9_]+?)@")
+
+    def __init__(self, filename, directory=None):
+        """Construct a Makefile from a file"""
+        if not os.path.exists(filename):
+            raise Exception('Path does not exist: %s' % filename)
+
+        self.filename = filename
+
+        if directory is not None:
+            self.directory = directory
+        else:
+            self.directory = os.path.dirname(filename)
+
+        self.env = dict(os.environ)
+
+        # Each Makefile instance can look at two sets of data, the low-level
+        # statements or the high-level Makefile from PyMake. Each data set is
+        # lazy-loaded.
+
+        # Care must be taken when loading the PyMake Makefile instance. When
+        # this is loaded, PyMake will perform some evaluation during the
+        # constructor. If the environment isn't sane (e.g. no proper shell),
+        # PyMake will explode.
+        self._makefile = None
+        self._statements = None
+        self._lines = None
+        self._resolved_variable_strings = {}
+
+    def __getstate__(self):
+        return {
+            'lines': ['%s\n' % line for line in self.lines()],
+            'filename': self.filename,
+            'directory': self.directory,
+            'env': self.env
+        }
+
+    def __setstate__(self, state):
+        self._lines = state['lines']
+        self.filename = state['filename']
+        self.directory = state['directory']
+        self.env = state['env']
+
+        self._makefile = None
+        self._statements = None
+        self._resolved_variable_strings = {}
+
+    @property
+    def statements(self):
+        """Obtain the StatementCollection for this Makefile."""
+        if self._statements is None:
+            buf = None
+            if self._lines is not None:
+                buf = ''.join(self._lines)
+
+            self._statements = StatementCollection(filename=self.filename,
+                                                   buf=buf,
+                                                   directory=self.directory)
+
+        return self._statements
+
+    @property
+    def makefile(self):
+        if self._makefile is None:
+            self._makefile = pymake.data.Makefile(workdir=self.directory,
+                env=self.env)
+
+            if self._lines is None:
+                self._makefile.include(os.path.basename(self.filename))
+                self._makefile.finishparsing()
+            else:
+                # This hackiness is because pymake doesn't offer an easier API.
+                # We basically copy pymake.data.Makefile.include
+                statements = pymake.parser.parsestring(''.join(self._lines),
+                    self.filename)
+                self._makefile.variables.append('MAKEFILE_LIST',
+                    pymake.data.Variables.SOURCE_AUTOMATIC, self.filename,
+                    None, self._makefile)
+                statements.execute(self._makefile, weak=False)
+                self._makefile.gettarget(self.filename).explicit = True
+
+        return self._makefile
+
+    def lines(self):
+        """Returns a list of lines making up this file."""
+
+        if self._statements:
+            for line in self._statements.lines():
+                yield line
+        elif self._lines is not None:
+            for line in self._lines:
+                yield line.rstrip('\n')
+        else:
+            # TODO this could come from file, no?
+            raise('No source of lines available')
+
+    def perform_substitutions(self, mapping, raise_on_missing=False,
+                              error_on_missing=False, callback_on_missing=None):
+        """Performs variable substitutions on the Makefile.
+
+        A dictionary of variables is passed. Each "@key@" in the source
+        Makefile will be substituted for the literal value in the dictionary.
+
+        This will invalidate any cached objects. However, consumers could
+        still have a reference to an old one. So, if this method is called,
+        it should be done before any other method is consumed.
+
+        Invalidation of the cached objects also means that changes to the
+        StatementCollection will be lost.
+
+        The caller has a few choices when it comes to behavior for source
+        variables missing from the translation map. The default behavior is
+        to insert the empty string (''). If raise_on_missing is True, an
+        exception will be thrown. If error_on_missing is True, an $(error)
+        will be inserted.
+        """
+
+        lines = []
+
+        with open(self.filename, 'rbU') as fh:
+            for line in fh:
+                # Handle simple case of no substitution first
+                if line.count('@') < 2:
+                    lines.append(line)
+                    continue
+
+                # Now we perform variable replacement on the line.
+                newline = line
+                for match in self.RE_SUB.finditer(line):
+                    variable = match.group(1)
+                    value = mapping.get(variable, None)
+
+                    if value is None:
+                        if raise_on_missing:
+                            raise Exception('Missing variable from translation map: %s' % variable)
+
+                        if callback_on_missing is not None:
+                            callback_on_missing(variable)
+
+                        if error_on_missing:
+                            value = '$(error Missing source variable: %s)' % variable
+                        else:
+                            value = ''
+                    newline = newline.replace(match.group(0), value)
+
+                lines.append(newline)
+
+        self._makefile = None
+        self._statements = None
+        self._lines = lines
+        self._resolved_variable_strings = {}
+
+    def variable_defined(self, name, search_includes=False):
+        """Returns whether a variable is defined in the Makefile.
+
+        By default, it only looks for variables defined in the current
+        file, not in included files."""
+        if search_includes:
+            v = self.makefile.variables.get(name, True)[2]
+            return v is not None
+        else:
+            return name in self.statements.defined_variables
+
+    def get_variable_string(self, name, resolve=True):
+        """Obtain a named variable as a string.
+
+        If resolve is True, the variable's value will be resolved. If not,
+        the Makefile syntax of the expansion is returned. In either case,
+        if the variable is not defined, None is returned.
+        """
+        if resolve:
+            cached = self._resolved_variable_strings.get(name, None)
+            if cached is not None:
+                return cached
+
+            v = self.makefile.variables.get(name, True)[2]
+            if v is None:
+                return None
+
+            value = v.resolvestr(self.makefile, self.makefile.variables)
+
+            self._resolved_variable_strings[name] = value
+            return value
+        else:
+            if self.variable_assignments is None:
+                self._load_variable_assignments()
+
+            if name not in self.variable_assignments:
+                return None
+
+            if len(self.variable_assignments[name]) > 1:
+                raise Exception('Cannot return string representation of variable set multiple times: %s' % name)
+
+            return self.variable_assignments[name][0].value
+
+    def get_variable_split(self, name):
+        """Obtain a named variable as a list."""
+        v = self.makefile.variables.get(name, True)[2]
+        if v is None:
+            return []
+
+        return v.resolvesplit(self.makefile, self.makefile.variables)
+
+    def get_own_variable_names(self, include_conditionals=True):
+        names = set()
+
+        for stmt, conds, name, value, how in self.statements.variable_assignments():
+            if not include_conditionals and len(conds) > 0:
+                continue
+
+            names.add(name)
+
+        return names
+
+    def has_own_variable(self, name):
+        return name in self.get_own_variable_names(include_conditionals=True)
+
+class MakefileCollection(object):
+    """Holds APIs for interacting with multiple Makefiles.
+
+    This is a convenience class so all methods interacting with sets of
+    Makefiles reside in one location.
+    """
+    __slots__ = (
+        'source_directory',
+        'object_directory',
+
+        # Dictionary of paths to Makefile instances (cache)
+        '_makefiles',
+    )
+
+    def __init__(self, source_directory, object_directory):
+        assert(os.path.isabs(source_directory))
+        assert(os.path.isabs(object_directory))
+
+        self.source_directory = source_directory
+        self.object_directory = object_directory
+
+        self._makefiles = {}
+
+    def add(self, makefile):
+        """Adds a Makefile this collection."""
+        assert isinstance(makefile, Makefile)
+
+        self._makefiles[makefile.filename] = makefile
+
+    def makefiles(self):
+        """A generator for Makefile instances from the configured paths.
+
+        Returns instances of Makefile.
+        """
+        for k in sorted(self._makefiles.keys()):
+            yield self._makefiles[k]
+
+    def includes(self):
+        """Obtain information about all the includes in the Makefiles.
+
+        This is a generator of tuples. Eah tuple has the items:
+
+          ( makefile, statement, conditions, path )
+        """
+        for m in self.makefiles():
+            for statement, conditions, path in m.statements.includes():
+                yield (m, statement, conditions, path)
+
+    def variable_assignments(self):
+        """A generator of variable assignments.
+
+        Each returned item is a tuple of:
+
+          ( makefile, statement, conditions, name, value, type )
+        """
+        for m in self.makefiles():
+            for statement, conditions, name, value, type in m.statements.variable_assignments():
+                yield (makefile, statement, conditions, name, value, type)
+
+    def rules(self):
+        """A generator for rules in all the Makefiles.
+
+        Each returned item is a tuple of:
+
+          ( makefile, statement, conditions, target, prerequisite, commands )
+        """
+        for m in self.makefiles():
+            for statement, conditions, target, prerequisites, commands in m.statements.rules():
+                yield (makefile, statement, conditions, target, prerequisites, commands)
+
+    def static_pattern_rules(self):
+        """A generator for static pattern rules in all the Makefiles.
+
+        Each returned item is a tuple of:
+
+          ( makefile, statement, conditions, target, pattern, prerequisite, commands )
+        """
+        for m in self.makefiles():
+            for statement, conditions, target, pattern, prerequisites, commands in m.statements.rules():
+                yield (makefile, statement, conditions, target, pattern, prerequisites, commands)
+
+
diff --git a/python/mozbuild/mozbuild/frontendbs/mozillamakefile.py b/python/mozbuild/mozbuild/frontendbs/mozillamakefile.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/frontendbs/mozillamakefile.py
@@ -0,0 +1,617 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# This file contains code for extracting metadata from a Mozilla Makefile.
+
+import os
+
+from . import data
+from .makefile import Makefile
+
+
+class MozillaMakefile(Makefile):
+    """A Makefile with knowledge of Mozilla's build system.
+
+    This is the class used to extract metadata from the Makefiles.
+    """
+
+    """Traits that can identify a Makefile"""
+    MODULE       = 1
+    LIBRARY      = 2
+    DIRS         = 3
+    XPIDL        = 4
+    EXPORTS      = 5
+    TEST         = 6
+    PROGRAM      = 7
+
+    """Variables common in most Makefiles that aren't really that special.
+
+    This list is used to help identify variables we don't do anything with."""
+    COMMON_VARIABLES = [
+        'DEPTH',            # Defined at top of file
+        'topsrcdir',        # Defined at top of file
+        'srcdir',           # Defined at top of file
+        'VPATH',            # Defined at top of file
+        'relativesrcdir',   # Defined at top of file. # TODO is this used by anything?
+        'DIRS',             # Path traversal
+        'PARALLEL_DIRS',    # Path traversal
+        'TOOL_DIRS',        # Path traversal
+    ]
+
+    """This list tracks all variables that are still in the wild but aren't used"""
+    UNUSED_VARIABLES = []
+
+    __slots__ = (
+        # Path within tree this Makefile is present at
+        'relative_directory',
+
+        # Set of traits exhibited by this file
+        'traits',
+    )
+
+    def __init__(self, filename, relative_directory=None, directory=None):
+        """Interface for Makefiles with Mozilla build system knowledge."""
+        Makefile.__init__(self, filename, directory=directory)
+
+        self.relative_directory = relative_directory
+        self.traits = None
+
+    def __getstate__(self):
+        state = Makefile.__getstate__(self)
+        state['relative_directory'] = self.relative_directory
+
+        return state
+
+    def __setstate__(self, state):
+        Makefile.__setstate__(self, state)
+
+        self.relative_directory = state['relative_directory']
+        self.traits = None
+
+    #def perform_substitutions(self, bse, callback_on_missing=None):
+    #    """Perform substitutions on this Makefile.
+    #
+    #    This overrides the parent method to apply Mozilla-specific
+    #    functionality.
+    #    """
+    #    assert(isinstance(bse, BuildSystemExtractor))
+    #    assert(self.relative_directory is not None)
+    #
+    #    autoconf = bse.autoconf_for_path(self.relative_directory)
+    #    mapping = autoconf.copy()
+    #
+    #    mapping['configure_input'] = 'Generated automatically from Build Splendid'
+    #    mapping['top_srcdir'] = bse.config.source_directory
+    #    mapping['srcdir'] = os.path.join(bse.config.source_directory,
+    #                                     self.relative_directory)
+    #
+    #    Makefile.perform_substitutions(self, mapping,
+    #                                            callback_on_missing=callback_on_missing)
+
+    def get_traits(self):
+        """Obtain traits of the Makefile.
+
+        Traits are recognized patterns that invoke special functionality in
+        Mozilla's Makefiles. Traits are identified by the presence of specific
+        named variables."""
+        if self.traits is not None:
+            return self.traits
+
+        self.traits = set()
+        variable_names = self.get_own_variable_names(include_conditionals=True)
+        for name in variable_names:
+            if name == 'MODULE':
+                self.traits.add(self.MODULE)
+            elif name == 'LIBRARY_NAME':
+                self.traits.add(self.LIBRARY)
+            elif name == 'DIRS' or name == 'PARALLEL_DIRS':
+                self.traits.add(self.DIRS)
+            elif name in ('XPIDL_MODULE', 'XPIDLSRCS', 'SDK_XPIDLSRCS'):
+                self.traits.add(self.XPIDL)
+            elif name in ('EXPORTS', 'EXPORTS_NAMESPACES'):
+                self.traits.add(self.EXPORTS)
+            elif name in ('_TEST_FILES', 'XPCSHELL_TESTS', '_BROWSER_TEST_FILES', '_CHROME_TEST_FILES'):
+                self.traits.add(self.TEST)
+            elif name in ('PROGRAM'):
+                self.traits.add(self.PROGRAM)
+
+        return self.traits
+
+    def get_dirs(self):
+        dirs = self.get_variable_split('DIRS')
+        dirs.extend(self.get_variable_split('PARALLEL_DIRS'))
+
+        return dirs
+
+    def is_module(self):
+        return self.MODULE in self.get_traits()
+
+    def is_xpidl_module(self):
+        return self.XPIDL_MODULE in self.get_traits()
+
+    def get_module(self):
+        return self.get_variable_string('MODULE')
+
+    def get_reldir(self):
+        absdir = os.path.abspath(self.dir)
+
+        return absdir[len(self.get_objtop())+1:]
+
+    def get_objtop(self):
+        depth = self.get_variable_string('DEPTH')
+        if not depth:
+            depth = self.get_variable_string('MOD_DEPTH')
+
+        return os.path.abspath(os.path.join(self.dir, depth))
+
+    def get_top_source_dir(self):
+        return self.get_variable_string('topsrcdir')
+
+    def get_source_dir(self):
+        return self.get_variable_string('srcdir')
+
+    def get_transformed_reldir(self):
+        return self.get_reldir().replace('\\', '_').replace('/', '_')
+
+    def resolve_absolute_path(self, path, obj):
+        assert isinstance(obj, data.MakefileDerivedObject)
+
+        if os.path.isabs(path):
+            return path
+
+        search_dirs = [obj.directory, obj.source_dir]
+        search_dirs.extend(obj.vpath)
+
+        for search_dir in search_dirs:
+            try_path = os.path.join(search_dir, path)
+
+            if os.path.exists(try_path):
+                return try_path
+
+        raise Exception('Could not find source file: %s' % path)
+
+    def normalize_compiler_arguments(self, arguments, directory):
+        """Normalizes compiler arguments to sane values."""
+
+        rewritten = []
+
+        for value in arguments:
+            value = value.strip()
+
+            # Normalize includes to absolute paths. The Makefile's often deal
+            # with relative paths. If we fail to do this, we have two problems.
+            # First, we would need to cd into the Makefile's directory for
+            # compilation. We could do that. The more important problem is that
+            # when specifying relative paths, the dependency output file will
+            # use relative paths. Since the dependency files may get included
+            # from any directory, this is no good. We need absolute paths
+            # everywhere.
+            # TODO handle non-GCC like compilers.
+            if value.startswith('-I'):
+                path = value[2:]
+
+                if not os.path.isabs(path):
+                    path = os.path.join(directory, path)
+
+                normalized = os.path.normpath(path)
+
+                rewritten.append(value[0:2] + normalized)
+                continue
+
+            rewritten.append(value)
+
+        return rewritten
+
+    def get_compiler_flags(self, l, source_var, varnames):
+        var_values = {}
+        for name in varnames:
+            value = self.get_variable_split(name)
+
+            if not len(value):
+                continue
+
+            var_values[name] = value
+
+        # Here there be dragons.
+        #
+        # Makefiles have target-specific variables. These are variables that
+        # only apply when evaluated in the context of a specific target. And,
+        # our build system uses them to control compiler flags. In the ideal
+        # world, our build system wouldn't do this and would accomplish
+        # file-specific flags through some other, easier-to-parse means. But,
+        # it does, and we have to deal with it.
+        #
+        # Because evaluating the variables for each target separately is
+        # expensive (you evaluate once per target rather than just a few times
+        # per make file), we go with an alternate approach. We look at all the
+        # target-specific variable assignments (they aren't too many of them).
+        # Only if the target and variable is relevant do we pull it in. And, as
+        # a bonus, we don't need to evaluate variables in the context of
+        # targets!
+        target_flags = {}
+
+        sources = getattr(l, source_var)
+
+        targets = {}
+        obj_suffix = self.get_variable_string('OBJ_SUFFIX')
+
+        for p in sources:
+            basename = os.path.basename(p)
+            targets['%s.%s' % (os.path.splitext(basename)[0], obj_suffix)] = p
+
+        evaluate_targets = {}
+
+        for tup in self.statements.target_specific_variable_assignments():
+            target = tup[0].statement.targetexp.resolvestr(self.makefile,
+                self.makefile.variables)
+
+            if not target in targets:
+                continue
+
+            if not tup[2] in varnames:
+                continue
+
+            t = evaluate_targets.get(target, set())
+            t.add(tup[2])
+            evaluate_targets[target] = t
+
+        target_flags = {}
+
+        for target, target_vars in evaluate_targets.iteritems():
+            values = {}
+
+            make_target = self.makefile.gettarget(target)
+
+            for target_var in target_vars:
+                value = make_target.variables.get(target_var, True)[2]
+                values[target_var] = value.resolvesplit(self.makefile,
+                    make_target.variables)
+
+            target_flags[targets[target]] = values
+
+        # We need to merge the target flags with the global ones if the target
+        # does not provide that variable.
+        for path, variables in target_flags.iteritems():
+            for k, v in var_values.iteritems():
+                if k not in variables:
+                    variables[k] = v
+
+        # Finally collapse down into a single list.
+        for path in target_flags.keys():
+            arguments = []
+            for flags in target_flags[path].values():
+                arguments.extend(flags)
+            target_flags[path] = self.normalize_compiler_arguments(
+                arguments, l.directory)
+
+        arguments = []
+        for flags in var_values.values():
+            arguments.extend(self.normalize_compiler_arguments(flags,
+                l.directory))
+
+        return arguments, target_flags
+
+    def get_library_info(self):
+        """Obtain information for the library defined by this Makefile.
+
+        Returns a data.LibraryInfo instance"""
+        l = data.LibraryInfo(self)
+
+        # It is possible for the name to be not defined if the trait was
+        # in a conditional that wasn't true.
+        l.used_variables.add('LIBRARY_NAME')
+        name = self.get_variable_string('LIBRARY_NAME')
+        l.name = name
+
+        l.used_variables.add('CPPSRCS')
+        l.exclusive_variables.add('CPPSRCS')
+        for f in self.get_variable_split('CPPSRCS'):
+            l.cpp_sources.add(self.resolve_absolute_path(f, l))
+
+        l.used_variables.add('CSRCS')
+        l.exclusive_variables.add('CSRCS')
+        for f in self.get_variable_split('CSRCS'):
+            l.c_sources.add(self.resolve_absolute_path(f, l))
+
+        l.used_variables.add('CMSRCS')
+        l.exclusive_variables.add('CMSRCS')
+        for f in self.get_variable_split('CMSRCS'):
+            l.objc_sources.add(self.resolve_absolute_path(f, l))
+
+        l.used_variables.add('CMMSRCS')
+        l.exclusive_variables.add('CMMSRCS')
+        for f in self.get_variable_split('CMMSRCS'):
+            l.objcpp_sources.add(self.resolve_absolute_path(f, l))
+
+        # LIBXUL_LIBRARY implies static library generation and presence in
+        # libxul.
+        l.used_variables.add('LIBXUL_LIBRARY')
+        if self.has_own_variable('LIBXUL_LIBRARY'):
+            l.is_static = True
+
+        # FORCE_STATIC_LIB forces generation of a static library
+        l.used_variables.add('FORCE_STATIC_LIB')
+        if self.has_own_variable('FORCE_STATIC_LIB'):
+            l.is_static = True
+
+        l.used_variables.add('FORCE_SHARED_LIB')
+        if self.has_own_variable('FORCE_SHARED_LIB'):
+            l.is_shared = True
+
+        l.used_variables.add('USE_STATIC_LIBS')
+        if self.has_own_variable('USE_STATIC_LIBS'):
+            l.use_static_libs = True
+
+        # IS_COMPONENT is used for verification. It also has side effects for
+        # linking flags.
+        l.used_variables.add('IS_COMPONENT')
+        if self.has_own_variable('IS_COMPONENT'):
+            l.is_component = self.get_variable_string('IS_COMPONENT') == '1'
+
+        l.used_variables.add('EXPORT_LIBRARY')
+        if self.has_own_variable('EXPORT_LIBRARY'):
+            l.export_library = self.get_variable_string('EXPORT_LIBRARY') == '1'
+
+        # SHORT_LIBNAME doesn't appears to be used, but we preserve it anyway.
+        l.used_variables.add('SHORT_LIBNAME')
+        if self.has_own_variable('SHORT_LIBNAME'):
+            l.short_libname = self.get_variable_string('SHORT_LIBNAME')
+
+        l.used_variables.add('SHARED_LIBRARY_LIBS')
+        for lib in self.get_variable_split('SHARED_LIBRARY_LIBS'):
+            l.shared_library_libs.add(lib)
+
+        # This is the new way of obtaining the flags. It emulates
+        # COMPILE_CXXFLAGS. We could probably use pymake.data.Expansion
+        # directly...
+        flags_vars = ['STL_FLAGS', 'VISIBILITY_FLAGS', 'DEFINES', 'INCLUDES',
+            'DSO_CFLAGS', 'DSO_PIC_CFLAGS', 'CXXFLAGS', 'RTL_FLAGS',
+            'OS_CPPFLAGS']
+
+        cxx_arguments, target_flags = self.get_compiler_flags(l, 'cpp_sources',
+            flags_vars)
+        l.source_specific_flags.update(target_flags)
+
+        # Holy hack, batman.
+        extra_arguments = [
+            '-include',
+            '$(OBJECT_DIR)/mozilla-config.h',
+            '-DMOZILLA_CLIENT',
+        ]
+
+        if os.name in ('nt', 'ce'):
+            extra_arguments = [
+                '-FI',
+                '$(OBJECT_DIR)/mozilla-config.h',
+                '-DMOZILLA_CLIENT',
+            ]
+
+        cxx_arguments.extend(extra_arguments)
+
+        l.compile_cxxflags = ' '.join(cxx_arguments)
+
+        # Objective-C++ uses almost the same mechanism.
+        cmm_arguments, target_flags = self.get_compiler_flags(l,
+            'objcpp_sources', ['COMPILE_CMMFLAGS'])
+        l.source_specific_flags.update(target_flags)
+        l.objcpp_compile_flags = l.compile_cxxflags + ' ' + ' '.join(cmm_arguments)
+
+        flags_vars = ['VISIBILITY_FLAGS', 'DEFINES', 'INCLUDES', 'DSO_CFLAGS',
+            'DSO_PIC_CFLAGS', 'CFLAGS', 'RTL_FLAGS', 'OS_CFLAGS']
+
+        c_arguments, target_flags = self.get_compiler_flags(l, 'c_sources',
+            flags_vars)
+        l.source_specific_flags.update(target_flags)
+        c_arguments.extend(extra_arguments)
+
+        l.compile_cflags = ' '.join(c_arguments)
+
+        cm_arguments, target_flags = self.get_compiler_flags(l, 'objc_sources',
+            ['COMPILE_CMFLAGS'])
+        l.source_specific_flags.update(target_flags)
+        l.objc_compile_flags = l.compile_cflags + ' ' + ' '.join(cm_arguments)
+
+        # Normalize to strings.
+        for k, v in l.source_specific_flags.iteritems():
+            v.extend(extra_arguments)
+            l.source_specific_flags[k] = ' '.join(v)
+
+        # TODO the above seems like a DRY violation.
+
+        return l
+
+    def get_data_objects(self):
+        """Retrieve data objects derived from the Makefile.
+
+        This is the main function that extracts metadata from individual
+        Makefiles and turns them into Python data structures.
+
+        This method emits a set of MakefileDerivedObjects which describe the
+        Makefile. These objects each describe an individual part of the
+        build system, e.g. libraries, IDL files, tests, etc. These emitted
+        objects can be fed into another system for conversion to another
+        build system, fed into a monolithic data structure, etc.
+        """
+        misc = data.MiscInfo(self)
+        tracker = data.UsedVariableInfo(self)
+        for v in self.COMMON_VARIABLES:
+            tracker.used_variables.add(v)
+
+        for v in self.UNUSED_VARIABLES:
+            tracker.used_variables.add(v)
+
+        traits = self.get_traits()
+
+        if self.MODULE in traits:
+            tracker.used_variables.add('MODULE')
+            # TODO emit MakefileDerivedObject instance
+            #tree.register_module(self.get_module(), self.dir)
+
+        if self.LIBRARY in traits:
+            li = self.get_library_info()
+            yield li
+
+        if self.PROGRAM in traits:
+            # TODO capture programs. Executables and libraries are two sides of
+            # the same coin. How should this be captured?
+            pass
+
+        # MODULE_NAME is only used for error checking, it appears.
+        tracker.used_variables.add('MODULE_NAME')
+
+        # EXPORTS and friends holds information on what files to copy
+        # to an output directory.
+        if self.EXPORTS in traits:
+            exports = data.ExportsInfo(self)
+
+            def handle_export(namespace, filename):
+                filename = self.resolve_absolute_path(filename, exports)
+                exports.output_directories.add(namespace)
+                output_leaf = os.path.join(namespace,
+                    os.path.basename(filename))
+
+                exports.filenames.append({
+                    'source': filename,
+                    'dest': output_leaf,
+                })
+
+            exports.used_variables.add('EXPORTS')
+            exports.exclusive_variables.add('EXPORTS')
+            for export in sorted(set(self.get_variable_split('EXPORTS'))):
+                handle_export('', export)
+
+            exports.used_variables.add('EXPORTS_NAMESPACES')
+            exports.exclusive_variables.add('EXPORTS_NAMESPACES')
+            for namespace in self.get_variable_split('EXPORTS_NAMESPACES'):
+                varname = 'EXPORTS_%s' % namespace
+                exports.used_variables.add(varname)
+                exports.exclusive_variables.add(varname)
+
+                # We feed into a set because there are some duplicates.
+                # TODO fix these in the tree and treat as fatal errors.
+                for s in sorted(set(self.get_variable_split(varname))):
+                    handle_export(namespace, s)
+
+            yield exports
+
+        # XP IDL file generation
+        if self.XPIDL in traits:
+            idl = data.XPIDLInfo(self)
+            idl.used_variables.add('XPIDL_MODULE')
+            idl.used_variables.add('MODULE')
+            if self.has_own_variable('XPIDL_MODULE'):
+                idl.module = self.get_variable_string('XPIDL_MODULE')
+            elif self.has_own_variable('MODULE'):
+                idl.module = self.get_variable_string('MODULE')
+            else:
+                raise Exception('XPIDL trait without XPIDL_MODULE or MODULE defined')
+
+            idl.used_variables.add('NO_INTERFACES_MANIFEST')
+            if self.has_own_variable('NO_INTERFACES_MANIFEST'):
+                idl.write_manifest = False
+
+            def add_idl(leaf):
+                assert not os.path.isabs(leaf)
+
+                path = os.path.join(idl.source_dir, leaf)
+                assert os.path.exists(path)
+
+                idl.sources.add(path)
+
+            idl.used_variables.add('XPIDLSRCS')
+            if self.has_own_variable('XPIDLSRCS'):
+                idl.exclusive_variables.add('XPIDLSRCS')
+                for f in self.get_variable_split('XPIDLSRCS'):
+                    add_idl(f)
+
+            # rules.mk merges SDK_XPIDLSRCS together, so we treat as the same
+            if self.has_own_variable('SDK_XPIDLSRCS'):
+                idl.exclusive_variables.add('SDK_XPIDLSRCS')
+                for f in self.get_variable_split('SDK_XPIDLSRCS'):
+                    add_idl(f)
+
+            # No need to perform final link if the XPT is already generated by
+            # a source of the same name.
+            if len(idl.sources) < 2 and idl.module in idl.sources:
+                idl.link_together = False
+
+            # Some files give off the scent but don't actually define any IDLs.
+            # Here, we prevent empty output.
+            if len(idl.sources):
+                yield idl
+
+        # Test definitions
+        if self.TEST in traits:
+            ti = data.TestInfo(self)
+
+            # Regular test files
+            ti.used_variables.add('_TEST_FILES')
+            if self.has_own_variable('_TEST_FILES'):
+                for f in self.get_variable_split('_TEST_FILES'):
+                    ti.test_files.add(f)
+
+            # Identifies directories holding xpcshell test files
+            ti.used_variables.add('XPCSHELL_TESTS')
+            if self.has_own_variable('XPCSHELL_TESTS'):
+                for dir in self.get_variable_split('XPCSHELL_TESTS'):
+                    ti.xpcshell_test_dirs.add(dir)
+
+            # Files for browser tests
+            ti.used_variables.add('_BROWSER_TEST_FILES')
+            if self.has_own_variable('_BROWSER_TEST_FILES'):
+                for f in self.get_variable_split('_BROWSER_TEST_FILES'):
+                    ti.browser_test_files.add(f)
+
+            # Files for chrome tests
+            ti.used_variables.add('_CHROME_TEST_FILES')
+            if self.has_own_variable('_CHROME_TEST_FILES'):
+                for f in self.get_variable_split('_CHROME_TEST_FILES'):
+                    ti.chrome_test_files.add(f)
+
+            yield ti
+
+        misc.used_variables.add('GRE_MODULE')
+        if self.has_own_variable('GRE_MODULE'):
+            misc.is_gre_module = True
+
+        #misc.used_variables.add('PLATFORM_DIR')
+        #for d in self.get_variable_split('PLATFORM_DIR'):
+        #    misc.platform_dirs.add(d)
+
+        #misc.used_variables.add('CHROME_DEPS')
+        #for d in self.get_variable_split('CHROME_DEPS'):
+        #    misc.chrome_dependencies.add(d)
+
+        # DEFINES is used by JarMaker too. Unfortunately, we can't detect
+        # when to do JarMaker from Makefiles (bug 487182 might fix it), so
+        # we just pass it along.
+        misc.used_variables.add('DEFINES')
+        if self.has_own_variable('DEFINES'):
+            for define in self.get_variable_split('DEFINES'):
+                if define[0:2] == '-D':
+                    misc.defines.add(define[2:])
+                else:
+                    misc.defines.add(define)
+
+        # TODO add an info object for JavaScript-related
+        misc.used_variables.add('EXTRA_JS_MODULES')
+        if self.has_own_variable('EXTRA_JS_MODULES'):
+            for js in self.get_variable_split('EXTRA_JS_MODULES'):
+                misc.extra_js_module.add(js)
+
+        misc.used_variables.add('EXTRA_COMPONENTS')
+        if self.has_own_variable('EXTRA_COMPONENTS'):
+            for c in self.get_variable_split('EXTRA_COMPONENTS'):
+                misc.extra_components.add(c)
+
+        misc.used_variables.add('GARBAGE')
+        if self.has_own_variable('GARBAGE'):
+            for g in self.get_variable_split('GARBAGE'):
+                misc.garbage.add(g)
+
+        misc.included_files = [t[0] for t in self.statements.includes()]
+
+        yield tracker
+        yield misc
+
