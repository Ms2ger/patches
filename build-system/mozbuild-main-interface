# HG changeset patch
# Parent 3269501068511f667f681c91907902035a85ab6d
# User Gregory Szorc <gps@mozilla.com>
Bug 855262 - Part 1: Implement BuildSystem class

diff --git a/python/mach/mach/main.py b/python/mach/mach/main.py
--- a/python/mach/mach/main.py
+++ b/python/mach/mach/main.py
@@ -314,16 +314,17 @@
             self.log_manager.add_json_handler(args.logfile)
 
         # Up the logging level if requested.
         log_level = logging.INFO
         if args.verbose:
             log_level = logging.DEBUG
 
         self.log_manager.register_structured_logger(logging.getLogger('mach'))
+        self.log_manager.register_structured_logger(logging.getLogger('mozbuild'))
 
         # Always enable terminal logging. The log manager figures out if we are
         # actually in a TTY or are a pipe and does the right thing.
         self.log_manager.add_terminal_logging(level=log_level,
             write_interval=args.log_interval)
 
         self.load_settings(args)
 
diff --git a/python/mozbuild/README.rst b/python/mozbuild/README.rst
--- a/python/mozbuild/README.rst
+++ b/python/mozbuild/README.rst
@@ -12,16 +12,18 @@
   backends. A build backend is an entity that consumes build system metadata
   (from mozbuild.frontend) and does something useful with it (typically writing
   out files that can be used by a build tool to build the tree).
 * mozbuild.compilation -- Functionality related to compiling. This
   includes managing compiler warnings.
 * mozbuild.frontend -- Functionality for reading build frontend files
   (what defines the build system) and converting them to data structures
   which are fed into build backends to produce backend configurations.
+* mozbuild.controller -- Contains high-level interfaces for interacting with
+  the build system.
 * mozpack -- Functionality related to packaging builds.
 
 Overview
 ========
 
 The build system consists of frontend files that define what to do. They
 say things like "compile X" "copy Y."
 
diff --git a/python/mozbuild/mozbuild/__init__.py b/python/mozbuild/mozbuild/__init__.py
--- a/python/mozbuild/mozbuild/__init__.py
+++ b/python/mozbuild/mozbuild/__init__.py
@@ -0,0 +1,6 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+from .controller.main import BuildSystem
+
diff --git a/python/mozbuild/mozbuild/base.py b/python/mozbuild/mozbuild/base.py
--- a/python/mozbuild/mozbuild/base.py
+++ b/python/mozbuild/mozbuild/base.py
@@ -7,17 +7,16 @@
 import logging
 import mozpack.path
 import multiprocessing
 import os
 import subprocess
 import sys
 import which
 
-from mach.mixin.logging import LoggingMixin
 from mach.mixin.process import ProcessExecutionMixin
 
 from mozfile.mozfile import rmtree
 
 from .backend.configenvironment import ConfigEnvironment
 from .config import BuildConfig
 from .mozconfig import (
     MozconfigFindException,
@@ -193,16 +192,18 @@
         if subdir:
             path = os.path.join(path, subdir)
 
         return os.path.join(path, filename)
 
     def _wrap_path_argument(self, arg):
         return PathArgument(arg, self.topsrcdir, self.topobjdir)
 
+    # This is deprecated in favor of BaseController's version (which was copied
+    # from this one).
     def _run_make(self, directory=None, filename=None, target=None, log=True,
             srcdir=False, allow_parallel=True, line_handler=None,
             append_env=None, explicit_env=None, ignore_errors=False,
             ensure_exit_code=0, silent=True, print_directory=True,
             pass_thru=False, num_jobs=0):
         """Invoke make.
 
         directory -- Relative directory to look for Makefile in.
diff --git a/python/mozbuild/mozbuild/controller/base.py b/python/mozbuild/mozbuild/controller/base.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/controller/base.py
@@ -0,0 +1,143 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+from __future__ import unicode_literals
+
+import errno
+import logging
+import os
+
+import which
+
+from mach.mixin.process import ProcessExecutionMixin
+
+
+class BaseController(ProcessExecutionMixin):
+    """Base class for controllers."""
+
+    def __init__(self, build_system):
+        self._bs = build_system
+        self.populate_logger()
+
+        self._make = None
+
+    def _init(self):
+        """Hook point for child classes to implement __init__ logic."""
+
+    def _mkdir(self, path):
+        """Ensure a directory and any parent directories exist."""
+        try:
+            os.makedirs(path)
+        except OSError as e:
+            if e.errno != errno.EEXIST:
+                raise
+
+    def _log_human(self, msg):
+        """Log a message intended for humans only.
+
+        The message is plain text and will be printed as-is if and only if the
+        logging output is destined for humans, not machines.
+        """
+        return self.log(logging.INFO, 'human', {'msg': msg}, '{msg}')
+
+    def _run_make(self, directory=None, filename=None, target=None, log=True,
+            srcdir=False, allow_parallel=True, line_handler=None,
+            append_env=None, explicit_env=None, ignore_errors=False,
+            ensure_exit_code=0, silent=True, print_directory=True,
+            pass_thru=False, num_jobs=0):
+        """Invoke make.
+
+        directory -- Relative directory to look for Makefile in.
+        filename -- Explicit makefile to run.
+        target -- Makefile target(s) to make. Can be a string or iterable of
+            strings.
+        srcdir -- If True, invoke make from the source directory tree.
+            Otherwise, make will be invoked from the object directory.
+        silent -- If True (the default), run make in silent mode.
+        print_directory -- If True (the default), have make print directories
+        while doing traversal.
+        """
+        args = [self._make_path]
+
+        if directory:
+            args.extend(['-C', directory])
+
+        if filename:
+            args.extend(['-f', filename])
+
+        if allow_parallel:
+            if num_jobs > 0:
+                args.append('-j%d' % num_jobs)
+            else:
+                args.append('-j%d' % multiprocessing.cpu_count())
+
+        if ignore_errors:
+            args.append('-k')
+
+        if silent:
+            args.append('-s')
+
+        # Print entering/leaving directory messages. Some consumers look at
+        # these to measure progress. Ideally, we'd do everything with pymake
+        # and use hooks in its API. Unfortunately, it doesn't provide that
+        # feature... yet.
+        if print_directory:
+            args.append('-w')
+
+        if isinstance(target, list):
+            args.extend(target)
+        elif target:
+            args.append(target)
+
+        params = {
+            'args': args,
+            'line_handler': line_handler,
+            'append_env': append_env,
+            'explicit_env': explicit_env,
+            'log_level': logging.INFO,
+            'require_unix_environment': True,
+            'ensure_exit_code': ensure_exit_code,
+            'pass_thru': pass_thru,
+
+            # Make manages its children, so mozprocess doesn't need to bother.
+            # Having mozprocess manage children can also have side-effects when
+            # building on Windows. See bug 796840.
+            'ignore_children': True,
+        }
+
+        params['cwd'] = self.topsrcdir if srcdir else self.topobjdir
+
+        if log:
+            params['log_name'] = 'make'
+
+        return self.run_process(**params)
+
+    @property
+    def _make_path(self):
+        if self._make is None:
+            if os.name == 'nt':
+                self._make = os.path.join(self.topsrcdir, 'build', 'pymake',
+                    'make.py')
+
+            else:
+                for test in ['gmake', 'make']:
+                    try:
+                        self._make = which.which(test)
+                        break
+                    except which.WhichError:
+                        continue
+
+        if self._make is None:
+            raise Exception('Could not find suitable make binary!')
+
+        return self._make
+
+    @property
+    def topsrcdir(self):
+        return self._bs.topsrcdir
+
+    @property
+    def topobjdir(self):
+        return self._bs.topobjdir
+
diff --git a/python/mozbuild/mozbuild/mach_commands.py b/python/mozbuild/mozbuild/controller/build.py
copy from python/mozbuild/mozbuild/mach_commands.py
copy to python/mozbuild/mozbuild/controller/build.py
--- a/python/mozbuild/mozbuild/mach_commands.py
+++ b/python/mozbuild/mozbuild/controller/build.py
@@ -1,72 +1,63 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, # You can obtain one at http://mozilla.org/MPL/2.0/.
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-from __future__ import print_function, unicode_literals
+from __future__ import unicode_literals
 
 import getpass
 import logging
-import operator
+import multiprocessing
 import os
 import sys
 import time
 
-from mach.decorators import (
-    CommandArgument,
-    CommandProvider,
-    Command,
+try:
+    import psutil
+except ImportError:
+    psutil = None
+
+from dumbmake.dumbmake import (
+    dependency_map,
+    add_extra_dependencies,
 )
 
-from mozbuild.base import MachCommandBase
+from .base import BaseController
 
+from ..compilation.warnings import (
+    WarningsCollector,
+    WarningsDatabase,
+)
 
-BUILD_WHAT_HELP = '''
-What to build. Can be a top-level make target or a relative directory. If
-multiple options are provided, they will be built serially. Takes dependency
-information from `topsrcdir/build/dumbmake-dependencies` to build additional
-targets as needed. BUILDING ONLY PARTS OF THE TREE CAN RESULT IN BAD TREE
-STATE. USE AT YOUR OWN RISK.
-'''.strip()
+from ..util import resolve_target_to_make
 
 FINDER_SLOW_MESSAGE = '''
 ===================
 PERFORMANCE WARNING
 
 The OS X Finder application (file indexing used by Spotlight) used a lot of CPU
 during the build - an average of %f%% (100%% is 1 core). This made your build
 slower.
 
 Consider adding ".noindex" to the end of your object directory name to have
 Finder ignore it. Or, add an indexing exclusion through the Spotlight System
 Preferences.
 ===================
 '''.strip()
 
 
-@CommandProvider
-class Build(MachCommandBase):
-    """Interface to build the tree."""
+class BuildController(BaseController):
+    """Contains the logic for invoking the build system.
 
-    @Command('build', category='build', description='Build the tree.')
-    @CommandArgument('--jobs', '-j', default='0', metavar='jobs', type=int,
-        help='Number of concurrent jobs to run. Default is the number of CPUs.')
-    @CommandArgument('what', default=None, nargs='*', help=BUILD_WHAT_HELP)
-    @CommandArgument('-X', '--disable-extra-make-dependencies',
-                     default=False, action='store_true',
-                     help='Do not add extra make dependencies.')
-    def build(self, what=None, disable_extra_make_dependencies=None, jobs=0):
-        # This code is only meant to be temporary until the more robust tree
-        # building code in bug 780329 lands.
-        from mozbuild.compilation.warnings import WarningsCollector
-        from mozbuild.compilation.warnings import WarningsDatabase
-        from mozbuild.util import resolve_target_to_make
-
-        warnings_path = self._get_state_filename('warnings.json')
+    If you are looking for how the build system is executed, you've come to the
+    right place.
+    """
+    def build(self, what, disable_extra_make_dependencies=False, jobs=0):
+        warnings_path = os.path.join(self.topobjdir, 'warnings.json')
         warnings_database = WarningsDatabase()
 
         if os.path.exists(warnings_path):
             try:
                 warnings_database.load_from_file(warnings_path)
             except ValueError:
                 os.remove(warnings_path)
 
@@ -86,18 +77,18 @@
             self.log(logging.INFO, 'build_output', {'line': line}, '{line}')
 
         finder_start_cpu = self._get_finder_cpu_usage()
         time_start = time.time()
 
         if what:
             top_make = os.path.join(self.topobjdir, 'Makefile')
             if not os.path.exists(top_make):
-                print('Your tree has not been configured yet. Please run '
-                    '|mach build| with no arguments.')
+                self._log_human('Your tree has not been configured yet. '
+                    'Please run |mach build| with no arguments.')
                 return 1
 
             # Collect target pairs.
             target_pairs = []
             for target in what:
                 path_arg = self._wrap_path_argument(target)
 
                 make_dir, make_target = resolve_target_to_make(self.topobjdir,
@@ -105,18 +96,16 @@
 
                 if make_dir is None and make_target is None:
                     return 1
 
                 target_pairs.append((make_dir, make_target))
 
             # Possibly add extra make depencies using dumbmake.
             if not disable_extra_make_dependencies:
-                from dumbmake.dumbmake import (dependency_map,
-                                               add_extra_dependencies)
                 depfile = os.path.join(self.topsrcdir, 'build',
                                        'dumbmake-dependencies')
                 with open(depfile) as f:
                     dm = dependency_map(f.readlines())
                 new_pairs = list(add_extra_dependencies(target_pairs, dm))
                 self.log(logging.DEBUG, 'dumbmake',
                          {'target_pairs': target_pairs,
                           'new_pairs': new_pairs},
@@ -149,46 +138,46 @@
         self._handle_finder_cpu_usage(time_elapsed, finder_start_cpu)
 
         long_build = time_elapsed > 600
 
         if status:
             return status
 
         if long_build:
-            print('We know it took a while, but your build finally finished successfully!')
+            self._log_human('We know it took a while, but your build finally '
+                'finished successfully!')
         else:
-            print('Your build was successful!')
+            self._log_human('Your build was successful!')
 
         # Only for full builds because incremental builders likely don't
         # need to be burdened with this.
         if not what:
             # Fennec doesn't have useful output from just building. We should
             # arguably make the build action useful for Fennec. Another day...
             if self.substs['MOZ_BUILD_APP'] != 'mobile/android':
                 app_path = self.get_binary_path('app')
-                print('To take your build for a test drive, run: %s' % app_path)
+                self._log_human('To take your build for a test drive, run: %s'
+                        % app_path)
             app = self.substs['MOZ_BUILD_APP']
             if app in ('browser', 'mobile/android'):
-                print('For more information on what to do now, see '
+                self._log_human('For more information on what to do now, see '
                     'https://developer.mozilla.org/docs/Developer_Guide/So_You_Just_Built_Firefox')
 
         return status
 
     def _get_finder_cpu_usage(self):
         """Obtain the CPU usage of the Finder app on OS X.
 
         This is used to detect high CPU usage.
         """
         if not sys.platform.startswith('darwin'):
             return None
 
-        try:
-            import psutil
-        except ImportError:
+        if not psutil:
             return None
 
         for proc in psutil.process_iter():
             if proc.name != 'Finder':
                 continue
 
             if proc.username != getpass.getuser():
                 continue
@@ -220,351 +209,10 @@
         cpu_seconds = end_total - start_total
 
         # If Finder used more than 25% of 1 core during the build, report an
         # error.
         finder_percent = cpu_seconds / elapsed * 100
         if finder_percent < 25:
             return
 
-        print(FINDER_SLOW_MESSAGE % finder_percent)
+        self._log_human(FINDER_SLOW_MESSAGE % finder_percent)
 
-
-    @Command('configure', category='build',
-        description='Configure the tree (run configure and config.status')
-    def configure(self):
-        def on_line(line):
-            self.log(logging.INFO, 'build_output', {'line': line}, '{line}')
-
-        status = self._run_make(srcdir=True, filename='client.mk',
-            target='configure', line_handler=on_line, log=False,
-            print_directory=False, allow_parallel=False, ensure_exit_code=False)
-
-        if not status:
-            print('Configure complete!')
-            print('Be sure to run |mach build| to pick up any changes');
-
-        return status
-
-
-    @Command('clobber', category='build',
-        description='Clobber the tree (delete the object directory).')
-    def clobber(self):
-        try:
-            self.remove_objdir()
-            return 0
-        except WindowsError as e:
-            if e.winerror in (5, 32):
-                self.log(logging.ERROR, 'file_access_error', {'error': e},
-                    "Could not clobber because a file was in use. If the "
-                    "application is running, try closing it. {error}")
-                return 1
-            else:
-                raise
-
-
-@CommandProvider
-class Warnings(MachCommandBase):
-    """Provide commands for inspecting warnings."""
-
-    @property
-    def database_path(self):
-        return self._get_state_filename('warnings.json')
-
-    @property
-    def database(self):
-        from mozbuild.compilation.warnings import WarningsDatabase
-
-        path = self.database_path
-
-        database = WarningsDatabase()
-
-        if os.path.exists(path):
-            database.load_from_file(path)
-
-        return database
-
-    @Command('warnings-summary', category='post-build',
-        description='Show a summary of compiler warnings.')
-    @CommandArgument('report', default=None, nargs='?',
-        help='Warnings report to display. If not defined, show the most '
-            'recent report.')
-    def summary(self, report=None):
-        database = self.database
-
-        type_counts = database.type_counts
-        sorted_counts = sorted(type_counts.iteritems(),
-            key=operator.itemgetter(1))
-
-        total = 0
-        for k, v in sorted_counts:
-            print('%d\t%s' % (v, k))
-            total += v
-
-        print('%d\tTotal' % total)
-
-    @Command('warnings-list', category='post-build',
-        description='Show a list of compiler warnings.')
-    @CommandArgument('report', default=None, nargs='?',
-        help='Warnings report to display. If not defined, show the most '
-            'recent report.')
-    def list(self, report=None):
-        database = self.database
-
-        by_name = sorted(database.warnings)
-
-        for warning in by_name:
-            filename = warning['filename']
-
-            if filename.startswith(self.topsrcdir):
-                filename = filename[len(self.topsrcdir) + 1:]
-
-            if warning['column'] is not None:
-                print('%s:%d:%d [%s] %s' % (filename, warning['line'],
-                    warning['column'], warning['flag'], warning['message']))
-            else:
-                print('%s:%d [%s] %s' % (filename, warning['line'],
-                    warning['flag'], warning['message']))
-
-@CommandProvider
-class GTestCommands(MachCommandBase):
-    @Command('gtest', category='testing',
-        description='Run GTest unit tests.')
-    @CommandArgument('gtest_filter', default=b"*", nargs='?', metavar='gtest_filter',
-        help="test_filter is a ':'-separated list of wildcard patterns (called the positive patterns),"
-             "optionally followed by a '-' and another ':'-separated pattern list (called the negative patterns).")
-    @CommandArgument('--jobs', '-j', default='1', nargs='?', metavar='jobs', type=int,
-        help='Run the tests in parallel using multiple processes.')
-    @CommandArgument('--tbpl-parser', '-t', action='store_true',
-        help='Output test results in a format that can be parsed by TBPL.')
-    @CommandArgument('--shuffle', '-s', action='store_true',
-        help='Randomize the execution order of tests.')
-    def gtest(self, shuffle, jobs, gtest_filter, tbpl_parser):
-        app_path = self.get_binary_path('app')
-
-        # Use GTest environment variable to control test execution
-        # For details see:
-        # https://code.google.com/p/googletest/wiki/AdvancedGuide#Running_Test_Programs:_Advanced_Options
-        gtest_env = {b'GTEST_FILTER': gtest_filter}
-
-        if shuffle:
-            gtest_env[b"GTEST_SHUFFLE"] = b"True"
-
-        if tbpl_parser:
-            gtest_env[b"MOZ_TBPL_PARSER"] = b"True"
-
-        if jobs == 1:
-            return self.run_process([app_path, "-unittest"],
-                                    append_env=gtest_env,
-                                    ensure_exit_code=False,
-                                    pass_thru=True)
-
-        from mozprocess import ProcessHandlerMixin
-        import functools
-        def handle_line(job_id, line):
-            # Prepend the jobId
-            line = '[%d] %s' % (job_id + 1, line.strip())
-            self.log(logging.INFO, "GTest", {'line': line}, '{line}')
-
-        gtest_env["GTEST_TOTAL_SHARDS"] = str(jobs)
-        processes = {}
-        for i in range(0, jobs):
-            gtest_env["GTEST_SHARD_INDEX"] = str(i)
-            processes[i] = ProcessHandlerMixin([app_path, "-unittest"],
-                             env=gtest_env,
-                             processOutputLine=[functools.partial(handle_line, i)],
-                             universal_newlines=True)
-            processes[i].run()
-
-        exit_code = 0
-        for process in processes.values():
-            status = process.wait()
-            if status:
-                exit_code = status
-
-        # Clamp error code to 255 to prevent overflowing multiple of
-        # 256 into 0
-        if exit_code > 255:
-            exit_code = 255
-
-        return exit_code
-
-@CommandProvider
-class ClangCommands(MachCommandBase):
-    @Command('clang-complete', category='devenv',
-        description='Generate a .clang_complete file.')
-    def clang_complete(self):
-        import shlex
-
-        build_vars = {}
-
-        def on_line(line):
-            elements = [s.strip() for s in line.split('=', 1)]
-
-            if len(elements) != 2:
-                return
-
-            build_vars[elements[0]] = elements[1]
-
-        try:
-            old_logger = self.log_manager.replace_terminal_handler(None)
-            self._run_make(target='showbuild', log=False, line_handler=on_line)
-        finally:
-            self.log_manager.replace_terminal_handler(old_logger)
-
-        def print_from_variable(name):
-            if name not in build_vars:
-                return
-
-            value = build_vars[name]
-
-            value = value.replace('-I.', '-I%s' % self.topobjdir)
-            value = value.replace(' .', ' %s' % self.topobjdir)
-            value = value.replace('-I..', '-I%s/..' % self.topobjdir)
-            value = value.replace(' ..', ' %s/..' % self.topobjdir)
-
-            args = shlex.split(value)
-            for i in range(0, len(args) - 1):
-                arg = args[i]
-
-                if arg.startswith(('-I', '-D')):
-                    print(arg)
-                    continue
-
-                if arg.startswith('-include'):
-                    print(arg + ' ' + args[i + 1])
-                    continue
-
-        print_from_variable('COMPILE_CXXFLAGS')
-
-        print('-I%s/ipc/chromium/src' % self.topsrcdir)
-        print('-I%s/ipc/glue' % self.topsrcdir)
-        print('-I%s/ipc/ipdl/_ipdlheaders' % self.topobjdir)
-
-
-@CommandProvider
-class Package(MachCommandBase):
-    """Package the built product for distribution."""
-
-    @Command('package', category='post-build',
-        description='Package the built product for distribution as an APK, DMG, etc.')
-    def package(self):
-        return self._run_make(directory=".", target='package', ensure_exit_code=False)
-
-@CommandProvider
-class Install(MachCommandBase):
-    """Install a package."""
-
-    @Command('install', category='post-build',
-        description='Install the package on the machine, or on a device.')
-    def install(self):
-        return self._run_make(directory=".", target='install', ensure_exit_code=False)
-
-@CommandProvider
-class RunProgram(MachCommandBase):
-    """Launch the compiled binary"""
-
-    @Command('run', category='post-build', allow_all_args=True,
-        description='Run the compiled program.')
-    @CommandArgument('params', default=None, nargs='...',
-        help='Command-line arguments to pass to the program.')
-    def run(self, params):
-        try:
-            args = [self.get_binary_path('app'), '-no-remote']
-        except Exception as e:
-            print("It looks like your program isn't built.",
-                "You can run |mach build| to build it.")
-            print(e)
-            return 1
-        if params:
-            args.extend(params)
-        return self.run_process(args=args, ensure_exit_code=False,
-            pass_thru=True)
-
-@CommandProvider
-class DebugProgram(MachCommandBase):
-    """Debug the compiled binary"""
-
-    @Command('debug', category='post-build', allow_all_args=True,
-        description='Debug the compiled program.')
-    @CommandArgument('params', default=None, nargs='...',
-        help='Command-line arguments to pass to the program.')
-    def debug(self, params):
-        import which
-        try:
-            debugger = which.which('gdb')
-        except Exception as e:
-            print("You don't have gdb in your PATH")
-            print(e)
-            return 1
-        try:
-            args = [debugger, '--args', self.get_binary_path('app'), '-no-remote']
-        except Exception as e:
-            print("It looks like your program isn't built.",
-                "You can run |mach build| to build it.")
-            print(e)
-            return 1
-        if params:
-            args.extend(params)
-        return self.run_process(args=args, ensure_exit_code=False,
-            pass_thru=True)
-
-@CommandProvider
-class Buildsymbols(MachCommandBase):
-    """Produce a package of debug symbols suitable for use with Breakpad."""
-
-    @Command('buildsymbols', category='post-build',
-        description='Produce a package of Breakpad-format symbols.')
-    def buildsymbols(self):
-        return self._run_make(directory=".", target='buildsymbols', ensure_exit_code=False)
-
-@CommandProvider
-class Makefiles(MachCommandBase):
-    @Command('empty-makefiles', category='build-dev',
-        description='Find empty Makefile.in in the tree.')
-    def empty(self):
-        import pymake.parser
-        import pymake.parserdata
-
-        IGNORE_VARIABLES = {
-            'DEPTH': ('@DEPTH@',),
-            'topsrcdir': ('@top_srcdir@',),
-            'srcdir': ('@srcdir@',),
-            'relativesrcdir': ('@relativesrcdir@',),
-            'VPATH': ('@srcdir@',),
-        }
-
-        IGNORE_INCLUDES = [
-            'include $(DEPTH)/config/autoconf.mk',
-            'include $(topsrcdir)/config/config.mk',
-            'include $(topsrcdir)/config/rules.mk',
-        ]
-
-        def is_statement_relevant(s):
-            if isinstance(s, pymake.parserdata.SetVariable):
-                exp = s.vnameexp
-                if not exp.is_static_string:
-                    return True
-
-                if exp.s not in IGNORE_VARIABLES:
-                    return True
-
-                return s.value not in IGNORE_VARIABLES[exp.s]
-
-            if isinstance(s, pymake.parserdata.Include):
-                if s.to_source() in IGNORE_INCLUDES:
-                    return False
-
-            return True
-
-        for path in self._makefile_ins():
-            statements = [s for s in pymake.parser.parsefile(path)
-                if is_statement_relevant(s)]
-
-            if not statements:
-                print(os.path.relpath(path, self.topsrcdir))
-
-    def _makefile_ins(self):
-        for root, dirs, files in os.walk(self.topsrcdir):
-            for f in files:
-                if f == 'Makefile.in':
-                    yield os.path.join(root, f)
-
diff --git a/python/mozbuild/mozbuild/controller/configure.py b/python/mozbuild/mozbuild/controller/configure.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/controller/configure.py
@@ -0,0 +1,59 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+from __future__ import unicode_literals
+
+from which import (
+    which,
+    WhichError
+)
+
+from mach.mixin.process import ProcessExecutionMixin
+
+
+class ConfigureError(Exception):
+    """Represents an error that occurs as part of configure."""
+
+
+class Configure(BaseController):
+    """Controller for interacting with autoconf and configure."""
+
+    def _init(self):
+        self._autoconf_path = None
+
+    @property
+    def autoconf_path(self):
+        if self._autoconf_path:
+            return self._autoconf_path
+
+        error = ConfigureError('Could not find autoconf 2.13')
+
+        if self._autoconf_path is False:
+            raise error
+
+        for name in ['autoconf-2.13', 'autoconf2.13', 'autoconf213']:
+            try:
+                self._autoconf_path = which(name)
+                return self._autoconf_path
+            except WhichError:
+                continue
+
+        # Fink may install autoconf in its own place not on the path.
+        try:
+            fink = which('fink')
+            path = os.path.normpath(os.path.join(os.path.dirname(fink), '..',
+                '..', 'lib', 'autoconf2.13', 'bin', 'autoconf'))
+
+            if os.path.exists(path):
+                self._autoconf_path = path
+                return self._autoconf_path
+
+        except WhichError:
+            pass
+
+        self._autoconf_path = False
+        raise error
+
+    def configure_paths(self):
+        pass
diff --git a/python/mozbuild/mozbuild/controller/main.py b/python/mozbuild/mozbuild/controller/main.py
new file mode 100644
--- /dev/null
+++ b/python/mozbuild/mozbuild/controller/main.py
@@ -0,0 +1,181 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+from __future__ import unicode_literals
+
+import errno
+import os
+import subprocess
+
+from mach.mixin.process import ProcessExecutionMixin
+
+from .build import BuildController
+
+from ..mozconfig import MozconfigLoader
+
+
+def ancestors(path):
+    """Emit the parent directories of a path."""
+    while path:
+        yield path
+        path, child = os.path.split(path)
+        if child == '':
+            break
+
+
+class BadEnvironmentException(Exception):
+    """Base class for errors raised when the build environment is not sane."""
+
+
+class BuildEnvironmentNotFoundException(BadEnvironmentException):
+    """Raised when we could not find a build environment."""
+
+
+class ObjdirMismatchException(BadEnvironmentException):
+    """Raised when the current dir is an objdir and doesn't match the mozconfig."""
+
+
+class BuildSystem(ProcessExecutionMixin):
+    """Main interface to the Mozilla build system.
+
+    This class provides a high-level interface to Mozilla's build system. If
+    you want to do anything with the build system, you should instantiate one
+    of these.
+
+    Instances are typically instantiated from one of the from_* static methods.
+    """
+
+    def __init__(self, topsrcdir, topobjdir, config):
+        """Create an interface from topsrcdir, topobjdir, and a configuration.
+
+        topsrcdir must be defined as an absolute and normalized path.
+
+        topobjdir must be an absolute and normalized path if it is defined. If
+        it is None, topobjdir will be calculated by running config.status.
+
+        config is currently a dict generated by loading mozconfig files. In the
+        future, we may create a dedicated type to represent the build system
+        config. This will allow the config to come from multiple sources, etc.
+        """
+        assert topsrcdir
+        assert os.path.isabs(topsrcdir)
+        assert os.path.normpath(topsrcdir) == topsrcdir
+
+        if topobjdir:
+            assert os.path.isabs(topobjdir)
+            assert os.path.normpath(topobjdir) == topobjdir
+        else:
+            topobjdir = 'obj-@CONFIG_GUESS@'
+
+        assert isinstance(config, dict)
+
+        p = os.path.join(topsrcdir, 'build', 'autoconf', 'config.guess')
+        args = self._normalize_command([p], True)
+        config_guess = subprocess.check_output(args, cwd=topsrcdir).strip()
+
+        topobjdir = topobjdir.replace('@CONFIG_GUESS@', config_guess)
+
+        self.topsrcdir = topsrcdir
+        self.topobjdir = topobjdir
+        self.mozconfig_path = config['path']
+        self.configure_args = config['configure_args']
+        self.make_flags = config['make_flags']
+        self.make_extra = config['make_extra']
+
+    @staticmethod
+    def from_topsrcdir(topsrcdir):
+        """Create a BuildSystem from only a topsrcdir path.
+
+        We will attempt to find a mozconfig from the environment.
+        """
+        loader = MozconfigLoader(topsrcdir)
+        config = loader.read_mozconfig(None)
+
+        return BuildSystem(topsrcdir, config['topobjdir'], config)
+
+    @staticmethod
+    def from_environment():
+        """Create a BuildSystem by detecting the proper one from the env.
+
+        This examines environment state like the current working directory and
+        creates a BuildSystem from the found source directory, mozconfig, etc.
+
+        The role of this function is to identify a topsrcdir, topobjdir, and
+        mozconfig file.
+
+        If the current working directory is inside a known objdir, we always
+        use the topsrcdir and mozconfig associated with that objdir. If no
+        mozconfig is associated with that objdir, we fall back to looking for
+        the mozconfig in the usual places.
+
+        If the current working directory is inside a known srcdir, we use that
+        topsrcdir and look for mozconfigs using the default mechanism, which
+        looks inside environment variables.
+
+        If we're not inside a srcdir or objdir, an exception is raised.
+        """
+
+        topsrcdir = None
+        topobjdir = None
+        mozconfig = None
+
+        for dir_path in ancestors(os.getcwd()):
+            # If we find a mozinfo.json, we are in the objdir.
+            mozinfo_path = os.path.join(dir_path, 'mozinfo.json')
+            if os.path.isfile(mozinfo_path):
+                info = json.load(open(mozinfo_path, 'rt'))
+
+                topsrcdir = info.get('topsrcdir')
+                topobjdir = dir_path
+                mozconfig = info.get('mozconfig')
+                break
+
+            # We choose an arbitrary file as an indicator that this is a
+            # srcdir. We go with ourself because why not!
+            our_path = os.path.join(dir_path, 'python', 'mozbuild', 'mozbuild',
+                'controller', 'main.py')
+            if os.path.isfile(our_path):
+                topsrcdir = dir_path
+                break
+
+        # If we were successful, we're only guaranteed to find a topsrcdir. If
+        # we couldn't find that, there's nothing we can do.
+        if not topsrcdir:
+            raise BuildEnvironmentNotFoundException(
+                'Could not find Mozilla source tree or build environment.')
+
+        # Now we try to load the config for this environment. If mozconfig is
+        # None, read_mozconfig() will attempt to find one in the existing
+        # environment. If no mozconfig is present, the config will not have
+        # much defined.
+        loader = MozconfigLoader(topsrcdir)
+        config = loader.read_mozconfig(mozconfig)
+
+        # If we're inside a objdir and the found mozconfig resolves to
+        # another objdir, we abort. The reasoning here is that if you are
+        # inside an objdir you probably want to perform actions on that objdir,
+        # not another one.
+        if topobjdir and config['topobjdir'] \
+            and topobjdir != config['topobjdir']:
+
+            raise ObjdirMismatchException()
+
+        topobjdir = config['topobjdir'] or topobjdir
+
+        # If we can't resolve topobjdir, oh well. The constructor will figure
+        # it out via config.guess.
+        return BuildSystem(topsrcdir, topobjdir, config)
+
+    def build(self, what, disable_extra_make_dependencies=False, jobs=0):
+        c = BuildController(self)
+        return c.build(what,
+            disable_extra_make_dependencies=disable_extra_make_dependencies,
+            jobs=jobs)
+
+    def _ensure_dir_exists(self, path):
+        try:
+            os.makedirs(path)
+        except OSError as e:
+            if e.errno != errno.EEXIST:
+                raise
diff --git a/python/mozbuild/mozbuild/mach_commands.py b/python/mozbuild/mozbuild/mach_commands.py
--- a/python/mozbuild/mozbuild/mach_commands.py
+++ b/python/mozbuild/mozbuild/mach_commands.py
@@ -1,15 +1,14 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, # You can obtain one at http://mozilla.org/MPL/2.0/.
 
 from __future__ import print_function, unicode_literals
 
-import getpass
 import logging
 import operator
 import os
 import sys
 import time
 
 from mach.decorators import (
     CommandArgument,
@@ -23,215 +22,36 @@
 BUILD_WHAT_HELP = '''
 What to build. Can be a top-level make target or a relative directory. If
 multiple options are provided, they will be built serially. Takes dependency
 information from `topsrcdir/build/dumbmake-dependencies` to build additional
 targets as needed. BUILDING ONLY PARTS OF THE TREE CAN RESULT IN BAD TREE
 STATE. USE AT YOUR OWN RISK.
 '''.strip()
 
-FINDER_SLOW_MESSAGE = '''
-===================
-PERFORMANCE WARNING
-
-The OS X Finder application (file indexing used by Spotlight) used a lot of CPU
-during the build - an average of %f%% (100%% is 1 core). This made your build
-slower.
-
-Consider adding ".noindex" to the end of your object directory name to have
-Finder ignore it. Or, add an indexing exclusion through the Spotlight System
-Preferences.
-===================
-'''.strip()
-
 
 @CommandProvider
 class Build(MachCommandBase):
     """Interface to build the tree."""
 
+    def _get_build_system(self):
+        from mozbuild import BuildSystem
+
+        return BuildSystem.from_environment()
+
     @Command('build', category='build', description='Build the tree.')
-    @CommandArgument('--jobs', '-j', default='0', metavar='jobs', type=int,
+    @CommandArgument('--jobs', '-j', default=0, metavar='jobs', type=int,
         help='Number of concurrent jobs to run. Default is the number of CPUs.')
     @CommandArgument('what', default=None, nargs='*', help=BUILD_WHAT_HELP)
     @CommandArgument('-X', '--disable-extra-make-dependencies',
                      default=False, action='store_true',
                      help='Do not add extra make dependencies.')
-    def build(self, what=None, disable_extra_make_dependencies=None, jobs=0):
-        # This code is only meant to be temporary until the more robust tree
-        # building code in bug 780329 lands.
-        from mozbuild.compilation.warnings import WarningsCollector
-        from mozbuild.compilation.warnings import WarningsDatabase
-        from mozbuild.util import resolve_target_to_make
-
-        warnings_path = self._get_state_filename('warnings.json')
-        warnings_database = WarningsDatabase()
-
-        if os.path.exists(warnings_path):
-            try:
-                warnings_database.load_from_file(warnings_path)
-            except ValueError:
-                os.remove(warnings_path)
-
-        warnings_collector = WarningsCollector(database=warnings_database,
-            objdir=self.topobjdir)
-
-        def on_line(line):
-            try:
-                warning = warnings_collector.process_line(line)
-                if warning:
-                    self.log(logging.INFO, 'compiler_warning', warning,
-                        'Warning: {flag} in {filename}: {message}')
-            except:
-                # This will get logged in the more robust implementation.
-                pass
-
-            self.log(logging.INFO, 'build_output', {'line': line}, '{line}')
-
-        finder_start_cpu = self._get_finder_cpu_usage()
-        time_start = time.time()
-
-        if what:
-            top_make = os.path.join(self.topobjdir, 'Makefile')
-            if not os.path.exists(top_make):
-                print('Your tree has not been configured yet. Please run '
-                    '|mach build| with no arguments.')
-                return 1
-
-            # Collect target pairs.
-            target_pairs = []
-            for target in what:
-                path_arg = self._wrap_path_argument(target)
-
-                make_dir, make_target = resolve_target_to_make(self.topobjdir,
-                    path_arg.relpath())
-
-                if make_dir is None and make_target is None:
-                    return 1
-
-                target_pairs.append((make_dir, make_target))
-
-            # Possibly add extra make depencies using dumbmake.
-            if not disable_extra_make_dependencies:
-                from dumbmake.dumbmake import (dependency_map,
-                                               add_extra_dependencies)
-                depfile = os.path.join(self.topsrcdir, 'build',
-                                       'dumbmake-dependencies')
-                with open(depfile) as f:
-                    dm = dependency_map(f.readlines())
-                new_pairs = list(add_extra_dependencies(target_pairs, dm))
-                self.log(logging.DEBUG, 'dumbmake',
-                         {'target_pairs': target_pairs,
-                          'new_pairs': new_pairs},
-                         'Added extra dependencies: will build {new_pairs} ' +
-                         'instead of {target_pairs}.')
-                target_pairs = new_pairs
-
-            # Build target pairs.
-            for make_dir, make_target in target_pairs:
-                status = self._run_make(directory=make_dir, target=make_target,
-                    line_handler=on_line, log=False, print_directory=False,
-                    ensure_exit_code=False, num_jobs=jobs)
-
-                if status != 0:
-                    break
-        else:
-            status = self._run_make(srcdir=True, filename='client.mk',
-                line_handler=on_line, log=False, print_directory=False,
-                allow_parallel=False, ensure_exit_code=False, num_jobs=jobs)
-
-            self.log(logging.WARNING, 'warning_summary',
-                {'count': len(warnings_collector.database)},
-                '{count} compiler warnings present.')
-
-        warnings_database.prune()
-        warnings_database.save_to_file(warnings_path)
-
-        time_end = time.time()
-        time_elapsed = time_end - time_start
-        self._handle_finder_cpu_usage(time_elapsed, finder_start_cpu)
-
-        long_build = time_elapsed > 600
-
-        if status:
-            return status
-
-        if long_build:
-            print('We know it took a while, but your build finally finished successfully!')
-        else:
-            print('Your build was successful!')
-
-        # Only for full builds because incremental builders likely don't
-        # need to be burdened with this.
-        if not what:
-            # Fennec doesn't have useful output from just building. We should
-            # arguably make the build action useful for Fennec. Another day...
-            if self.substs['MOZ_BUILD_APP'] != 'mobile/android':
-                app_path = self.get_binary_path('app')
-                print('To take your build for a test drive, run: %s' % app_path)
-            app = self.substs['MOZ_BUILD_APP']
-            if app in ('browser', 'mobile/android'):
-                print('For more information on what to do now, see '
-                    'https://developer.mozilla.org/docs/Developer_Guide/So_You_Just_Built_Firefox')
-
-        return status
-
-    def _get_finder_cpu_usage(self):
-        """Obtain the CPU usage of the Finder app on OS X.
-
-        This is used to detect high CPU usage.
-        """
-        if not sys.platform.startswith('darwin'):
-            return None
-
-        try:
-            import psutil
-        except ImportError:
-            return None
-
-        for proc in psutil.process_iter():
-            if proc.name != 'Finder':
-                continue
-
-            if proc.username != getpass.getuser():
-                continue
-
-            # Try to isolate system finder as opposed to other "Finder"
-            # processes.
-            if not proc.exe.endswith('CoreServices/Finder.app/Contents/MacOS/Finder'):
-                continue
-
-            return proc.get_cpu_times()
-
-        return None
-
-    def _handle_finder_cpu_usage(self, elapsed, start):
-        if not start:
-            return
-
-        # We only measure if the measured range is sufficiently long.
-        if elapsed < 15:
-            return
-
-        end = self._get_finder_cpu_usage()
-        if not end:
-            return
-
-        start_total = start.user + start.system
-        end_total = end.user + end.system
-
-        cpu_seconds = end_total - start_total
-
-        # If Finder used more than 25% of 1 core during the build, report an
-        # error.
-        finder_percent = cpu_seconds / elapsed * 100
-        if finder_percent < 25:
-            return
-
-        print(FINDER_SLOW_MESSAGE % finder_percent)
-
+    def build(self, **kwargs):
+        bs = self._get_build_system()
+        return bs.build(**kwargs)
 
     @Command('configure', category='build',
         description='Configure the tree (run configure and config.status')
     def configure(self):
         def on_line(line):
             self.log(logging.INFO, 'build_output', {'line': line}, '{line}')
 
         status = self._run_make(srcdir=True, filename='client.mk',
