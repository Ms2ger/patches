# HG changeset patch
# Parent b335d88f9c147c43dc133d6729847f8fe4f0cfd7
# User Gregory Szorc <gps@mozilla.com>
Bug 787273 - Part 9: Remove Svc.Prefs singleton

Previously, code assumed a specific prefs branch was used by accessing
all prefs through Svc.Prefs. We now store a reference to a specific
prefs branch in the service instance and always use that branch.

diff --git a/browser/base/content/browser-places.js b/browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js
+++ b/browser/base/content/browser-places.js
@@ -640,17 +640,17 @@
     // Enable/disable the Tabs From Other Computers menu. Some of the menus handled
     // by HistoryMenu do not have this menuitem.
     let menuitem = this._rootElt.getElementsByClassName("syncTabsMenuItem")[0];
     if (!menuitem)
       return;
 
     // If Sync isn't configured yet, then don't show the menuitem.
     if (Weave.Status.checkSetup() == Weave.CLIENT_NOT_CONFIGURED ||
-        Weave.Svc.Prefs.get("firstSync", "") == "notReady") {
+        Weave.Service.prefs.get("firstSync", "") == "notReady") {
       menuitem.setAttribute("hidden", true);
       return;
     }
 
     // The tabs engine might never be inited (if services.sync.registerEngines
     // is modified), so make sure we avoid undefined errors.
     let enabled = Weave.Service.isLoggedIn &&
                   Weave.Service.engineManager.get("tabs") &&
diff --git a/browser/base/content/sync/setup.js b/browser/base/content/sync/setup.js
--- a/browser/base/content/sync/setup.js
+++ b/browser/base/content/sync/setup.js
@@ -93,17 +93,17 @@
       this.wizardType = window.arguments[0];
     }
     switch (this.wizardType) {
       case null:
         this.wizard.pageIndex = INTRO_PAGE;
         // Fall through!
       case "pair":
         this.captchaBrowser.addProgressListener(this);
-        Weave.Svc.Prefs.set("firstSync", "notReady");
+        Weave.Service.prefs.set("firstSync", "notReady");
         break;
       case "reset":
         this._resettingSync = true;
         this.wizard.pageIndex = OPTIONS_PAGE;
         break;
     }
 
     this.wizard.getButton("extra1").label =
@@ -160,17 +160,17 @@
     // Hide any errors about the passphrase, we know it's not right.
     let feedback = document.getElementById("existingPassphraseFeedbackRow");
     feedback.hidden = true;
     let el = document.getElementById("existingPassphrase");
     el.value = Weave.Utils.hyphenatePassphrase(passphrase);
 
     // changePassphrase() will sync, make sure we set the "firstSync" pref
     // according to the user's pref.
-    Weave.Svc.Prefs.reset("firstSync");
+    Weave.Service.prefs.reset("firstSync");
     this.setupInitialSync();
     gSyncUtils.resetPassphrase(true);
   },
 
   onResetPassphrase: function () {
     document.getElementById("existingPassphrase").value =
       Weave.Utils.hyphenatePassphrase(Weave.Service.identity.syncKey);
     this.checkFields();
@@ -234,17 +234,17 @@
       case "resetClient":
         // if we're not resetting sync, we don't need to explicitly
         // call resetClient
         if (!this._resettingSync)
           return;
         // otherwise, fall through
       case "wipeClient":
       case "wipeRemote":
-        Weave.Svc.Prefs.set("firstSync", action);
+        Weave.Service.prefs.set("firstSync", action);
         break;
     }
   },
 
   // fun with validation!
   checkFields: function () {
     this.wizard.canAdvance = this.readyToAdvance();
   },
@@ -368,17 +368,17 @@
         this.wizard.getButton("extra1").hidden = false;
         this.wizard.getButton("next").hidden = false;
         this.wizard.getButton("back").hidden = false;
         this.onServerCommand();
         this.wizard.canRewind = true;
         this.checkFields();
         break;
       case EXISTING_ACCOUNT_CONNECT_PAGE:
-        Weave.Svc.Prefs.set("firstSync", "existingAccount");
+        Weave.Service.prefs.set("firstSync", "existingAccount");
         this.wizard.getButton("next").hidden = false;
         this.wizard.getButton("back").hidden = false;
         this.wizard.getButton("extra1").hidden = false;
         this.wizard.canAdvance = false;
         this.wizard.canRewind = true;
         this.startEasySetup();
         break;
       case EXISTING_ACCOUNT_LOGIN_PAGE:
@@ -465,17 +465,17 @@
         let error = Weave.Service.createAccount(email, password,
                                                 challenge, response);
 
         if (error == null) {
           Weave.Service.identity.account = email;
           Weave.Service.identity.basicPassword = password;
           Weave.Service.identity.syncKey = Weave.Utils.generatePassphrase();
           this._handleNoScript(false);
-          Weave.Svc.Prefs.set("firstSync", "newAccount");
+          Weave.Service.prefs.set("firstSync", "newAccount");
           this.wizardFinish();
           return false;
         }
 
         image.setAttribute("status", "error");
         label.value = Weave.Utils.getErrorString(error);
         return false;
       case EXISTING_ACCOUNT_LOGIN_PAGE:
@@ -543,21 +543,21 @@
     if (!this._resettingSync) {
       function isChecked(element) {
         return document.getElementById(element).hasAttribute("checked");
       }
 
       let prefs = ["engine.bookmarks", "engine.passwords", "engine.history",
                    "engine.tabs", "engine.prefs", "engine.addons"];
       for (let i = 0;i < prefs.length;i++) {
-        Weave.Svc.Prefs.set(prefs[i], isChecked(prefs[i]));
+        Weave.Service.prefs.set(prefs[i], isChecked(prefs[i]));
       }
       this._handleNoScript(false);
-      if (Weave.Svc.Prefs.get("firstSync", "") == "notReady")
-        Weave.Svc.Prefs.reset("firstSync");
+      if (Weave.Service.prefs.get("firstSync", "") == "notReady")
+        Weave.Service.prefs.reset("firstSync");
 
       Weave.Service.persistLogin();
       Weave.Svc.Obs.notify("weave:service:setup-complete");
 
       gSyncUtils.openFirstSyncProgressPage();
     }
     Weave.Utils.nextTick(Weave.Service.sync, Weave.Service);
     window.close();
@@ -733,17 +733,17 @@
       this._disabledSites = [];
     }
   },
 
   onExistingServerCommand: function () {
     let control = document.getElementById("existingServer");
     if (control.selectedIndex == 0) {
       control.removeAttribute("editable");
-      Weave.Svc.Prefs.reset("serverURL");
+      Weave.Service.prefs.reset("serverURL");
     } else {
       control.setAttribute("editable", "true");
       // Force a style flush to ensure that the binding is attached.
       control.clientTop;
       control.value = "";
       control.inputField.focus();
     }
     document.getElementById("existingServerFeedbackRow").hidden = true;
@@ -768,17 +768,17 @@
       control.clientTop;
       control.value = "";
       control.inputField.focus();
       // checkServer() will call checkAccount() and checkFields().
       this.checkServer();
       return;
     }
     control.removeAttribute("editable");
-    Weave.Svc.Prefs.reset("serverURL");
+    Weave.Service.prefs.reset("serverURL");
     if (this._settingUpNew) {
       this.loadCaptcha();
     }
     this.checkAccount();
     this.status.server = true;
     document.getElementById("serverFeedbackRow").hidden = true;
     this.checkFields();
   },
@@ -850,17 +850,17 @@
     else if (uri) {
       valid = true;
       Weave.Service.serverURL = uri.spec;
     }
 
     if (valid)
       element.value = Weave.Service.serverURL;
     else
-      Weave.Svc.Prefs.reset("serverURL");
+      Weave.Service.prefs.reset("serverURL");
 
     return valid;
   },
 
   _handleChoice: function () {
     let desc = document.getElementById("mergeChoiceRadio").selectedIndex;
     document.getElementById("chosenActionDeck").selectedIndex = desc;
     switch (desc) {
diff --git a/browser/base/content/sync/utils.js b/browser/base/content/sync/utils.js
--- a/browser/base/content/sync/utils.js
+++ b/browser/base/content/sync/utils.js
@@ -61,21 +61,21 @@
       this.openChange("UpdatePassphrase");
   },
 
   resetPassword: function () {
     this._openLink(Weave.Service.pwResetURL);
   },
 
   openToS: function () {
-    this._openLink(Weave.Svc.Prefs.get("termsURL"));
+    this._openLink(Weave.Service.prefs.get("termsURL"));
   },
 
   openPrivacyPolicy: function () {
-    this._openLink(Weave.Svc.Prefs.get("privacyURL"));
+    this._openLink(Weave.Service.prefs.get("privacyURL"));
   },
 
   openFirstSyncProgressPage: function () {
     this._openLink("about:sync-progress");
   },
 
   /**
    * Prepare an invisible iframe with the passphrase backup document.
@@ -95,22 +95,22 @@
     iframe.contentWindow.addEventListener("load", function() {
       iframe.contentWindow.removeEventListener("load", arguments.callee, false);
 
       // Insert the Sync Key into the page.
       let el = iframe.contentDocument.getElementById("synckey");
       el.firstChild.nodeValue = pp;
 
       // Insert the TOS and Privacy Policy URLs into the page.
-      let termsURL = Weave.Svc.Prefs.get("termsURL");
+      let termsURL = Weave.Service.prefs.get("termsURL");
       el = iframe.contentDocument.getElementById("tosLink");
       el.setAttribute("href", termsURL);
       el.firstChild.nodeValue = termsURL;
 
-      let privacyURL = Weave.Svc.Prefs.get("privacyURL");
+      let privacyURL = Weave.Service.prefs.get("privacyURL");
       el = iframe.contentDocument.getElementById("ppLink");
       el.setAttribute("href", privacyURL);
       el.firstChild.nodeValue = privacyURL;
 
       callback(iframe);
     }, false);
   },
 
diff --git a/browser/components/preferences/in-content/sync.js b/browser/components/preferences/in-content/sync.js
--- a/browser/components/preferences/in-content/sync.js
+++ b/browser/components/preferences/in-content/sync.js
@@ -17,17 +17,17 @@
     return document.getElementById("weavePrefsDeck").selectedIndex;
   },
 
   set page(val) {
     document.getElementById("weavePrefsDeck").selectedIndex = val;
   },
 
   get _usingCustomServer() {
-    return Weave.Svc.Prefs.isSet("serverURL");
+    return Weave.Service.prefs.isSet("serverURL");
   },
 
   needsUpdate: function () {
     this.page = PAGE_NEEDS_UPDATE;
     let label = document.getElementById("loginError");
     label.value = Weave.Utils.getErrorString(Weave.Status.login);
     label.className = "error";
   },
@@ -53,17 +53,17 @@
 
     this._stringBundle =
       Services.strings.createBundle("chrome://browser/locale/preferences/preferences.properties");
     this.updateWeavePrefs();
   },
 
   updateWeavePrefs: function () {
     if (Weave.Status.service == Weave.CLIENT_NOT_CONFIGURED ||
-        Weave.Svc.Prefs.get("firstSync", "") == "notReady") {
+        Weave.Service.prefs.get("firstSync", "") == "notReady") {
       this.page = PAGE_NO_ACCOUNT;
     } else if (Weave.Status.login == Weave.LOGIN_FAILED_INVALID_PASSPHRASE ||
                Weave.Status.login == Weave.LOGIN_FAILED_LOGIN_REJECTED) {
       this.needsUpdate();
     } else {
       this.page = PAGE_HAS_ACCOUNT;
       document.getElementById("accountName").value = Weave.Service.identity.account;
       document.getElementById("syncComputerName").value = Weave.Service.clientsEngine.localName;
diff --git a/browser/components/preferences/sync.js b/browser/components/preferences/sync.js
--- a/browser/components/preferences/sync.js
+++ b/browser/components/preferences/sync.js
@@ -18,17 +18,17 @@
     return document.getElementById("weavePrefsDeck").selectedIndex;
   },
 
   set page(val) {
     document.getElementById("weavePrefsDeck").selectedIndex = val;
   },
 
   get _usingCustomServer() {
-    return Weave.Svc.Prefs.isSet("serverURL");
+    return Weave.Service.prefs.isSet("serverURL");
   },
 
   needsUpdate: function () {
     this.page = PAGE_NEEDS_UPDATE;
     let label = document.getElementById("loginError");
     label.value = Weave.Utils.getErrorString(Weave.Status.login);
     label.className = "error";
   },
@@ -54,17 +54,17 @@
 
     this._stringBundle =
       Services.strings.createBundle("chrome://browser/locale/preferences/preferences.properties");
     this.updateWeavePrefs();
   },
 
   updateWeavePrefs: function () {
     if (Weave.Status.service == Weave.CLIENT_NOT_CONFIGURED ||
-        Weave.Svc.Prefs.get("firstSync", "") == "notReady") {
+        Weave.Service.prefs.get("firstSync", "") == "notReady") {
       this.page = PAGE_NO_ACCOUNT;
     } else if (Weave.Status.login == Weave.LOGIN_FAILED_INVALID_PASSPHRASE ||
                Weave.Status.login == Weave.LOGIN_FAILED_LOGIN_REJECTED) {
       this.needsUpdate();
     } else {
       this.page = PAGE_HAS_ACCOUNT;
       document.getElementById("accountName").value = Weave.Service.identity.account;
       document.getElementById("syncComputerName").value = Weave.Service.clientsEngine.localName;
diff --git a/services/sync/modules-testing/rotaryengine.js b/services/sync/modules-testing/rotaryengine.js
--- a/services/sync/modules-testing/rotaryengine.js
+++ b/services/sync/modules-testing/rotaryengine.js
@@ -27,17 +27,17 @@
 function RotaryRecord(collection, id) {
   CryptoWrapper.call(this, collection, id);
 }
 RotaryRecord.prototype = {
   __proto__: CryptoWrapper.prototype
 };
 Utils.deferGetSet(RotaryRecord, "cleartext", ["denomination"]);
 
-function RotaryStore(engine) {
+function RotaryStore(name, engine) {
   Store.call(this, "Rotary", engine);
   this.items = {};
 }
 RotaryStore.prototype = {
   __proto__: Store.prototype,
 
   create: function create(record) {
     this.items[record.id] = record.denomination;
@@ -83,17 +83,17 @@
     return ids;
   },
 
   wipe: function wipe() {
     this.items = {};
   }
 };
 
-function RotaryTracker(engine) {
+function RotaryTracker(name, engine) {
   Tracker.call(this, "Rotary", engine);
 }
 RotaryTracker.prototype = {
   __proto__: Tracker.prototype
 };
 
 
 function RotaryEngine(service) {
diff --git a/services/sync/modules/addonsreconciler.js b/services/sync/modules/addonsreconciler.js
--- a/services/sync/modules/addonsreconciler.js
+++ b/services/sync/modules/addonsreconciler.js
@@ -51,17 +51,17 @@
  * The internal state is persisted to a JSON file in the profile directory.
  *
  * An instance of this is bound to an AddonsEngine instance. In reality, it
  * likely exists as a singleton. To AddonsEngine, it functions as a store and
  * an entity which emits events for tracking.
  *
  * The usage pattern for instances of this class is:
  *
- *   let reconciler = new AddonsReconciler();
+ *   let reconciler = new AddonsReconciler(prefs);
  *   reconciler.loadState(null, function(error) { ... });
  *
  *   // At this point, your instance should be ready to use.
  *
  * When you are finished with the instance, please call:
  *
  *   reconciler.stopListening();
  *   reconciler.saveStateFile(...);
@@ -107,20 +107,23 @@
  *
  * Restartless add-ons have interesting behavior during uninstall. These
  * add-ons are first disabled then they are actually uninstalled. So, we will
  * see AL.onDisabling and AL.onDisabled. The onUninstalling and onUninstalled
  * events only come after the Addon Manager is closed or another view is
  * switched to. In the case of Sync performing the uninstall, the uninstall
  * events will occur immediately. However, we still see disabling events and
  * heed them like they were normal. In the end, the state is proper.
+ *
+ * @param prefs
+ *        (Preferences) Prefs branch to use.
  */
-function AddonsReconciler() {
+function AddonsReconciler(prefs) {
   this._log = Log4Moz.repository.getLogger("Sync.AddonsReconciler");
-  let level = Svc.Prefs.get("log.logger.addonsreconciler", "Debug");
+  let level = prefs.get("log.logger.addonsreconciler", "Debug");
   this._log.level = Log4Moz.Level[level];
 
   Svc.Obs.add("xpcom-shutdown", this.stopListening, this);
 };
 AddonsReconciler.prototype = {
   /** Flag indicating whether we are listening to AddonManager events. */
   _listening: false,
 
diff --git a/services/sync/modules/addonutils.js b/services/sync/modules/addonutils.js
--- a/services/sync/modules/addonutils.js
+++ b/services/sync/modules/addonutils.js
@@ -5,26 +5,28 @@
 "use strict";
 
 const EXPORTED_SYMBOLS = ["AddonUtils"];
 
 const {interfaces: Ci, utils: Cu} = Components;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/util.js");
 
 XPCOMUtils.defineLazyModuleGetter(this, "AddonManager",
   "resource://gre/modules/AddonManager.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "AddonRepository",
   "resource://gre/modules/AddonRepository.jsm");
 
-function AddonUtilsInternal() {
+function AddonUtilsInternal(prefs) {
   this._log = Log4Moz.repository.getLogger("Sync.AddonUtils");
-  this._log.Level = Log4Moz.Level[Svc.Prefs.get("log.logger.addonutils")];
+  this._log.Level = Log4Moz.Level[prefs.get("log.logger.addonutils")];
 }
 AddonUtilsInternal.prototype = {
   /**
    * Obtain an AddonInstall object from an AddonSearchResult instance.
    *
    * The callback will be invoked with the result of the operation. The
    * callback receives 2 arguments, error and result. Error will be falsy
    * on success or some kind of error value otherwise. The result argument
@@ -465,10 +467,10 @@
       return;
     }
     // Else the listener will handle invoking the callback.
   },
 
 };
 
 XPCOMUtils.defineLazyGetter(this, "AddonUtils", function() {
-  return new AddonUtilsInternal();
+  return new AddonUtilsInternal(new Preferences(PREFS_BRANCH));
 });
diff --git a/services/sync/modules/engines.js b/services/sync/modules/engines.js
--- a/services/sync/modules/engines.js
+++ b/services/sync/modules/engines.js
@@ -33,22 +33,27 @@
  * want to sync.
  *
  */
 function Tracker(name, engine) {
   if (!engine) {
     throw new Error("Tracker must be associated with an Engine instance.");
   }
 
+  if (!engine.prefs) {
+    throw new Error("Engine does not have prefs instance.");
+  }
+
   name = name || "Unnamed";
   this.name = this.file = name.toLowerCase();
   this.engine = engine;
+  this.prefs = engine.prefs;
 
   this._log = Log4Moz.repository.getLogger("Sync.Tracker." + name);
-  let level = Svc.Prefs.get("log.logger.engine." + this.name, "Debug");
+  let level = engine.prefs.get("log.logger.engine." + this.name, "Debug");
   this._log.level = Log4Moz.Level[level];
 
   this._score = 0;
   this._ignored = [];
   this.ignoreAll = false;
   this.changedIDs = {};
   this.loadChangedIDs();
 }
@@ -174,19 +179,20 @@
 function Store(name, engine) {
   if (!engine) {
     throw new Error("Store must be associated with an Engine instance.");
   }
 
   name = name || "Unnamed";
   this.name = name.toLowerCase();
   this.engine = engine;
+  this.prefs = engine.prefs;
 
   this._log = Log4Moz.repository.getLogger("Sync.Store." + name);
-  let level = Svc.Prefs.get("log.logger.engine." + this.name, "Debug");
+  let level = this.prefs.get("log.logger.engine." + this.name, "Debug");
   this._log.level = Log4Moz.Level[level];
 
   XPCOMUtils.defineLazyGetter(this, "_timer", function() {
     return Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
   });
 }
 Store.prototype = {
 
@@ -362,17 +368,17 @@
   }
 };
 
 function EngineManager(service) {
   this.service = service;
 
   this._engines = {};
   this._log = Log4Moz.repository.getLogger("Sync.EngineManager");
-  this._log.level = Log4Moz.Level[Svc.Prefs.get(
+  this._log.level = Log4Moz.Level[service.prefs.get(
     "log.logger.service.engines", "Debug")];
 }
 EngineManager.prototype = {
   get: function get(name) {
     // Return an array of engines if we have an array of names
     if (Array.isArray(name)) {
       let engines = [];
       name.forEach(function(name) {
@@ -452,39 +458,50 @@
 function Engine(name, service) {
   if (!service) {
     throw new Error("Engine must be associated with a Service instance.");
   }
 
   this.Name = name || "Unnamed";
   this.name = name.toLowerCase();
   this.service = service;
+  this.prefs = this.service.prefs;
 
   this._notify = Utils.notify("weave:engine:");
   this._log = Log4Moz.repository.getLogger("Sync.Engine." + this.Name);
-  let level = Svc.Prefs.get("log.logger.engine." + this.name, "Debug");
+  let level = this.prefs.get("log.logger.engine." + this.name, "Debug");
   this._log.level = Log4Moz.Level[level];
 
   this._tracker; // initialize tracker to load previously changed IDs
   this._log.debug("Engine initialized");
 }
 Engine.prototype = {
   // _storeObj, and _trackerObj should to be overridden in subclasses
   _storeObj: Store,
   _trackerObj: Tracker,
 
   // Local 'constant'.
   // Signal to the engine that processing further records is pointless.
   eEngineAbortApplyIncoming: "error.engine.abort.applyincoming",
 
-  get prefName() this.name,
-  get enabled() Svc.Prefs.get("engine." + this.prefName, false),
-  set enabled(val) Svc.Prefs.set("engine." + this.prefName, !!val),
+  get prefName() {
+    return this.name;
+  },
 
-  get score() this._tracker.score,
+  get enabled() {
+    return this.prefs.get("engine." + this.prefName, false);
+  },
+
+  set enabled(val) {
+    this.prefs.set("engine." + this.prefName, !!val)
+  },
+
+  get score() {
+    return this._tracker.score;
+  },
 
   get _store() {
     let store = new this._storeObj(this.Name, this);
     this.__defineGetter__("_store", function() store);
     return store;
   },
 
   get _tracker() {
@@ -554,50 +571,58 @@
   // How many records to pull at one time when specifying IDs. This is to avoid
   // URI length limitations.
   guidFetchBatchSize: DEFAULT_GUID_FETCH_BATCH_SIZE,
   mobileGUIDFetchBatchSize: DEFAULT_MOBILE_GUID_FETCH_BATCH_SIZE,
   
   // How many records to process in a single batch.
   applyIncomingBatchSize: DEFAULT_STORE_BATCH_SIZE,
 
-  get storageURL() Svc.Prefs.get("clusterURL") + SYNC_API_VERSION +
-    "/" + this.service.identity.username + "/storage/",
+  get storageURL() {
+    return this.prefs.get("clusterURL") + SYNC_API_VERSION +
+           "/" + this.service.identity.username + "/storage/";
+  },
 
-  get engineURL() this.storageURL + this.name,
+  get engineURL() {
+    return this.storageURL + this.name;
+  },
 
-  get cryptoKeysURL() this.storageURL + "crypto/keys",
+  get cryptoKeysURL() {
+    return this.storageURL + "crypto/keys";
+  },
 
-  get metaURL() this.storageURL + "meta/global",
+  get metaURL() {
+    return this.storageURL + "meta/global";
+  },
 
   get syncID() {
     // Generate a random syncID if we don't have one
-    let syncID = Svc.Prefs.get(this.name + ".syncID", "");
+    let syncID = this.prefs.get(this.name + ".syncID", "");
     return syncID == "" ? this.syncID = Utils.makeGUID() : syncID;
   },
   set syncID(value) {
-    Svc.Prefs.set(this.name + ".syncID", value);
+    this.prefs.set(this.name + ".syncID", value);
   },
 
   /*
    * lastSync is a timestamp in server time.
    */
   get lastSync() {
-    return parseFloat(Svc.Prefs.get(this.name + ".lastSync", "0"));
+    return parseFloat(this.prefs.get(this.name + ".lastSync", "0"));
   },
   set lastSync(value) {
     // Reset the pref in-case it's a number instead of a string
-    Svc.Prefs.reset(this.name + ".lastSync");
+    this.prefs.reset(this.name + ".lastSync");
     // Store the value as a string to keep floating point precision
-    Svc.Prefs.set(this.name + ".lastSync", value.toString());
+    this.prefs.set(this.name + ".lastSync", value.toString());
   },
   resetLastSync: function SyncEngine_resetLastSync() {
     this._log.debug("Resetting " + this.name + " last sync time");
-    Svc.Prefs.reset(this.name + ".lastSync");
-    Svc.Prefs.set(this.name + ".lastSync", "0");
+    this.prefs.reset(this.name + ".lastSync");
+    this.prefs.set(this.name + ".lastSync", "0");
     this.lastSyncLocal = 0;
   },
 
   get toFetch() this._toFetch,
   set toFetch(val) {
     // Coerce the array to a string for more efficient comparison.
     if (val + "" == this._toFetch) {
       return;
@@ -639,21 +664,21 @@
       }
     });
   },
 
   /*
    * lastSyncLocal is a timestamp in local time.
    */
   get lastSyncLocal() {
-    return parseInt(Svc.Prefs.get(this.name + ".lastSyncLocal", "0"), 10);
+    return parseInt(this.prefs.get(this.name + ".lastSyncLocal", "0"), 10);
   },
   set lastSyncLocal(value) {
     // Store as a string because pref can only store C longs as numbers.
-    Svc.Prefs.set(this.name + ".lastSyncLocal", value.toString());
+    this.prefs.set(this.name + ".lastSyncLocal", value.toString());
   },
 
   /*
    * Returns a mapping of IDs -> changed timestamp. Engine implementations
    * can override this method to bypass the tracker for certain or all
    * changed items.
    */
   getChangedIDs: function getChangedIDs() {
@@ -744,17 +769,17 @@
 
   // Process incoming records
   _processIncoming: function SyncEngine__processIncoming() {
     this._log.trace("Downloading & applying server changes");
 
     // Figure out how many total items to fetch this sync; do less on mobile.
     let batchSize = Infinity;
     let newitems = new Collection(this.engineURL, this._recordObj, this.service);
-    let isMobile = (Svc.Prefs.get("client.type") == "mobile");
+    let isMobile = (this.prefs.get("client.type") == "mobile");
 
     if (isMobile) {
       batchSize = MOBILE_BATCH_SIZE;
     }
     newitems.newer = this.lastSync;
     newitems.full  = true;
     newitems.limit = batchSize;
     
diff --git a/services/sync/modules/engines/addons.js b/services/sync/modules/engines/addons.js
--- a/services/sync/modules/engines/addons.js
+++ b/services/sync/modules/engines/addons.js
@@ -105,17 +105,17 @@
  * that AddonManager doesn't.
  *
  * The engine instance overrides a handful of functions on the base class. The
  * rationale for each is documented by that function.
  */
 function AddonsEngine(service) {
   SyncEngine.call(this, "Addons", service);
 
-  this._reconciler = new AddonsReconciler();
+  this._reconciler = new AddonsReconciler(this.prefs);
 }
 AddonsEngine.prototype = {
   __proto__:              SyncEngine.prototype,
   _storeObj:              AddonsStore,
   _trackerObj:            AddonsTracker,
   _recordObj:             AddonRecord,
   version:                1,
 
@@ -284,17 +284,17 @@
    * Provides core Store API to create/install an add-on from a record.
    */
   create: function create(record) {
     let cb = Async.makeSpinningCallback();
     AddonUtils.installAddons([{
       id:               record.addonID,
       syncGUID:         record.id,
       enabled:          record.enabled,
-      requireSecureURI: !Svc.Prefs.get("addons.ignoreRepositoryChecking", false),
+      requireSecureURI: !this.prefs.get("addons.ignoreRepositoryChecking", false),
     }], cb);
 
     // This will throw if there was an error. This will get caught by the sync
     // engine and the record will try to be applied later.
     let results = cb.wait();
 
     let addon;
     for each (let a in results.addons) {
@@ -553,17 +553,17 @@
     if (this._extensionsPrefs.get("hotfix.id", null) == addon.id) {
       this._log.debug(addon.id + " not syncable: is a hotfix.");
       return false;
     }
 
     // We provide a back door to skip the repository checking of an add-on.
     // This is utilized by the tests to make testing easier. Users could enable
     // this, but it would sacrifice security.
-    if (Svc.Prefs.get("addons.ignoreRepositoryChecking", false)) {
+    if (this.prefs.get("addons.ignoreRepositoryChecking", false)) {
       return true;
     }
 
     let cb = Async.makeSyncCallback();
     AddonRepository.getCachedAddonByID(addon.id, cb);
     let result = Async.waitForSyncCallback(cb);
 
     if (!result) {
@@ -585,17 +585,17 @@
    * @param  uri
    *         nsIURI instance to validate
    * @return bool
    */
   isSourceURITrusted: function isSourceURITrusted(uri) {
     // For security reasons, we currently limit synced add-ons to those
     // installed from trusted hostname(s). We additionally require TLS with
     // the add-ons site to help prevent forgeries.
-    let trustedHostnames = Svc.Prefs.get("addons.trustedSourceHostnames", "")
+    let trustedHostnames = this.prefs.get("addons.trustedSourceHostnames", "")
                            .split(",");
 
     if (!uri) {
       this._log.debug("Undefined argument to isSourceURITrusted().");
       return false;
     }
 
     // Scheme is validated before the hostname because uri.host may not be
@@ -632,17 +632,17 @@
    */
   updateUserDisabled: function updateUserDisabled(addon, value, callback) {
     if (addon.userDisabled == value) {
       callback(null, addon);
       return;
     }
 
     // A pref allows changes to the enabled flag to be ignored.
-    if (Svc.Prefs.get("addons.ignoreUserEnabledChanges", false)) {
+    if (this.prefs.get("addons.ignoreUserEnabledChanges", false)) {
       this._log.info("Ignoring enabled state change due to preference: " +
                      addon.id);
       callback(null, addon);
       return;
     }
 
     AddonUtils.updateUserDisabled(addon, value, callback);
   },
diff --git a/services/sync/modules/engines/clients.js b/services/sync/modules/engines/clients.js
--- a/services/sync/modules/engines/clients.js
+++ b/services/sync/modules/engines/clients.js
@@ -41,20 +41,20 @@
   _storeObj: ClientStore,
   _recordObj: ClientsRec,
   _trackerObj: ClientsTracker,
 
   // Always sync client data as it controls other sync behavior
   get enabled() true,
 
   get lastRecordUpload() {
-    return Svc.Prefs.get(this.name + ".lastRecordUpload", 0);
+    return this.prefs.get(this.name + ".lastRecordUpload", 0);
   },
   set lastRecordUpload(value) {
-    Svc.Prefs.set(this.name + ".lastRecordUpload", Math.floor(value));
+    this.prefs.set(this.name + ".lastRecordUpload", Math.floor(value));
   },
 
   // Aggregate some stats on the composition of clients on this account
   get stats() {
     let stats = {
       hasMobile: this.localType == "mobile",
       names: [this.localName],
       numClients: 1,
@@ -66,45 +66,53 @@
       stats.numClients++;
     }
 
     return stats;
   },
 
   get localID() {
     // Generate a random GUID id we don't have one
-    let localID = Svc.Prefs.get("client.GUID", "");
+    let localID = this.prefs.get("client.GUID", "");
     return localID == "" ? this.localID = Utils.makeGUID() : localID;
   },
-  set localID(value) Svc.Prefs.set("client.GUID", value),
+  set localID(value) this.prefs.set("client.GUID", value),
 
   get localName() {
-    let localName = Svc.Prefs.get("client.name", "");
+    let localName = this.prefs.get("client.name", "");
     if (localName != "")
       return localName;
 
     // Generate a client name if we don't have a useful one yet
     let env = Cc["@mozilla.org/process/environment;1"]
                 .getService(Ci.nsIEnvironment);
     let user = env.get("USER") || env.get("USERNAME") ||
-               Svc.Prefs.get("account") || Svc.Prefs.get("username");
+               this.prefs.get("account") || this.prefs.get("username");
     let brand = new StringBundle("chrome://branding/locale/brand.properties");
     let app = brand.get("brandShortName");
 
     let system = Cc["@mozilla.org/system-info;1"]
                    .getService(Ci.nsIPropertyBag2).get("device") ||
                  Cc["@mozilla.org/network/protocol;1?name=http"]
                    .getService(Ci.nsIHttpProtocolHandler).oscpu;
 
     return this.localName = Str.sync.get("client.name2", [user, app, system]);
   },
-  set localName(value) Svc.Prefs.set("client.name", value),
 
-  get localType() Svc.Prefs.get("client.type", "desktop"),
-  set localType(value) Svc.Prefs.set("client.type", value),
+  set localName(value) {
+    this.prefs.set("client.name", value);
+  },
+
+  get localType() {
+    return this.prefs.get("client.type", "desktop");
+  },
+
+  set localType(value) {
+    this.prefs.set("client.type", value);
+  },
 
   isMobile: function isMobile(id) {
     if (this._store._remoteClients[id])
       return this._store._remoteClients[id].type == "mobile";
     return false;
   },
 
   _syncStartup: function _syncStartup() {
@@ -407,26 +415,26 @@
   __proto__: Tracker.prototype,
 
   _enabled: false,
 
   observe: function observe(subject, topic, data) {
     switch (topic) {
       case "weave:engine:start-tracking":
         if (!this._enabled) {
-          Svc.Prefs.observe("client.name", this);
+          this.prefs.observe("client.name", this);
           this._enabled = true;
         }
         break;
       case "weave:engine:stop-tracking":
         if (this._enabled) {
-          Svc.Prefs.ignore("clients.name", this);
+          this.prefs.ignore("clients.name", this);
           this._enabled = false;
         }
         break;
       case "nsPref:changed":
         this._log.debug("client.name preference changed");
-        this.addChangedID(Svc.Prefs.get("client.GUID"));
+        this.addChangedID(this.prefs.get("client.GUID"));
         this.score += SCORE_INCREMENT_XLARGE;
         break;
     }
   }
 };
diff --git a/services/sync/modules/engines/passwords.js b/services/sync/modules/engines/passwords.js
--- a/services/sync/modules/engines/passwords.js
+++ b/services/sync/modules/engines/passwords.js
@@ -35,28 +35,28 @@
   _trackerObj: PasswordTracker,
   _recordObj: LoginRec,
   applyIncomingBatchSize: PASSWORDS_STORE_BATCH_SIZE,
 
   _syncFinish: function _syncFinish() {
     SyncEngine.prototype._syncFinish.call(this);
 
     // Delete the weave credentials from the server once
-    if (!Svc.Prefs.get("deletePwd", false)) {
+    if (!this.prefs.get("deletePwd", false)) {
       try {
         let ids = Services.logins.findLogins({}, PWDMGR_HOST, "", "")
                           .map(function(info) {
           return info.QueryInterface(Components.interfaces.nsILoginMetaInfo).guid;
         });
         let coll = new Collection(this.engineURL, null, this.service);
         coll.ids = ids;
         let ret = coll.delete();
         this._log.debug("Delete result: " + ret);
 
-        Svc.Prefs.set("deletePwd", true);
+        this.prefs.set("deletePwd", true);
       }
       catch(ex) {
         this._log.debug("Password deletes failed: " + Utils.exceptionStr(ex));
       }
     }
   },
 
   _findDupe: function _findDupe(item) {
diff --git a/services/sync/modules/engines/prefs.js b/services/sync/modules/engines/prefs.js
--- a/services/sync/modules/engines/prefs.js
+++ b/services/sync/modules/engines/prefs.js
@@ -193,20 +193,20 @@
   Svc.Obs.add("profile-before-change", this);
   Svc.Obs.add("weave:engine:start-tracking", this);
   Svc.Obs.add("weave:engine:stop-tracking", this);
 }
 PrefTracker.prototype = {
   __proto__: Tracker.prototype,
 
   get modified() {
-    return Svc.Prefs.get("engine.prefs.modified", false);
+    return this.prefs.get("engine.prefs.modified", false);
   },
   set modified(value) {
-    Svc.Prefs.set("engine.prefs.modified", value);
+    this.prefs.set("engine.prefs.modified", value);
   },
 
   loadChangedIDs: function loadChangedIDs() {
     // Don't read changed IDs from disk at start up.
   },
 
   clearChangedIDs: function clearChangedIDs() {
     this.modified = false;
diff --git a/services/sync/modules/engines/tabs.js b/services/sync/modules/engines/tabs.js
--- a/services/sync/modules/engines/tabs.js
+++ b/services/sync/modules/engines/tabs.js
@@ -116,17 +116,17 @@
     let weaveLastUsed = tab.extData && tab.extData.weaveLastUsed;
     if (!weaveLastUsed) {
       return 0;
     }
     return parseInt(weaveLastUsed, 10) || 0;
   },
 
   getAllTabs: function getAllTabs(filter) {
-    let filteredUrls = new RegExp(Svc.Prefs.get("engine.tabs.filteredUrls"), "i");
+    let filteredUrls = new RegExp(this.prefs.get("engine.tabs.filteredUrls"), "i");
 
     let allTabs = [];
 
     let currentState = JSON.parse(Svc.Session.getBrowserState());
     let tabLastUsed = this.tabLastUsed;
     currentState.windows.forEach(function(window) {
       window.tabs.forEach(function(tab) {
         // Make sure there are history entries to look at.
@@ -209,26 +209,29 @@
   },
 
   create: function TabStore_create(record) {
     this._log.debug("Adding remote tabs from " + record.clientName);
     this._remoteClients[record.id] = record.cleartext;
 
     // Lose some precision, but that's good enough (seconds)
     let roundModify = Math.floor(record.modified / 1000);
-    let notifyState = Svc.Prefs.get("notifyTabState");
+    let notifyState = this.prefs.get("notifyTabState");
     // If there's no existing pref, save this first modified time
-    if (notifyState == null)
-      Svc.Prefs.set("notifyTabState", roundModify);
+    if (notifyState == null) {
+      this.prefs.set("notifyTabState", roundModify);
+    }
     // Don't change notifyState if it's already 0 (don't notify)
-    else if (notifyState == 0)
+    else if (notifyState == 0) {
       return;
+    }
     // We must have gotten a new tab that isn't the same as last time
-    else if (notifyState != roundModify)
-      Svc.Prefs.set("notifyTabState", 0);
+    else if (notifyState != roundModify) {
+      this.prefs.set("notifyTabState", 0);
+    }
   },
 
   update: function update(record) {
     this._log.trace("Ignoring tab updates as local ones win");
   }
 };
 
 
diff --git a/services/sync/modules/identity.js b/services/sync/modules/identity.js
--- a/services/sync/modules/identity.js
+++ b/services/sync/modules/identity.js
@@ -44,19 +44,25 @@
  * mechanism needs them to do. In addition, you may wish to install custom
  * functions to support your API. Although, that is certainly not required.
  * If you do monkeypatch, please be advised that Sync expects the core
  * attributes to have values. You will need to carry at least account and
  * username forward. If you do not wish to support one of the built-in
  * authentication mechanisms, you'll probably want to redefine currentAuthState
  * and any other function that involves the built-in functionality.
  */
-function IdentityManager() {
+function IdentityManager(prefs) {
+  if (!prefs) {
+    throw new Error("IdentityManager must be constructed with a Preferences.");
+  }
+
+  this._prefs = prefs;
+
   this._log = Log4Moz.repository.getLogger("Sync.Identity");
-  this._log.Level = Log4Moz.Level[Svc.Prefs.get("log.logger.identity")];
+  this._log.Level = Log4Moz.Level[prefs.get("log.logger.identity")];
 
   this._basicPassword = null;
   this._basicPasswordAllowLookup = true;
   this._basicPasswordUpdated = false;
   this._syncKey = null;
   this._syncKeyAllowLookup = true;
   this._syncKeySet = false;
   this._syncKeyBundle = null;
@@ -70,17 +76,17 @@
 
   _syncKey: null,
   _syncKeyAllowLookup: true,
   _syncKeySet: false,
 
   _syncKeyBundle: null,
 
   get account() {
-    return Svc.Prefs.get("account", this.username);
+    return this._prefs.get("account", this.username);
   },
 
   /**
    * Sets the active account name.
    *
    * This should almost always be called in favor of setting username, as
    * username is derived from account.
    *
@@ -88,44 +94,44 @@
    * credentials. Keep in mind that persistCredentials() will need to be called
    * to flush the changes to disk.
    *
    * Set this value to null to clear out identity information.
    */
   set account(value) {
     if (value) {
       value = value.toLowerCase();
-      Svc.Prefs.set("account", value);
+      this._prefs.set("account", value);
     } else {
-      Svc.Prefs.reset("account");
+      this._prefs.reset("account");
     }
 
     this.username = this.usernameFromAccount(value);
   },
 
   get username() {
-    return Svc.Prefs.get("username", null);
+    return this._prefs.get("username", null);
   },
 
   /**
    * Set the username value.
    *
    * Changing the username has the side-effect of wiping credentials.
    */
   set username(value) {
     if (value) {
       value = value.toLowerCase();
 
       if (value == this.username) {
         return;
       }
 
-      Svc.Prefs.set("username", value);
+      this._prefs.set("username", value);
     } else {
-      Svc.Prefs.reset("username");
+      this._prefs.reset("username");
     }
 
     // If we change the username, we interpret this as a major change event
     // and wipe out the credentials.
     this._log.info("Username changed. Removing stored credentials.");
     this.basicPassword = null;
     this.syncKey = null;
     // syncKeyBundle cleared as a result of setting syncKey.
diff --git a/services/sync/modules/jpakeclient.js b/services/sync/modules/jpakeclient.js
--- a/services/sync/modules/jpakeclient.js
+++ b/services/sync/modules/jpakeclient.js
@@ -108,24 +108,25 @@
  * 
  *   client.abort();
  * 
  * Note that after completion or abort, the 'client' instance may not be reused.
  * You will have to create a new one in case you'd like to restart the process.
  */
 function JPAKEClient(controller) {
   this.controller = controller;
+  this.prefs = controller.prefs;
 
   this._log = Log4Moz.repository.getLogger("Sync.JPAKEClient");
-  this._log.level = Log4Moz.Level[Svc.Prefs.get(
+  this._log.level = Log4Moz.Level[controller.prefs.get(
     "log.logger.service.jpakeclient", "Debug")];
 
-  this._serverURL = Svc.Prefs.get("jpake.serverURL");
-  this._pollInterval = Svc.Prefs.get("jpake.pollInterval");
-  this._maxTries = Svc.Prefs.get("jpake.maxTries");
+  this._serverURL = controller.prefs.get("jpake.serverURL");
+  this._pollInterval = controller.prefs.get("jpake.pollInterval");
+  this._maxTries = controller.prefs.get("jpake.maxTries");
   if (this._serverURL.slice(-1) != "/") {
     this._serverURL += "/";
   }
 
   this._jpake = Cc["@mozilla.org/services-crypto/sync-jpake;1"]
                   .createInstance(Ci.nsISyncJPAKE);
 
   this._setClientID();
@@ -147,40 +148,40 @@
   receiveNoPIN: function receiveNoPIN() {
     this._my_signerid = JPAKE_SIGNERID_RECEIVER;
     this._their_signerid = JPAKE_SIGNERID_SENDER;
 
     this._secret = this._createSecret();
 
     // Allow a large number of tries first while we wait for the PIN
     // to be entered on the other device.
-    this._maxTries = Svc.Prefs.get("jpake.firstMsgMaxTries");
+    this._maxTries = this.prefs.get("jpake.firstMsgMaxTries");
     this._chain(this._getChannel,
                 this._computeStepOne,
                 this._putStep,
                 this._getStep,
                 function(callback) {
                   // We fetched the first response from the other client.
                   // Notify controller of the pairing starting.
                   Utils.nextTick(this.controller.onPairingStart,
                                  this.controller);
 
                   // Now we can switch back to the smaller timeout.
-                  this._maxTries = Svc.Prefs.get("jpake.maxTries");
+                  this._maxTries = this.prefs.get("jpake.maxTries");
                   callback();
                 },
                 this._computeStepTwo,
                 this._putStep,
                 this._getStep,
                 this._computeFinal,
                 this._computeKeyVerification,
                 this._putStep,
                 function(callback) {
                   // Allow longer time-out for the last message.
-                  this._maxTries = Svc.Prefs.get("jpake.lastMsgMaxTries");
+                  this._maxTries = this.prefs.get("jpake.lastMsgMaxTries");
                   callback();
                 },
                 this._getStep,
                 this._decryptData,
                 this._complete)();
   },
 
   /**
@@ -694,18 +695,20 @@
  *
  * Usage:
  *
  *   jpakeclient.controller = new SendCredentialsController(jpakeclient,
  *                                                          service);
  *
  */
 function SendCredentialsController(jpakeclient, service) {
+  this.prefs = service.prefs;
+
   this._log = Log4Moz.repository.getLogger("Sync.SendCredentialsController");
-  this._log.level = Log4Moz.Level[Svc.Prefs.get("log.logger.service.main")];
+  this._log.level = Log4Moz.Level[this.prefs.get("log.logger.service.main")];
 
   this._log.trace("Loading.");
   this.jpakeclient = jpakeclient;
   this.service = service;
 
   // Register ourselves as observers the first Sync finishing (either
   // successfully or unsuccessfully, we don't care) or for removing
   // this device's sync configuration, in case that happens while we
diff --git a/services/sync/modules/policies.js b/services/sync/modules/policies.js
--- a/services/sync/modules/policies.js
+++ b/services/sync/modules/policies.js
@@ -12,16 +12,17 @@
 Cu.import("resource://services-common/log4moz.js");
 Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/engines.js");
 Cu.import("resource://services-sync/status.js");
 Cu.import("resource://services-sync/util.js");
 
 function SyncScheduler(service) {
   this.service = service;
+  this.prefs = service.prefs;
   this.init();
 }
 SyncScheduler.prototype = {
   _log: Log4Moz.repository.getLogger("Sync.SyncScheduler"),
 
   _fatalLoginStatus: [LOGIN_FAILED_NO_USERNAME,
                       LOGIN_FAILED_NO_PASSWORD,
                       LOGIN_FAILED_NO_PASSPHRASE,
@@ -31,47 +32,47 @@
   /**
    * The nsITimer object that schedules the next sync. See scheduleNextSync().
    */
   syncTimer: null,
 
   setDefaults: function setDefaults() {
     this._log.trace("Setting SyncScheduler policy values to defaults.");
 
-    this.singleDeviceInterval = Svc.Prefs.get("scheduler.singleDeviceInterval") * 1000;
-    this.idleInterval         = Svc.Prefs.get("scheduler.idleInterval")         * 1000;
-    this.activeInterval       = Svc.Prefs.get("scheduler.activeInterval")       * 1000;
-    this.immediateInterval    = Svc.Prefs.get("scheduler.immediateInterval")    * 1000;
+    this.singleDeviceInterval = this.prefs.get("scheduler.singleDeviceInterval") * 1000;
+    this.idleInterval         = this.prefs.get("scheduler.idleInterval")         * 1000;
+    this.activeInterval       = this.prefs.get("scheduler.activeInterval")       * 1000;
+    this.immediateInterval    = this.prefs.get("scheduler.immediateInterval")    * 1000;
 
     // A user is non-idle on startup by default.
     this.idle = false;
 
     this.hasIncomingItems = false;
 
     this.clearSyncTriggers();
   },
 
   // nextSync is in milliseconds, but prefs can't hold that much
-  get nextSync() Svc.Prefs.get("nextSync", 0) * 1000,
-  set nextSync(value) Svc.Prefs.set("nextSync", Math.floor(value / 1000)),
+  get nextSync() this.prefs.get("nextSync", 0) * 1000,
+  set nextSync(value) this.prefs.set("nextSync", Math.floor(value / 1000)),
 
-  get syncInterval() Svc.Prefs.get("syncInterval", this.singleDeviceInterval),
-  set syncInterval(value) Svc.Prefs.set("syncInterval", value),
+  get syncInterval() this.prefs.get("syncInterval", this.singleDeviceInterval),
+  set syncInterval(value) this.prefs.set("syncInterval", value),
 
-  get syncThreshold() Svc.Prefs.get("syncThreshold", SINGLE_USER_THRESHOLD),
-  set syncThreshold(value) Svc.Prefs.set("syncThreshold", value),
+  get syncThreshold() this.prefs.get("syncThreshold", SINGLE_USER_THRESHOLD),
+  set syncThreshold(value) this.prefs.set("syncThreshold", value),
 
-  get globalScore() Svc.Prefs.get("globalScore", 0),
-  set globalScore(value) Svc.Prefs.set("globalScore", value),
+  get globalScore() this.prefs.get("globalScore", 0),
+  set globalScore(value) this.prefs.set("globalScore", value),
 
-  get numClients() Svc.Prefs.get("numClients", 0),
-  set numClients(value) Svc.Prefs.set("numClients", value),
+  get numClients() this.prefs.get("numClients", 0),
+  set numClients(value) this.prefs.set("numClients", value),
 
   init: function init() {
-    this._log.level = Log4Moz.Level[Svc.Prefs.get("log.logger.service.main")];
+    this._log.level = Log4Moz.Level[this.prefs.get("log.logger.service.main")];
     this.setDefaults();
     Svc.Obs.add("weave:engine:score:updated", this);
     Svc.Obs.add("network:offline-status-changed", this);
     Svc.Obs.add("weave:service:sync:start", this);
     Svc.Obs.add("weave:service:sync:finish", this);
     Svc.Obs.add("weave:engine:sync:finish", this);
     Svc.Obs.add("weave:engine:sync:error", this);
     Svc.Obs.add("weave:service:login:error", this);
@@ -79,17 +80,17 @@
     Svc.Obs.add("weave:service:sync:error", this);
     Svc.Obs.add("weave:service:backoff:interval", this);
     Svc.Obs.add("weave:service:ready", this);
     Svc.Obs.add("weave:engine:sync:applied", this);
     Svc.Obs.add("weave:service:setup-complete", this);
     Svc.Obs.add("weave:service:start-over", this);
 
     if (Status.checkSetup() == STATUS_OK) {
-      Svc.Idle.addIdleObserver(this, Svc.Prefs.get("scheduler.idleTime"));
+      Svc.Idle.addIdleObserver(this, this.prefs.get("scheduler.idleTime"));
     }
   },
 
   observe: function observe(subject, topic, data) {
     this._log.trace("Handling " + topic);
     switch(topic) {
       case "weave:engine:score:updated":
         if (Status.login == LOGIN_SUCCEEDED) {
@@ -176,37 +177,37 @@
         // Leave up to 25% more time for the back off.
         let interval = requested_interval * (1 + Math.random() * 0.25);
         Status.backoffInterval = interval;
         Status.minimumNextSync = Date.now() + requested_interval;
         break;
       case "weave:service:ready":
         // Applications can specify this preference if they want autoconnect
         // to happen after a fixed delay.
-        let delay = Svc.Prefs.get("autoconnectDelay");
+        let delay = this.prefs.get("autoconnectDelay");
         if (delay) {
           this.delayedAutoConnect(delay);
         }
         break;
       case "weave:engine:sync:applied":
         let numItems = subject.succeeded;
         this._log.trace("Engine " + data + " successfully applied " + numItems +
                         " items.");
         if (numItems) {
           this.hasIncomingItems = true;
         }
         break;
       case "weave:service:setup-complete":
          Services.prefs.savePrefFile(null);
-         Svc.Idle.addIdleObserver(this, Svc.Prefs.get("scheduler.idleTime"));
+         Svc.Idle.addIdleObserver(this, this.prefs.get("scheduler.idleTime"));
          break;
       case "weave:service:start-over":
          this.setDefaults();
          try {
-           Svc.Idle.removeIdleObserver(this, Svc.Prefs.get("scheduler.idleTime"));
+           Svc.Idle.removeIdleObserver(this, this.prefs.get("scheduler.idleTime"));
          } catch (ex if (ex.result == Cr.NS_ERROR_FAILURE)) {
            // In all likelihood we didn't have an idle observer registered yet.
            // It's all good.
          }
          break;
       case "idle":
         this._log.trace("We're idle.");
         this.idle = true;
@@ -464,16 +465,17 @@
   },
 };
 
 const LOG_PREFIX_SUCCESS = "success-";
 const LOG_PREFIX_ERROR   = "error-";
 
 function ErrorHandler(service) {
   this.service = service;
+  this.prefs = service.prefs;
   this.init();
 }
 ErrorHandler.prototype = {
 
   /**
    * Flag that turns on error reporting for all errors, incl. network errors.
    */
   dontIgnoreErrors: false,
@@ -485,33 +487,33 @@
     Svc.Obs.add("weave:service:sync:error", this);
     Svc.Obs.add("weave:service:sync:finish", this);
 
     this.initLogs();
   },
 
   initLogs: function initLogs() {
     this._log = Log4Moz.repository.getLogger("Sync.ErrorHandler");
-    this._log.level = Log4Moz.Level[Svc.Prefs.get("log.logger.service.main")];
+    this._log.level = Log4Moz.Level[this.prefs.get("log.logger.service.main")];
     this._cleaningUpFileLogs = false;
 
     let root = Log4Moz.repository.getLogger("Sync");
-    root.level = Log4Moz.Level[Svc.Prefs.get("log.rootLogger")];
+    root.level = Log4Moz.Level[this.prefs.get("log.rootLogger")];
 
     let formatter = new Log4Moz.BasicFormatter();
     let capp = new Log4Moz.ConsoleAppender(formatter);
-    capp.level = Log4Moz.Level[Svc.Prefs.get("log.appender.console")];
+    capp.level = Log4Moz.Level[this.prefs.get("log.appender.console")];
     root.addAppender(capp);
 
     let dapp = new Log4Moz.DumpAppender(formatter);
-    dapp.level = Log4Moz.Level[Svc.Prefs.get("log.appender.dump")];
+    dapp.level = Log4Moz.Level[this.prefs.get("log.appender.dump")];
     root.addAppender(dapp);
 
     let fapp = this._logAppender = new Log4Moz.StorageStreamAppender(formatter);
-    fapp.level = Log4Moz.Level[Svc.Prefs.get("log.appender.file.level")];
+    fapp.level = Log4Moz.Level[this.prefs.get("log.appender.file.level")];
     root.addAppender(fapp);
   },
 
   observe: function observe(subject, topic, data) {
     this._log.trace("Handling " + topic);
     switch(topic) {
       case "weave:engine:sync:applied":
         if (subject.newFailed) {
@@ -527,33 +529,33 @@
         let engine_name = data;   // engine name that threw the exception
 
         this.checkServerError(exception);
 
         Status.engines = [engine_name, exception.failureCode || ENGINE_UNKNOWN_FAIL];
         this._log.debug(engine_name + " failed: " + Utils.exceptionStr(exception));
         break;
       case "weave:service:login:error":
-        this.resetFileLog(Svc.Prefs.get("log.appender.file.logOnError"),
+        this.resetFileLog(this.prefs.get("log.appender.file.logOnError"),
                           LOG_PREFIX_ERROR);
 
         if (this.shouldReportError()) {
           this.notifyOnNextTick("weave:ui:login:error");
         } else {
           this.notifyOnNextTick("weave:ui:clear-error");
         }
 
         this.dontIgnoreErrors = false;
         break;
       case "weave:service:sync:error":
         if (Status.sync == CREDENTIALS_CHANGED) {
           this.service.logout();
         }
 
-        this.resetFileLog(Svc.Prefs.get("log.appender.file.logOnError"),
+        this.resetFileLog(this.prefs.get("log.appender.file.logOnError"),
                           LOG_PREFIX_ERROR);
 
         if (this.shouldReportError()) {
           this.notifyOnNextTick("weave:ui:sync:error");
         } else {
           this.notifyOnNextTick("weave:ui:sync:finish");
         }
 
@@ -565,31 +567,31 @@
         // Check both of these status codes: in the event of a failure in one
         // engine, Status.service will be SYNC_FAILED_PARTIAL despite
         // Status.sync being SYNC_SUCCEEDED.
         // *facepalm*
         if (Status.sync    == SYNC_SUCCEEDED &&
             Status.service == STATUS_OK) {
           // Great. Let's clear our mid-sync 401 note.
           this._log.trace("Clearing lastSyncReassigned.");
-          Svc.Prefs.reset("lastSyncReassigned");
+          this.prefs.reset("lastSyncReassigned");
         }
 
         if (Status.service == SYNC_FAILED_PARTIAL) {
           this._log.debug("Some engines did not sync correctly.");
-          this.resetFileLog(Svc.Prefs.get("log.appender.file.logOnError"),
+          this.resetFileLog(this.prefs.get("log.appender.file.logOnError"),
                             LOG_PREFIX_ERROR);
 
           if (this.shouldReportError()) {
             this.dontIgnoreErrors = false;
             this.notifyOnNextTick("weave:ui:sync:error");
             break;
           }
         } else {
-          this.resetFileLog(Svc.Prefs.get("log.appender.file.logOnSuccess"),
+          this.resetFileLog(this.prefs.get("log.appender.file.logOnSuccess"),
                             LOG_PREFIX_SUCCESS);
         }
         this.dontIgnoreErrors = false;
         this.notifyOnNextTick("weave:ui:sync:finish");
         break;
     }
   },
 
@@ -614,17 +616,17 @@
 
   /**
    * Finds all logs older than maxErrorAge and deletes them without tying up I/O.
    */
   cleanupLogs: function cleanupLogs() {
     let direntries = FileUtils.getDir("ProfD", ["weave", "logs"]).directoryEntries;
     let oldLogs = [];
     let index = 0;
-    let threshold = Date.now() - 1000 * Svc.Prefs.get("log.appender.file.maxErrorAge");
+    let threshold = Date.now() - 1000 * this.prefs.get("log.appender.file.maxErrorAge");
 
     while (direntries.hasMoreElements()) {
       let logFile = direntries.getNext().QueryInterface(Ci.nsIFile);
       if (logFile.lastModifiedTime < threshold) {
         oldLogs.push(logFile);
       }
     }
 
@@ -723,19 +725,19 @@
       this._log.trace("shouldReportError: false (master password locked).");
       return false;
     }
 
     if (this.dontIgnoreErrors) {
       return true;
     }
 
-    let lastSync = Svc.Prefs.get("lastSync");
+    let lastSync = this.prefs.get("lastSync");
     if (lastSync && ((Date.now() - Date.parse(lastSync)) >
-        Svc.Prefs.get("errorhandler.networkFailureReportTimeout") * 1000)) {
+        this.prefs.get("errorhandler.networkFailureReportTimeout") * 1000)) {
       Status.sync = PROLONGED_SYNC_FAILURE;
       this._log.trace("shouldReportError: true (prolonged sync failure).");
       return true;
     }
 
     // We got a 401 mid-sync. Wait for the next sync before actually handling
     // an error. This assumes that we'll get a 401 again on a login fetch in
     // order to report the error.
@@ -759,30 +761,30 @@
         if (resp == RESPONSE_OVER_QUOTA) {
           Status.sync = OVER_QUOTA;
         }
         break;
 
       case 401:
         this.service.logout();
         this._log.info("Got 401 response; resetting clusterURL.");
-        Svc.Prefs.reset("clusterURL");
+        this.prefs.reset("clusterURL");
 
         let delay = 0;
-        if (Svc.Prefs.get("lastSyncReassigned")) {
+        if (this.prefs.get("lastSyncReassigned")) {
           // We got a 401 in the middle of the previous sync, and we just got
           // another. Login must have succeeded in order for us to get here, so
           // the password should be correct.
           // This is likely to be an intermittent server issue, so back off and
           // give it time to recover.
           this._log.warn("Last sync also failed for 401. Delaying next sync.");
           delay = MINIMUM_BACKOFF_INTERVAL;
         } else {
           this._log.debug("New mid-sync 401 failure. Making a note.");
-          Svc.Prefs.set("lastSyncReassigned", true);
+          this.prefs.set("lastSyncReassigned", true);
         }
         this._log.info("Attempting to schedule another sync.");
         this.service.scheduler.scheduleNextSync(delay);
         break;
 
       case 500:
       case 502:
       case 503:
diff --git a/services/sync/modules/record.js b/services/sync/modules/record.js
--- a/services/sync/modules/record.js
+++ b/services/sync/modules/record.js
@@ -5,20 +5,17 @@
 const EXPORTED_SYMBOLS = [
   "WBORecord",
   "RecordManager",
   "CryptoWrapper",
   "CollectionKeyManager",
   "Collection",
 ];
 
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cr = Components.results;
-const Cu = Components.utils;
+const {interfaces: Ci, utils: Cu} = Components;
 
 const CRYPTO_COLLECTION = "crypto";
 const KEYS_WBO = "keys";
 
 Cu.import("resource://services-common/log4moz.js");
 Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/keys.js");
 Cu.import("resource://services-sync/resource.js");
diff --git a/services/sync/modules/resource.js b/services/sync/modules/resource.js
--- a/services/sync/modules/resource.js
+++ b/services/sync/modules/resource.js
@@ -2,28 +2,28 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const EXPORTED_SYMBOLS = [
   "AsyncResource",
   "Resource"
 ];
 
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cr = Components.results;
-const Cu = Components.utils;
+const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu} = Components;
 
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/observers.js");
+Cu.import("resource://services-common/preferences.js");
 Cu.import("resource://services-common/async.js");
 Cu.import("resource://services-sync/constants.js");
-Cu.import("resource://services-common/observers.js");
-Cu.import("resource://services-common/preferences.js");
-Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
 
+const prefs = new Preferences(PREFS_BRANCH);
+
 /*
  * AsyncResource represents a remote network resource, identified by a URI.
  * Create an instance like so:
  *
  *   let resource = new AsyncResource("http://foobar.com/path/to/resource");
  *
  * The 'resource' object has the following methods to issue HTTP requests
  * of the corresponding HTTP methods:
@@ -39,17 +39,17 @@
  *
  * 'error' will be null on successful requests. Likewise, result will not be
  * passed (=undefined) when an error occurs. Note that this is independent of
  * the status of the HTTP response.
  */
 function AsyncResource(uri) {
   this._log = Log4Moz.repository.getLogger(this._logName);
   this._log.level =
-    Log4Moz.Level[Svc.Prefs.get("log.logger.network.resources")];
+    Log4Moz.Level[Service.prefs.get("log.logger.network.resources", "Debug")];
   this.uri = uri;
   this._headers = {};
   this._onComplete = Utils.bind2(this, this._onComplete);
 }
 AsyncResource.prototype = {
   _logName: "Sync.AsyncResource",
 
   // ** {{{ AsyncResource.serverTime }}} **
@@ -144,18 +144,18 @@
     channel.loadFlags |= Ci.nsIRequest.INHIBIT_CACHING;
     // Don't send user cookies & such over the wire (Bug 644734)
     channel.loadFlags |= Ci.nsIRequest.LOAD_ANONYMOUS;
 
     // Setup a callback to handle channel notifications.
     channel.notificationCallbacks = new ChannelNotificationListener();
 
     // Compose a UA string fragment from the various available identifiers.
-    if (Svc.Prefs.get("sendVersionInfo", true)) {
-      let ua = this._userAgent + Svc.Prefs.get("client.type", "desktop");
+    if (Service.prefs.get("sendVersionInfo", true)) {
+      let ua = this._userAgent + Service.prefs.get("client.type", "desktop");
       channel.setRequestHeader("user-agent", ua, false);
     }
 
     let headers = this.headers;
 
     if (this.authenticator) {
       let result = this.authenticator(this, method);
       if (result && result.headers) {
diff --git a/services/sync/modules/rest.js b/services/sync/modules/rest.js
--- a/services/sync/modules/rest.js
+++ b/services/sync/modules/rest.js
@@ -11,19 +11,24 @@
 
 const EXPORTED_SYMBOLS = ["SyncStorageRequest"];
 
 const STORAGE_REQUEST_TIMEOUT = 5 * 60; // 5 minutes
 
 /**
  * RESTRequest variant for use against a Sync storage server.
  */
-function SyncStorageRequest(uri) {
+function SyncStorageRequest(uri, prefs) {
+  if (!prefs) {
+    throw new Error("Preferences instance must be provided.");
+  }
+
   RESTRequest.call(this, uri);
 
+  this.prefs = prefs;
   this.authenticator = null;
 }
 SyncStorageRequest.prototype = {
 
   __proto__: RESTRequest.prototype,
 
   _logName: "Sync.StorageRequest",
 
@@ -44,18 +49,18 @@
 
   /**
    * Wait 5 minutes before killing a request.
    */
   timeout: STORAGE_REQUEST_TIMEOUT,
 
   dispatch: function dispatch(method, data, onComplete, onProgress) {
     // Compose a UA string fragment from the various available identifiers.
-    if (Svc.Prefs.get("sendVersionInfo", true)) {
-      let ua = this.userAgent + Svc.Prefs.get("client.type", "desktop");
+    if (this.prefs.get("sendVersionInfo", true)) {
+      let ua = this.userAgent + this.prefs.get("client.type", "desktop");
       this.setHeader("user-agent", ua);
     }
 
     if (this.authenticator) {
       this.authenticator(this);
     } else {
       this._log.debug("No authenticator found.");
     }
diff --git a/services/sync/modules/service.js b/services/sync/modules/service.js
--- a/services/sync/modules/service.js
+++ b/services/sync/modules/service.js
@@ -48,17 +48,20 @@
 };
 
 const STORAGE_INFO_TYPES = [INFO_COLLECTIONS,
                             INFO_COLLECTION_USAGE,
                             INFO_COLLECTION_COUNTS,
                             INFO_QUOTA];
 
 
-function Sync11Service() {
+function Sync11Service(prefsBranch) {
+  this.prefs = new Preferences(prefsBranch);
+  this.defaultPrefs = new Preferences({branch: prefsBranch, defaultBranch: true});
+
   this._notify = Utils.notify("weave:service:");
 }
 Sync11Service.prototype = {
 
   _lock: Utils.lock,
   _locked: false,
   _loggedIn: false,
 
@@ -67,51 +70,58 @@
   storageURL: null,
   metaURL: null,
   cryptoKeyURL: null,
 
   get enabledEngineNames() {
     return [e.name for each (e in this.engineManager.getEnabled())];
   },
 
-  get serverURL() Svc.Prefs.get("serverURL"),
+  get serverURL() {
+    return this.prefs.get("serverURL");
+  },
+
   set serverURL(value) {
     // Only do work if it's actually changing
-    if (value == this.serverURL)
+    if (value == this.serverURL) {
       return;
+    }
 
-    // A new server most likely uses a different cluster, so clear that
-    Svc.Prefs.set("serverURL", value);
-    Svc.Prefs.reset("clusterURL");
+    // A new server most likely uses a different cluster, so clear that.
+    this.prefs.set("serverURL", value);
+    this.prefs.reset("clusterURL");
   },
 
-  get clusterURL() Svc.Prefs.get("clusterURL", ""),
+  get clusterURL() {
+    return this.prefs.get("clusterURL", "");
+  },
+
   set clusterURL(value) {
-    Svc.Prefs.set("clusterURL", value);
+    this.prefs.set("clusterURL", value);
     this._updateCachedURLs();
   },
 
   get miscAPI() {
     // Append to the serverURL if it's a relative fragment
-    let misc = Svc.Prefs.get("miscURL");
+    let misc = this.prefs.get("miscURL");
     if (misc.indexOf(":") == -1)
       misc = this.serverURL + misc;
     return misc + MISC_API_VERSION + "/";
   },
 
   /**
    * The URI of the User API service.
    *
    * This is the base URI of the service as applicable to all users up to
    * and including the server version path component, complete with trailing
    * forward slash.
    */
   get userAPIURI() {
     // Append to the serverURL if it's a relative fragment.
-    let url = Svc.Prefs.get("userURL");
+    let url = this.prefs.get("userURL");
     if (!url.contains(":")) {
       url = this.serverURL + url;
     }
 
     return url + USER_API_VERSION + "/";
   },
 
   get pwResetURL() {
@@ -119,21 +129,21 @@
   },
 
   get updatedURL() {
     return WEAVE_CHANNEL == "dev" ? UPDATED_DEV_URL : UPDATED_REL_URL;
   },
 
   get syncID() {
     // Generate a random syncID id we don't have one
-    let syncID = Svc.Prefs.get("client.syncID", "");
+    let syncID = this.prefs.get("client.syncID", "");
     return syncID == "" ? this.syncID = Utils.makeGUID() : syncID;
   },
   set syncID(value) {
-    Svc.Prefs.set("client.syncID", value);
+    this.prefs.set("client.syncID", value);
   },
 
   get isLoggedIn() { return this._loggedIn; },
 
   get locked() { return this._locked; },
   lock: function lock() {
     if (this._locked)
       return false;
@@ -315,17 +325,17 @@
     this.status = Status;
     this.identity = Status._authManager;
     this.collectionKeys = new CollectionKeyManager();
 
     this.errorHandler = new ErrorHandler(this);
 
     this._log = Log4Moz.repository.getLogger("Sync.Service");
     this._log.level =
-      Log4Moz.Level[Svc.Prefs.get("log.logger.service.main")];
+      Log4Moz.Level[this.prefs.get("log.logger.service.main")];
 
     this._log.info("Loading Weave " + WEAVE_VERSION);
 
     this._clusterManager = new ClusterManager(this);
     this.recordManager = new RecordManager(this);
 
     this.enabled = true;
 
@@ -337,17 +347,17 @@
 
     if (!this._checkCrypto()) {
       this.enabled = false;
       this._log.info("Could not load the Weave crypto component. Disabling " +
                       "Weave, since it will not work correctly.");
     }
 
     Svc.Obs.add("weave:service:setup-complete", this);
-    Svc.Prefs.observe("engine.", this);
+    this.prefs.observe("engine.", this);
 
     this.scheduler = new SyncScheduler(this);
 
     if (!this.enabled) {
       this._log.info("Firefox Sync disabled.");
     }
 
     this._updateCachedURLs();
@@ -370,57 +380,57 @@
     if (!this.enabled) {
       return this.status.service = STATUS_DISABLED;
     }
     return this.status.checkSetup();
   },
 
   _migratePrefs: function _migratePrefs() {
     // Migrate old debugLog prefs.
-    let logLevel = Svc.Prefs.get("log.appender.debugLog");
+    let logLevel = this.prefs.get("log.appender.debugLog");
     if (logLevel) {
-      Svc.Prefs.set("log.appender.file.level", logLevel);
-      Svc.Prefs.reset("log.appender.debugLog");
+      this.prefs.set("log.appender.file.level", logLevel);
+      this.prefs.reset("log.appender.debugLog");
     }
-    if (Svc.Prefs.get("log.appender.debugLog.enabled")) {
-      Svc.Prefs.set("log.appender.file.logOnSuccess", true);
-      Svc.Prefs.reset("log.appender.debugLog.enabled");
+    if (this.prefs.get("log.appender.debugLog.enabled")) {
+      this.prefs.set("log.appender.file.logOnSuccess", true);
+      this.prefs.reset("log.appender.debugLog.enabled");
     }
 
     // Migrate old extensions.weave.* prefs if we haven't already tried.
-    if (Svc.Prefs.get("migrated", false))
+    if (this.prefs.get("migrated", false))
       return;
 
     // Grab the list of old pref names
     let oldPrefBranch = "extensions.weave.";
     let oldPrefNames = Cc["@mozilla.org/preferences-service;1"].
                        getService(Ci.nsIPrefService).
                        getBranch(oldPrefBranch).
                        getChildList("", {});
 
     // Map each old pref to the current pref branch
     let oldPref = new Preferences(oldPrefBranch);
     for each (let pref in oldPrefNames)
-      Svc.Prefs.set(pref, oldPref.get(pref));
+      this.prefs.set(pref, oldPref.get(pref));
 
     // Remove all the old prefs and remember that we've migrated
     oldPref.resetBranch("");
-    Svc.Prefs.set("migrated", true);
+    this.prefs.set("migrated", true);
   },
 
   /**
    * Register the built-in engines for certain applications
    */
   _registerEngines: function _registerEngines() {
     this.engineManager = new EngineManager(this);
 
     let engines = [];
     // Applications can provide this preference (comma-separated list)
     // to specify which engines should be registered on startup.
-    let pref = Svc.Prefs.get("registerEngines");
+    let pref = this.prefs.get("registerEngines");
     if (pref) {
       engines = pref.split(",");
     }
 
     this.clientsEngine = new ClientEngine(this);
 
     for (let name of engines) {
       if (!name in ENGINE_MODULES) {
@@ -464,22 +474,22 @@
         let engine = data.slice((PREFS_BRANCH + "engine.").length);
         this._handleEngineStatusChanged(engine);
         break;
     }
   },
 
   _handleEngineStatusChanged: function handleEngineDisabled(engine) {
     this._log.trace("Status for " + engine + " engine changed.");
-    if (Svc.Prefs.get("engineStatusChanged." + engine, false)) {
+    if (this.prefs.get("engineStatusChanged." + engine, false)) {
       // The enabled status being changed back to what it was before.
-      Svc.Prefs.reset("engineStatusChanged." + engine);
+      this.prefs.reset("engineStatusChanged." + engine);
     } else {
       // Remember that the engine status changed locally until the next sync.
-      Svc.Prefs.set("engineStatusChanged." + engine, true);
+      this.prefs.set("engineStatusChanged." + engine, true);
     }
   },
 
   /**
    * Obtain a Resource instance with authentication credentials.
    */
   resource: function resource(url) {
     let res = new Resource(url);
@@ -487,17 +497,17 @@
 
     return res;
   },
 
   /**
    * Obtain a SyncStorageRequest instance with authentication credentials.
    */
   getStorageRequest: function getStorageRequest(url) {
-    let request = new SyncStorageRequest(url);
+    let request = new SyncStorageRequest(url, this.prefs);
     request.authenticator = this.identity.getRESTRequestAuthenticator();
 
     return request;
   },
 
   /**
    * Perform the info fetch as part of a login or key fetch.
    */
@@ -857,20 +867,20 @@
 
     // Reset all engines and clear keys.
     this.resetClient();
     this.collectionKeys.clear();
     this.status.resetBackoff();
 
     // Reset Weave prefs.
     this._ignorePrefObserver = true;
-    Svc.Prefs.resetBranch("");
+    this.prefs.resetBranch("");
     this._ignorePrefObserver = false;
 
-    Svc.Prefs.set("lastversion", WEAVE_VERSION);
+    this.prefs.set("lastversion", WEAVE_VERSION);
 
     this.identity.deleteSyncCredentials();
   },
 
   persistLogin: function persistLogin() {
     try {
       this.identity.persistCredentials(true);
     } catch (ex) {
@@ -953,18 +963,18 @@
   },
 
   createAccount: function createAccount(email, password,
                                         captchaChallenge, captchaResponse) {
     let client = new UserAPI10Client(this.userAPIURI);
 
     // Hint to server to allow scripted user creation or otherwise
     // ignore captcha.
-    if (Svc.Prefs.isSet("admin-secret")) {
-      client.adminSecret = Svc.Prefs.get("admin-secret", "");
+    if (this.prefs.isSet("admin-secret")) {
+      client.adminSecret = this.prefs.get("admin-secret", "");
     }
 
     let cb = Async.makeSpinningCallback();
 
     client.createAccount(email, password, captchaChallenge, captchaResponse,
                          cb);
 
     try {
@@ -1137,17 +1147,17 @@
       reason = kSyncWeaveDisabled;
     else if (Services.io.offline)
       reason = kSyncNetworkOffline;
     else if (this.status.minimumNextSync > Date.now())
       reason = kSyncBackoffNotMet;
     else if ((this.status.login == MASTER_PASSWORD_LOCKED) &&
              Utils.mpLocked())
       reason = kSyncMasterPasswordLocked;
-    else if (Svc.Prefs.get("firstSync") == "notReady")
+    else if (this.prefs.get("firstSync") == "notReady")
       reason = kFirstSyncChoiceNotMade;
 
     if (ignore && ignore.indexOf(reason) != -1)
       return "";
 
     return reason;
   },
 
@@ -1470,10 +1480,10 @@
         return callback(ex);
       }
       this._log.trace("Successfully retrieved '" + info_type + "'.");
       return callback(null, result);
     });
   },
 };
 
-let Service = new Sync11Service();
+let Service = new Sync11Service(PREFS_BRANCH);
 Service.onStartup();
diff --git a/services/sync/modules/stages/cluster.js b/services/sync/modules/stages/cluster.js
--- a/services/sync/modules/stages/cluster.js
+++ b/services/sync/modules/stages/cluster.js
@@ -11,17 +11,17 @@
 Cu.import("resource://services-sync/policies.js");
 Cu.import("resource://services-sync/util.js");
 
 /**
  * Contains code for managing the Sync cluster we are in.
  */
 function ClusterManager(service) {
   this._log = Log4Moz.repository.getLogger("Sync.Service");
-  this._log.level = Log4Moz.Level[Svc.Prefs.get("log.logger.service.main")];
+  this._log.level = Log4Moz.Level[service.prefs.get("log.logger.service.main")];
 
   this.service = service;
 }
 ClusterManager.prototype = {
   get identity() {
     return this.service.identity;
   },
 
@@ -82,14 +82,14 @@
 
     // Don't update stuff if we already have the right cluster
     if (cluster == this.service.clusterURL) {
       return false;
     }
 
     this._log.debug("Setting cluster to " + cluster);
     this.service.clusterURL = cluster;
-    Svc.Prefs.set("lastClusterUpdate", Date.now().toString());
+    this.service.prefs.set("lastClusterUpdate", Date.now().toString());
 
     return true;
   },
 };
 Object.freeze(ClusterManager.prototype);
diff --git a/services/sync/modules/stages/enginesync.js b/services/sync/modules/stages/enginesync.js
--- a/services/sync/modules/stages/enginesync.js
+++ b/services/sync/modules/stages/enginesync.js
@@ -18,17 +18,17 @@
 
 /**
  * Perform synchronization of engines.
  *
  * This was originally split out of service.js. The API needs lots of love.
  */
 function EngineSynchronizer(service) {
   this._log = Log4Moz.repository.getLogger("Sync.Synchronizer");
-  this._log.level = Log4Moz.Level[Svc.Prefs.get("log.logger.synchronizer")];
+  this._log.level = Log4Moz.Level[service.prefs.get("log.logger.synchronizer")];
 
   this.service = service;
 
   this.onComplete = null;
 }
 
 EngineSynchronizer.prototype = {
   sync: function sync() {
@@ -60,20 +60,20 @@
       this._log.info("No cluster URL found. Cannot sync.");
       this.onComplete(null);
       return;
     }
 
     // Ping the server with a special info request once a day.
     let infoURL = this.service.infoURL;
     let now = Math.floor(Date.now() / 1000);
-    let lastPing = Svc.Prefs.get("lastPing", 0);
+    let lastPing = this.service.prefs.get("lastPing", 0);
     if (now - lastPing > 86400) { // 60 * 60 * 24
       infoURL += "?v=" + WEAVE_VERSION;
-      Svc.Prefs.set("lastPing", now);
+      this.service.prefs.set("lastPing", now);
     }
 
     // Figure out what the last modified time is for each collection
     let info = this.service._fetchInfo(infoURL);
 
     // Convert the response to an object and read out the modified times
     for (let engine of [this.service.clientsEngine].concat(this.service.engineManager.getAll())) {
       engine.lastModified = info.obj[engine.name] || 0;
@@ -90,17 +90,17 @@
       // Clients is an engine like any other; it can fail with a 401,
       // and we can elect to abort the sync.
       this._log.warn("Client engine sync failed. Aborting.");
       this.onComplete(null);
       return;
     }
 
     // Wipe data in the desired direction if necessary
-    switch (Svc.Prefs.get("firstSync")) {
+    switch (this.service.prefs.get("firstSync")) {
       case "resetClient":
         this.service.resetClient(this.service.enabledEngineNames);
         break;
       case "wipeClient":
         this.service.wipeClient(this.service.enabledEngineNames);
         break;
       case "wipeRemote":
         this.service.wipeRemote(this.service.enabledEngineNames);
@@ -165,21 +165,21 @@
       if (meta.isNew || meta.changed) {
         this.service.resource(this.service.metaURL).put(meta);
         delete meta.isNew;
         delete meta.changed;
       }
 
       // If there were no sync engine failures
       if (this.service.status.service != SYNC_FAILED_PARTIAL) {
-        Svc.Prefs.set("lastSync", new Date().toString());
+        this.service.prefs.set("lastSync", new Date().toString());
         this.service.status.sync = SYNC_SUCCEEDED;
       }
     } finally {
-      Svc.Prefs.reset("firstSync");
+      this.service.prefs.reset("firstSync");
 
       let syncTime = ((Date.now() - startTime) / 1000).toFixed(2);
       let dateStr = new Date().toLocaleFormat(LOG_DATE_FORMAT);
       this._log.info("Sync completed at " + dateStr
                      + " after " + syncTime + " secs.");
     }
 
     this.onComplete(null);
@@ -236,39 +236,39 @@
         continue;
       }
       let engine = this.service.engineManager.get(engineName);
       if (!engine) {
         // The engine doesn't exist locally. Nothing to do.
         continue;
       }
 
-      if (Svc.Prefs.get("engineStatusChanged." + engine.prefName, false)) {
+      if (this.service.prefs.get("engineStatusChanged." + engine.prefName, false)) {
         // The engine was disabled locally. Wipe server data and
         // disable it everywhere.
         this._log.trace("Wiping data for " + engineName + " engine.");
         engine.wipeServer();
         delete meta.payload.engines[engineName];
         meta.changed = true;
       } else {
         // The engine was enabled remotely. Enable it locally.
         this._log.trace(engineName + " engine was enabled remotely.");
         engine.enabled = true;
       }
     }
 
     // Any remaining engines were either enabled locally or disabled remotely.
     for each (let engineName in enabled) {
       let engine = this.service.engineManager.get(engineName);
-      if (Svc.Prefs.get("engineStatusChanged." + engine.prefName, false)) {
+      if (this.service.prefs.get("engineStatusChanged." + engine.prefName, false)) {
         this._log.trace("The " + engineName + " engine was enabled locally.");
       } else {
         this._log.trace("The " + engineName + " engine was disabled remotely.");
         engine.enabled = false;
       }
     }
 
-    Svc.Prefs.resetBranch("engineStatusChanged.");
+    this.service.prefs.resetBranch("engineStatusChanged.");
     this.service._ignorePrefObserver = false;
   },
 
 };
 Object.freeze(EngineSynchronizer.prototype);
diff --git a/services/sync/modules/status.js b/services/sync/modules/status.js
--- a/services/sync/modules/status.js
+++ b/services/sync/modules/status.js
@@ -4,25 +4,29 @@
 
 const EXPORTED_SYMBOLS = ["Status"];
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cr = Components.results;
 const Cu = Components.utils;
 
+Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-common/preferences.js");
 Cu.import("resource://services-sync/constants.js");
-Cu.import("resource://services-common/log4moz.js");
 Cu.import("resource://services-sync/identity.js");
 Cu.import("resource://gre/modules/Services.jsm");
 
+let prefs = new Preferences(PREFS_BRANCH);
+
 let Status = {
   _log: Log4Moz.repository.getLogger("Sync.Status"),
-  _authManager: new IdentityManager(),
+  _authManager: new IdentityManager(prefs),
   ready: false,
+  prefs: prefs,
 
   get service() {
     return this._service;
   },
 
   set service(code) {
     this._log.debug("Status.service: " + this._service + " => " + code);
     this._service = code;
diff --git a/services/sync/modules/util.js b/services/sync/modules/util.js
--- a/services/sync/modules/util.js
+++ b/services/sync/modules/util.js
@@ -531,18 +531,16 @@
   converter.charset = "UTF-8";
   return converter;
 });
 
 /*
  * Commonly-used services
  */
 let Svc = {};
-Svc.Prefs = new Preferences(PREFS_BRANCH);
-Svc.DefaultPrefs = new Preferences({branch: PREFS_BRANCH, defaultBranch: true});
 Svc.Obs = Observers;
 
 let _sessionCID = Services.appinfo.ID == SEAMONKEY_ID ?
   "@mozilla.org/suite/sessionstore;1" :
   "@mozilla.org/browser/sessionstore;1";
 
 [["Form", "@mozilla.org/satchel/form-history;1", "nsIFormHistory2"],
  ["Idle", "@mozilla.org/widget/idleservice;1", "nsIIdleService"],
diff --git a/services/sync/tests/unit/test_addon_utils.js b/services/sync/tests/unit/test_addon_utils.js
--- a/services/sync/tests/unit/test_addon_utils.js
+++ b/services/sync/tests/unit/test_addon_utils.js
@@ -120,17 +120,17 @@
 });
 
 add_test(function test_source_uri_rewrite() {
   _("Ensure that a 'src=api' query string is rewritten to 'src=sync'");
 
   // This tests for conformance with bug 708134 so server-side metrics aren't
   // skewed.
 
-  Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
+  prefs.set("addons.ignoreRepositoryChecking", true);
 
   // We resort to monkeypatching because of the API design.
   let oldFunction = AddonUtils.__proto__.installAddonFromSearchResult;
 
   let installCalled = false;
   AddonUtils.__proto__.installAddonFromSearchResult =
     function testInstallAddon(addon, metadata, cb) {
 
@@ -152,11 +152,11 @@
 
   let installCallback = Async.makeSpinningCallback();
   AddonUtils.installAddons([{id: "rewrite@tests.mozilla.org"}], installCallback);
 
   installCallback.wait();
   do_check_true(installCalled);
   AddonUtils.__proto__.installAddonFromSearchResult = oldFunction;
 
-  Svc.Prefs.reset("addons.ignoreRepositoryChecking");
+  prefs.reset("addons.ignoreRepositoryChecking");
   server.stop(run_next_test);
 });
diff --git a/services/sync/tests/unit/test_addons_engine.js b/services/sync/tests/unit/test_addons_engine.js
--- a/services/sync/tests/unit/test_addons_engine.js
+++ b/services/sync/tests/unit/test_addons_engine.js
@@ -30,17 +30,17 @@
 function advance_test() {
   reconciler._addons = {};
   reconciler._changes = [];
 
   let cb = Async.makeSpinningCallback();
   reconciler.saveState(null, cb);
   cb.wait();
 
-  Svc.Prefs.reset("addons.ignoreRepositoryChecking");
+  engine.prefs.reset("addons.ignoreRepositoryChecking");
 
   run_next_test();
 }
 
 // This is a basic sanity test for the unit test itself. If this breaks, the
 // add-ons API likely changed upstream.
 add_test(function test_addon_install() {
   _("Ensure basic add-on APIs work as expected.");
@@ -99,17 +99,17 @@
   do_check_eq("object", typeof(changes));
   do_check_eq(1, Object.keys(changes).length);
   do_check_true(guid1 in changes);
   do_check_eq(changeTime, changes[guid1]);
 
   tracker.clearChangedIDs();
 
   _("Ensure reconciler changes are populated.");
-  Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
+  engine.prefs.set("addons.ignoreRepositoryChecking", true);
   let addon = installAddon("test_bootstrap1_1");
   tracker.clearChangedIDs(); // Just in case.
   changes = engine.getChangedIDs();
   do_check_eq("object", typeof(changes));
   do_check_eq(1, Object.keys(changes).length);
   do_check_true(addon.syncGUID in changes);
   do_check_true(changes[addon.syncGUID] > changeTime);
 
@@ -146,17 +146,17 @@
 
 add_test(function test_disabled_install_semantics() {
   _("Ensure that syncing a disabled add-on preserves proper state.");
 
   // This is essentially a test for bug 712542, which snuck into the original
   // add-on sync drop. It ensures that when an add-on is installed that the
   // disabled state and incoming syncGUID is preserved, even on the next sync.
 
-  Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
+  engine.prefs.set("addons.ignoreRepositoryChecking", true);
 
   const USER       = "foo";
   const PASSWORD   = "password";
   const PASSPHRASE = "abcdeabcdeabcdeabcdeabcdea";
   const ADDON_ID   = "addon1@tests.mozilla.org";
 
   new SyncTestingInfrastructure(USER, PASSWORD, PASSPHRASE);
 
diff --git a/services/sync/tests/unit/test_addons_reconciler.js b/services/sync/tests/unit/test_addons_reconciler.js
--- a/services/sync/tests/unit/test_addons_reconciler.js
+++ b/services/sync/tests/unit/test_addons_reconciler.js
@@ -13,57 +13,57 @@
 startupManager();
 
 function run_test() {
   initTestLogging("Trace");
   Log4Moz.repository.getLogger("Sync.AddonsReconciler").level = Log4Moz.Level.Trace;
   Log4Moz.repository.getLogger("Sync.AddonsReconciler").level =
     Log4Moz.Level.Trace;
 
-  Svc.Prefs.set("engine.addons", true);
+  Service.prefs.set("engine.addons", true);
   Service.engineManager.register(AddonsEngine);
 
   run_next_test();
 }
 
 add_test(function test_defaults() {
   _("Ensure new objects have reasonable defaults.");
 
-  let reconciler = new AddonsReconciler();
+  let reconciler = new AddonsReconciler(Service.prefs);
 
   do_check_false(reconciler._listening);
   do_check_eq("object", typeof(reconciler.addons));
   do_check_eq(0, Object.keys(reconciler.addons).length);
   do_check_eq(0, reconciler._changes.length);
   do_check_eq(0, reconciler._listeners.length);
 
   run_next_test();
 });
 
 add_test(function test_load_state_empty_file() {
   _("Ensure loading from a missing file results in defaults being set.");
 
-  let reconciler = new AddonsReconciler();
+  let reconciler = new AddonsReconciler(Service.prefs);
 
   reconciler.loadState(null, function(error, loaded) {
     do_check_eq(null, error);
     do_check_false(loaded);
 
     do_check_eq("object", typeof(reconciler.addons));
     do_check_eq(0, Object.keys(reconciler.addons).length);
     do_check_eq(0, reconciler._changes.length);
 
     run_next_test();
   });
 });
 
 add_test(function test_install_detection() {
   _("Ensure that add-on installation results in appropriate side-effects.");
 
-  let reconciler = new AddonsReconciler();
+  let reconciler = new AddonsReconciler(Service.prefs);
   reconciler.startListening();
 
   let before = new Date();
   let addon = installAddon("test_bootstrap1_1");
   let after = new Date();
 
   do_check_eq(1, Object.keys(reconciler.addons).length);
   do_check_true(addon.id in reconciler.addons);
@@ -93,17 +93,17 @@
   uninstallAddon(addon);
 
   run_next_test();
 });
 
 add_test(function test_uninstall_detection() {
   _("Ensure that add-on uninstallation results in appropriate side-effects.");
 
-  let reconciler = new AddonsReconciler();
+  let reconciler = new AddonsReconciler(Service.prefs);
   reconciler.startListening();
 
   reconciler._addons = {};
   reconciler._changes = [];
 
   let addon = installAddon("test_bootstrap1_1");
   let id = addon.id;
   let guid = addon.syncGUID;
@@ -125,17 +125,17 @@
   run_next_test();
 });
 
 add_test(function test_load_state_future_version() {
   _("Ensure loading a file from a future version results in no data loaded.");
 
   const FILENAME = "TEST_LOAD_STATE_FUTURE_VERSION";
 
-  let reconciler = new AddonsReconciler();
+  let reconciler = new AddonsReconciler(Service.prefs);
 
   // First we populate our new file.
   let state = {version: 100, addons: {foo: {}}, changes: [[1, 1, "foo"]]};
   let cb = Async.makeSyncCallback();
 
   // jsonSave() expects an object with ._log, so we give it a reconciler
   // instance.
   Utils.jsonSave(FILENAME, reconciler, state, cb);
@@ -151,17 +151,17 @@
 
     run_next_test();
   });
 });
 
 add_test(function test_prune_changes_before_date() {
   _("Ensure that old changes are pruned properly.");
 
-  let reconciler = new AddonsReconciler();
+  let reconciler = new AddonsReconciler(Service.prefs);
   reconciler._ensureStateLoaded();
   reconciler._changes = [];
 
   let now = new Date();
   const HOUR_MS = 1000 * 60 * 60;
 
   _("Ensure pruning an empty changes array works.");
   reconciler.pruneChangesBeforeDate(now);
diff --git a/services/sync/tests/unit/test_addons_store.js b/services/sync/tests/unit/test_addons_store.js
--- a/services/sync/tests/unit/test_addons_store.js
+++ b/services/sync/tests/unit/test_addons_store.js
@@ -8,17 +8,16 @@
 Cu.import("resource://services-sync/engines/addons.js");
 Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
 
 const HTTP_PORT = 8888;
 
 let prefs = new Preferences();
 
-Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
 prefs.set("extensions.getAddons.get.url", "http://localhost:8888/search/guid:%IDS%");
 loadAddonTestFunctions();
 startupManager();
 
 Service.engineManager.register(AddonsEngine);
 let engine     = Service.engineManager.get("addons");
 let tracker    = engine._tracker;
 let store      = engine._store;
@@ -69,16 +68,18 @@
 function run_test() {
   initTestLogging("Trace");
   Log4Moz.repository.getLogger("Sync.Engine.Addons").level = Log4Moz.Level.Trace;
   Log4Moz.repository.getLogger("Sync.AddonsRepository").level =
     Log4Moz.Level.Trace;
 
   reconciler.startListening();
 
+  engine.prefs.set("addons.ignoreRepositoryChecking", true);
+
   run_next_test();
 }
 
 add_test(function test_get_all_ids() {
   _("Ensures that getAllIDs() returns an appropriate set.");
 
   engine._refreshReconcilerState();
 
@@ -217,25 +218,25 @@
   failed = store.applyIncomingBatch(records);
   do_check_eq(0, failed.length);
   addon = getAddonFromAddonManagerByID(addon.id);
   do_check_false(addon.userDisabled);
   records = [];
 
   _("Ensure enabled state updates don't apply if the ignore pref is set.");
   records.push(createRecordForThisApp(addon.syncGUID, addon.id, false, false));
-  Svc.Prefs.set("addons.ignoreUserEnabledChanges", true);
+  prefs.set("addons.ignoreUserEnabledChanges", true);
   failed = store.applyIncomingBatch(records);
   do_check_eq(0, failed.length);
   addon = getAddonFromAddonManagerByID(addon.id);
   do_check_false(addon.userDisabled);
   records = [];
 
   uninstallAddon(addon);
-  Svc.Prefs.reset("addons.ignoreUserEnabledChanges");
+  prefs.reset("addons.ignoreUserEnabledChanges");
   run_next_test();
 });
 
 add_test(function test_ignore_different_appid() {
   _("Ensure that incoming records with a different application ID are ignored.");
 
   // We test by creating a record that should result in an update.
   let addon = installAddon("test_bootstrap1_1");
@@ -288,18 +289,18 @@
   do_check_eq(null, addon);
 
   run_next_test();
 });
 
 add_test(function test_addon_syncability() {
   _("Ensure isAddonSyncable functions properly.");
 
-  Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
-  Svc.Prefs.set("addons.trustedSourceHostnames",
+  prefs.set("addons.ignoreRepositoryChecking", true);
+  prefs.set("addons.trustedSourceHostnames",
                 "addons.mozilla.org,other.example.com");
 
   do_check_false(store.isAddonSyncable(null));
 
   let addon = installAddon("test_bootstrap1_1");
   do_check_true(store.isAddonSyncable(addon));
 
   let dummy = {};
@@ -346,33 +347,33 @@
   for each (let uri in trusted) {
     do_check_true(store.isSourceURITrusted(createURI(uri)));
   }
 
   for each (let uri in untrusted) {
     do_check_false(store.isSourceURITrusted(createURI(uri)));
   }
 
-  Svc.Prefs.set("addons.trustedSourceHostnames", "");
+  prefs.set("addons.trustedSourceHostnames", "");
   for each (let uri in trusted) {
     do_check_false(store.isSourceURITrusted(createURI(uri)));
   }
 
-  Svc.Prefs.set("addons.trustedSourceHostnames", "addons.mozilla.org");
+  prefs.set("addons.trustedSourceHostnames", "addons.mozilla.org");
   do_check_true(store.isSourceURITrusted(createURI("https://addons.mozilla.org/foo")));
 
-  Svc.Prefs.reset("addons.trustedSourceHostnames");
+  prefs.reset("addons.trustedSourceHostnames");
 
   run_next_test();
 });
 
 add_test(function test_ignore_hotfixes() {
   _("Ensure that hotfix extensions are ignored.");
 
-  Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
+  prefs.set("addons.ignoreRepositoryChecking", true);
 
   // A hotfix extension is one that has the id the same as the
   // extensions.hotfix.id pref.
   let prefs = new Preferences("extensions.");
 
   let addon = installAddon("test_bootstrap1_1");
   do_check_true(store.isAddonSyncable(addon));
 
@@ -395,34 +396,34 @@
   // Need to delete pref before changing type.
   prefSvc.deleteBranch("hotfix.id");
   prefSvc.setIntPref("hotfix.id", 0xdeadbeef);
 
   do_check_true(store.isAddonSyncable(dummy));
 
   uninstallAddon(addon);
 
-  Svc.Prefs.reset("addons.ignoreRepositoryChecking");
+  prefs.reset("addons.ignoreRepositoryChecking");
   prefs.reset("hotfix.id");
 
   run_next_test();
 });
 
 add_test(function test_wipe() {
   _("Ensures that wiping causes add-ons to be uninstalled.");
 
   let addon1 = installAddon("test_bootstrap1_1");
 
-  Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
+  prefs.set("addons.ignoreRepositoryChecking", true);
   store.wipe();
 
   let addon = getAddonFromAddonManagerByID(addon1.id);
   do_check_eq(null, addon);
 
-  Svc.Prefs.reset("addons.ignoreRepositoryChecking");
+  prefs.reset("addons.ignoreRepositoryChecking");
 
   run_next_test();
 });
 
 add_test(function test_wipe_and_install() {
   _("Ensure wipe followed by install works.");
 
   // This tests the reset sync flow where remote data is replaced by local. The
diff --git a/services/sync/tests/unit/test_addons_tracker.js b/services/sync/tests/unit/test_addons_tracker.js
--- a/services/sync/tests/unit/test_addons_tracker.js
+++ b/services/sync/tests/unit/test_addons_tracker.js
@@ -6,18 +6,18 @@
 Cu.import("resource://gre/modules/AddonManager.jsm");
 Cu.import("resource://services-sync/engines/addons.js");
 Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
 
 loadAddonTestFunctions();
 startupManager();
-Svc.Prefs.set("addons.ignoreRepositoryChecking", true);
-Svc.Prefs.set("engine.addons", true);
+Service.prefs.set("addons.ignoreRepositoryChecking", true);
+Service.prefs.set("engine.addons", true);
 
 Service.engineManager.register(AddonsEngine);
 let engine     = Service.engineManager.get("addons");
 let reconciler = engine._reconciler;
 let store      = engine._store;
 let tracker    = engine._tracker;
 
 const addon1ID = "addon1@tests.mozilla.org";
diff --git a/services/sync/tests/unit/test_bookmark_engine.js b/services/sync/tests/unit/test_bookmark_engine.js
--- a/services/sync/tests/unit/test_bookmark_engine.js
+++ b/services/sync/tests/unit/test_bookmark_engine.js
@@ -151,17 +151,17 @@
     do_check_eq(new_children[0], folder1_payload.children[0]);
     do_check_eq(new_children[1], folder1_payload.children[1]);
 
     do_check_eq(PlacesUtils.bookmarks.getItemIndex(bmk1_id), 1);
     do_check_eq(PlacesUtils.bookmarks.getItemIndex(bmk2_id), 0);
 
   } finally {
     store.wipe();
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_restorePromptsReupload() {
   _("Ensure that restoring from a backup will reupload all records.");
   new SyncTestingInfrastructure();
@@ -282,17 +282,17 @@
     do_check_eq(bookmarkWBOs[0].title, "Get Firefox!");
 
     _("Our old friend Folder 1 is still in play.");
     do_check_eq(folderWBOs.length, 1);
     do_check_eq(folderWBOs[0].title, "Folder 1");
 
   } finally {
     store.wipe();
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 // Bug 632287.
 add_test(function test_mismatched_types() {
   _("Ensure that handling a record that changes type causes deletion " +
@@ -358,17 +358,17 @@
 
     _("Applied new. It's a livemark.");
     do_check_eq(bms.getItemType(newID), bms.TYPE_FOLDER);
     do_check_true(PlacesUtils.annotations
                              .itemHasAnnotation(newID, PlacesUtils.LMANNO_FEEDURI));
 
   } finally {
     store.wipe();
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_bookmark_guidMap_fail() {
   _("Ensure that failures building the GUID map cause early death.");
 
diff --git a/services/sync/tests/unit/test_bookmark_smart_bookmarks.js b/services/sync/tests/unit/test_bookmark_smart_bookmarks.js
--- a/services/sync/tests/unit/test_bookmark_smart_bookmarks.js
+++ b/services/sync/tests/unit/test_bookmark_smart_bookmarks.js
@@ -163,17 +163,17 @@
     store.update(newRecord);
     do_check_eq("LeastVisited", PlacesUtils.annotations.getItemAnnotation(
       newID, SMART_BOOKMARKS_ANNO));
 
 
   } finally {
     // Clean up.
     store.wipe();
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_smart_bookmarks_duped() {
   new SyncTestingInfrastructure();
 
@@ -217,17 +217,17 @@
     do_check_eq(mostVisitedGUID, engine._mapDupe(record));
 
     engine._syncFinish();
 
   } finally {
     // Clean up.
     store.wipe();
     server.stop(do_test_finished);
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
   }
 });
 
 function run_test() {
   initTestLogging("Trace");
   Log4Moz.repository.getLogger("Sync.Engine.Bookmarks").level = Log4Moz.Level.Trace;
 
diff --git a/services/sync/tests/unit/test_clients_engine.js b/services/sync/tests/unit/test_clients_engine.js
--- a/services/sync/tests/unit/test_clients_engine.js
+++ b/services/sync/tests/unit/test_clients_engine.js
@@ -140,33 +140,33 @@
     engine._sync();
     do_check_eq(deletedItems.length, 1);
     check_client_deleted(oldLocalID);
     check_clients_count(1);
     let newKey = Service.collectionKeys.keyForCollection();
     do_check_false(oldKey.equals(newKey));
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_properties() {
   _("Test lastRecordUpload property");
   try {
-    do_check_eq(Svc.Prefs.get("clients.lastRecordUpload"), undefined);
+    do_check_eq(Service.prefs.get("clients.lastRecordUpload"), undefined);
     do_check_eq(engine.lastRecordUpload, 0);
 
     let now = Date.now();
     engine.lastRecordUpload = now / 1000;
     do_check_eq(engine.lastRecordUpload, Math.floor(now / 1000));
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   }
 });
 
 add_test(function test_sync() {
   _("Ensure that Clients engine uploads a new client record once a week.");
 
   new SyncTestingInfrastructure();
@@ -209,17 +209,17 @@
     _("Time travel one day back, no record uploaded.");
     engine.lastRecordUpload -= LESS_THAN_CLIENTS_TTL_REFRESH;
     let yesterday = engine.lastRecordUpload;
     engine._sync();
     do_check_eq(clientWBO().payload, undefined);
     do_check_eq(engine.lastRecordUpload, yesterday);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_client_name_change() {
   _("Ensure client name change incurs a client record update.");
 
@@ -233,17 +233,17 @@
 
   // Tracker already has data, so clear it.
   tracker.clearChangedIDs();
 
   let initialScore = tracker.score;
 
   do_check_eq(Object.keys(tracker.changedIDs).length, 0);
 
-  Svc.Prefs.set("client.name", "new name");
+  Service.prefs.set("client.name", "new name");
 
   _("new name: " + engine.localName);
   do_check_neq(initialName, engine.localName);
   do_check_eq(Object.keys(tracker.changedIDs).length, 1);
   do_check_true(engine.localID in tracker.changedIDs);
   do_check_true(tracker.score > initialScore);
   do_check_true(tracker.score >= SCORE_INCREMENT_XLARGE);
 
@@ -440,30 +440,30 @@
     _("Syncing.");
     engine._sync();
     _("Checking record was uploaded.");
     do_check_neq(clientWBO(engine.localID).payload, undefined);
     do_check_true(engine.lastRecordUpload > 0);
 
     do_check_neq(clientWBO(remoteId).payload, undefined);
 
-    Svc.Prefs.set("client.GUID", remoteId);
+    Service.prefs.set("client.GUID", remoteId);
     engine._resetClient();
     do_check_eq(engine.localID, remoteId);
     _("Performing sync on resetted client.");
     engine._sync();
     do_check_neq(engine.localCommands, undefined);
     do_check_eq(engine.localCommands.length, 1);
 
     let command = engine.localCommands[0];
     do_check_eq(command.command, "wipeAll");
     do_check_eq(command.args.length, 0);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_send_uri_to_client_for_display() {
   _("Ensure sendURIToClientForDisplay() sends command properly.");
 
diff --git a/services/sync/tests/unit/test_clients_escape.js b/services/sync/tests/unit/test_clients_escape.js
--- a/services/sync/tests/unit/test_clients_escape.js
+++ b/services/sync/tests/unit/test_clients_escape.js
@@ -52,11 +52,11 @@
     do_check_eq(record.id, "ascii");
     do_check_eq(record.name, "wéävê");
 
     _("Sanity check that creating the record also gives the same");
     record = engine._createRecord("ascii");
     do_check_eq(record.id, "ascii");
     do_check_eq(record.name, "wéävê");
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   }
 }
diff --git a/services/sync/tests/unit/test_collections_recovery.js b/services/sync/tests/unit/test_collections_recovery.js
--- a/services/sync/tests/unit/test_collections_recovery.js
+++ b/services/sync/tests/unit/test_collections_recovery.js
@@ -65,17 +65,17 @@
     do_check_eq(fresh, 1);
     fresh = 0;
 
     _("Regular sync: no need to freshStart.");
     Service.sync();
     do_check_eq(fresh, 0);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
 
 function run_test() {
   initTestLogging("Trace");
   run_next_test();
 }
diff --git a/services/sync/tests/unit/test_corrupt_keys.js b/services/sync/tests/unit/test_corrupt_keys.js
--- a/services/sync/tests/unit/test_corrupt_keys.js
+++ b/services/sync/tests/unit/test_corrupt_keys.js
@@ -30,17 +30,17 @@
   johndoe.createContents({
     meta: {},
     crypto: {},
     clients: {}
   });
   server.start();
 
   try {
-    Svc.Prefs.set("registerEngines", "Tab");
+    Service.prefs.set("registerEngines", "Tab");
     _("Set up some tabs.");
     let myTabs =
       {windows: [{tabs: [{index: 1,
                           entries: [{
                             url: "http://foo.com/",
                             title: "Title"
                           }],
                           attributes: {
@@ -190,17 +190,17 @@
     do_check_eq(hmacErrorCount, 6);
     do_check_false(store.urlExists("http://foo/bar?record-no--5"));
     do_check_false(store.urlExists("http://foo/bar?record-no--6"));
     do_check_false(store.urlExists("http://foo/bar?record-no--7"));
     do_check_false(store.urlExists("http://foo/bar?record-no--8"));
     do_check_false(store.urlExists("http://foo/bar?record-no--9"));
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
 
 function run_test() {
   let logger = Log4Moz.repository.rootLogger;
   Log4Moz.repository.rootLogger.addAppender(new Log4Moz.DumpAppender());
 
diff --git a/services/sync/tests/unit/test_engine.js b/services/sync/tests/unit/test_engine.js
--- a/services/sync/tests/unit/test_engine.js
+++ b/services/sync/tests/unit/test_engine.js
@@ -2,29 +2,29 @@
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-common/observers.js");
 Cu.import("resource://services-sync/engines.js");
 Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
 
 
-function SteamStore(engine) {
+function SteamStore(name, engine) {
   Store.call(this, "Steam", engine);
   this.wasWiped = false;
 }
 SteamStore.prototype = {
   __proto__: Store.prototype,
 
   wipe: function() {
     this.wasWiped = true;
   }
 };
 
-function SteamTracker(engine) {
+function SteamTracker(name, engine) {
   Tracker.call(this, "Steam", engine);
 }
 SteamTracker.prototype = {
   __proto__: Tracker.prototype
 };
 
 function SteamEngine() {
   Engine.call(this, "Steam", Service);
@@ -127,23 +127,23 @@
   engineObserver.reset();
 }
 
 function test_enabled() {
   _("Engine.enabled corresponds to preference");
   let engine = new SteamEngine(Service);
   try {
     do_check_false(engine.enabled);
-    Svc.Prefs.set("engine.steam", true);
+    Service.prefs.set("engine.steam", true);
     do_check_true(engine.enabled);
 
     engine.enabled = false;
-    do_check_false(Svc.Prefs.get("engine.steam"));
+    do_check_false(Service.prefs.get("engine.steam"));
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   }
 }
 
 function test_sync() {
   let engine = new SteamEngine(Service);
   try {
     _("Engine.sync doesn't call _sync if it's not enabled");
     do_check_false(engine.enabled);
@@ -153,17 +153,17 @@
 
     _("Engine.sync calls _sync if it's enabled");
     engine.enabled = true;
     engine.sync();
     do_check_true(engine.wasSynced);
     do_check_eq(engineObserver.topics[0], "weave:engine:sync:start");
     do_check_eq(engineObserver.topics[1], "weave:engine:sync:finish");
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     engine.wasSynced = false;
     engineObserver.reset();
   }
 }
 
 function run_test() {
   test_members();
   test_score();
diff --git a/services/sync/tests/unit/test_engine_abort.js b/services/sync/tests/unit/test_engine_abort.js
--- a/services/sync/tests/unit/test_engine_abort.js
+++ b/services/sync/tests/unit/test_engine_abort.js
@@ -56,15 +56,15 @@
     engine.sync();
   } catch (ex) {
     err = ex;
   }
 
   do_check_eq(err, undefined);
 
   server.stop(run_next_test);
-  Svc.Prefs.resetBranch("");
+  Service.prefs.resetBranch("");
   Service.recordManager.clearCache();
 });
 
 function run_test() {
   run_next_test();
 }
diff --git a/services/sync/tests/unit/test_errorhandler.js b/services/sync/tests/unit/test_errorhandler.js
--- a/services/sync/tests/unit/test_errorhandler.js
+++ b/services/sync/tests/unit/test_errorhandler.js
@@ -12,25 +12,25 @@
 Cu.import("resource://testing-common/services/sync/utils.js");
 
 const TEST_MAINTENANCE_URL = "http://localhost:8080/maintenance/";
 const logsdir = FileUtils.getDir("ProfD", ["weave", "logs"], true);
 const LOG_PREFIX_SUCCESS = "success-";
 const LOG_PREFIX_ERROR   = "error-";
 
 const PROLONGED_ERROR_DURATION =
-  (Svc.Prefs.get('errorhandler.networkFailureReportTimeout') * 2) * 1000;
+  (Service.prefs.get('errorhandler.networkFailureReportTimeout') * 2) * 1000;
 
 const NON_PROLONGED_ERROR_DURATION =
-  (Svc.Prefs.get('errorhandler.networkFailureReportTimeout') / 2) * 1000;
+  (Service.prefs.get('errorhandler.networkFailureReportTimeout') / 2) * 1000;
 
 Service.engineManager.clear();
 
 function setLastSync(lastSyncValue) {
-  Svc.Prefs.set("lastSync", (new Date(Date.now() - lastSyncValue)).toString());
+  Service.prefs.set("lastSync", (new Date(Date.now() - lastSyncValue)).toString());
 }
 
 function CatapultEngine() {
   SyncEngine.call(this, "Catapult", Service);
 }
 CatapultEngine.prototype = {
   __proto__: SyncEngine.prototype,
   exception: null, // tests fill this in
@@ -1117,26 +1117,26 @@
   });
 
   Svc.Obs.add("weave:ui:sync:error", function onUIUpdate() {
     Svc.Obs.remove("weave:ui:sync:error", onUIUpdate);
     do_check_true(Status.enforceBackoff);
     do_check_eq(backoffInterval, 42);
     do_check_eq(Status.service, SYNC_FAILED);
     do_check_eq(Status.sync, PROLONGED_SYNC_FAILURE);
-    do_check_eq(Svc.Prefs.get("firstSync"), "wipeRemote");
+    do_check_eq(Service.prefs.get("firstSync"), "wipeRemote");
 
     clean();
     server.stop(run_next_test);
   });
 
   do_check_false(Status.enforceBackoff);
   do_check_eq(Status.service, STATUS_OK);
 
-  Svc.Prefs.set("firstSync", "wipeRemote");
+  Service.prefs.set("firstSync", "wipeRemote");
   setLastSync(PROLONGED_ERROR_DURATION);
   Service.sync();
 });
 
 add_test(function test_sync_syncAndReportErrors_server_maintenance_error() {
   // Test server maintenance errors are reported
   // when calling syncAndReportErrors.
   let server = sync_httpd_setup();
@@ -1356,26 +1356,26 @@
   });
 
   Svc.Obs.add("weave:ui:sync:error", function onUIUpdate() {
     Svc.Obs.remove("weave:ui:sync:error", onUIUpdate);
     do_check_true(Status.enforceBackoff);
     do_check_eq(backoffInterval, 42);
     do_check_eq(Status.service, SYNC_FAILED);
     do_check_eq(Status.sync, SERVER_MAINTENANCE);
-    do_check_eq(Svc.Prefs.get("firstSync"), "wipeRemote");
+    do_check_eq(Service.prefs.get("firstSync"), "wipeRemote");
 
     clean();
     server.stop(run_next_test);
   });
 
   do_check_false(Status.enforceBackoff);
   do_check_eq(Status.service, STATUS_OK);
 
-  Svc.Prefs.set("firstSync", "wipeRemote");
+  Service.prefs.set("firstSync", "wipeRemote");
   setLastSync(NON_PROLONGED_ERROR_DURATION);
   errorHandler.syncAndReportErrors();
 });
 
 add_test(function test_sync_syncAndReportErrors_prolonged_server_maintenance_error() {
   // Test prolonged server maintenance errors are
   // reported when calling syncAndReportErrors.
   let server = sync_httpd_setup();
@@ -1579,17 +1579,17 @@
 
   let engine = engineManager.get("catapult");
   engine.enabled = true;
   engine.sync = function sync() {
     Svc.Obs.notify("weave:engine:sync:error", "", "catapult");
   };
 
   let log = Log4Moz.repository.getLogger("Sync.ErrorHandler");
-  Svc.Prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.logOnError", true);
 
   do_check_eq(Status.engines["catapult"], undefined);
 
   // Don't wait for reset-file-log until the sync is underway.
   // This avoids us catching a delayed notification from an earlier test.
   Svc.Obs.add("weave:engine:sync:finish", function onEngineFinish() {
     Svc.Obs.remove("weave:engine:sync:finish", onEngineFinish);
 
@@ -1619,17 +1619,17 @@
   Service.sync();
 });
 
 add_test(function test_logs_on_sync_error_despite_shouldReportError() {
   _("Ensure that an error is still logged when weave:service:sync:error " +
     "is notified, despite shouldReportError returning false.");
 
   let log = Log4Moz.repository.getLogger("Sync.ErrorHandler");
-  Svc.Prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.logOnError", true);
   log.info("TESTING");
 
   // Ensure that we report no error.
   Status.login = MASTER_PASSWORD_LOCKED;
   do_check_false(errorHandler.shouldReportError());
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
@@ -1647,17 +1647,17 @@
   Svc.Obs.notify("weave:service:sync:error", {});
 });
 
 add_test(function test_logs_on_login_error_despite_shouldReportError() {
   _("Ensure that an error is still logged when weave:service:login:error " +
     "is notified, despite shouldReportError returning false.");
 
   let log = Log4Moz.repository.getLogger("Sync.ErrorHandler");
-  Svc.Prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.logOnError", true);
   log.info("TESTING");
 
   // Ensure that we report no error.
   Status.login = MASTER_PASSWORD_LOCKED;
   do_check_false(errorHandler.shouldReportError());
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
@@ -1683,17 +1683,17 @@
   let engine = engineManager.get("catapult");
   engine.enabled = true;
   delete engine.exception;
   engine.sync = function sync() {
     Svc.Obs.notify("weave:engine:sync:applied", {newFailed:1}, "catapult");
   };
 
   let log = Log4Moz.repository.getLogger("Sync.ErrorHandler");
-  Svc.Prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.logOnError", true);
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
 
     do_check_eq(Status.engines["catapult"], ENGINE_APPLY_FAIL);
     do_check_eq(Status.service, SYNC_FAILED_PARTIAL);
 
     // Test Error log was written on SYNC_FAILED_PARTIAL.
diff --git a/services/sync/tests/unit/test_errorhandler_filelog.js b/services/sync/tests/unit/test_errorhandler_filelog.js
--- a/services/sync/tests/unit/test_errorhandler_filelog.js
+++ b/services/sync/tests/unit/test_errorhandler_filelog.js
@@ -8,22 +8,22 @@
 
 const logsdir            = FileUtils.getDir("ProfD", ["weave", "logs"], true);
 const LOG_PREFIX_SUCCESS = "success-";
 const LOG_PREFIX_ERROR   = "error-";
 const CLEANUP_DELAY      = 1000; // delay to age files for cleanup (ms)
 const DELAY_BUFFER       = 50; // buffer for timers on different OS platforms
 
 const PROLONGED_ERROR_DURATION =
-  (Svc.Prefs.get('errorhandler.networkFailureReportTimeout') * 2) * 1000;
+  (Service.prefs.get('errorhandler.networkFailureReportTimeout') * 2) * 1000;
 
 let errorHandler = Service.errorHandler;
 
 function setLastSync(lastSyncValue) {
-  Svc.Prefs.set("lastSync", (new Date(Date.now() - lastSyncValue)).toString());
+  Service.prefs.set("lastSync", (new Date(Date.now() - lastSyncValue)).toString());
 }
 
 function run_test() {
   initTestLogging("Trace");
 
   Log4Moz.repository.getLogger("Sync.Service").level = Log4Moz.Level.Trace;
   Log4Moz.repository.getLogger("Sync.SyncScheduler").level = Log4Moz.Level.Trace;
   Log4Moz.repository.getLogger("Sync.ErrorHandler").level = Log4Moz.Level.Trace;
@@ -31,63 +31,63 @@
   run_next_test();
 }
 
 add_test(function test_noOutput() {
   // Ensure that the log appender won't print anything.
   errorHandler._logAppender.level = Log4Moz.Level.Fatal + 1;
 
   // Clear log output from startup.
-  Svc.Prefs.set("log.appender.file.logOnSuccess", false);
+  Service.prefs.set("log.appender.file.logOnSuccess", false);
   Svc.Obs.notify("weave:service:sync:finish");
 
   // Clear again without having issued any output.
-  Svc.Prefs.set("log.appender.file.logOnSuccess", true);
+  Service.prefs.set("log.appender.file.logOnSuccess", true);
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
 
     errorHandler._logAppender.level = Log4Moz.Level.Trace;
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   });
 
   // Fake a successful sync.
   Svc.Obs.notify("weave:service:sync:finish");
 });
 
 add_test(function test_logOnSuccess_false() {
-  Svc.Prefs.set("log.appender.file.logOnSuccess", false);
+  Service.prefs.set("log.appender.file.logOnSuccess", false);
 
   let log = Log4Moz.repository.getLogger("Sync.Test.FileLog");
   log.info("this won't show up");
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
     // No log file was written.
     do_check_false(logsdir.directoryEntries.hasMoreElements());
 
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   });
 
   // Fake a successful sync.
   Svc.Obs.notify("weave:service:sync:finish");
 });
 
 function readFile(file, callback) {
   NetUtil.asyncFetch(file, function (inputStream, statusCode, request) {
     let data = NetUtil.readInputStreamToString(inputStream,
                                                inputStream.available());
     callback(statusCode, data);
   });
 }
 
 add_test(function test_logOnSuccess_true() {
-  Svc.Prefs.set("log.appender.file.logOnSuccess", true);
+  Service.prefs.set("log.appender.file.logOnSuccess", true);
 
   let log = Log4Moz.repository.getLogger("Sync.Test.FileLog");
   const MESSAGE = "this WILL show up";
   log.info(MESSAGE);
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
 
@@ -108,47 +108,47 @@
       // Clean up.
       try {
         logfile.remove(false);
       } catch(ex) {
         dump("Couldn't delete file: " + ex + "\n");
         // Stupid Windows box.
       }
 
-      Svc.Prefs.resetBranch("");
+      Service.prefs.resetBranch("");
       run_next_test();
     });
   });
 
   // Fake a successful sync.
   Svc.Obs.notify("weave:service:sync:finish");
 });
 
 add_test(function test_sync_error_logOnError_false() {
-  Svc.Prefs.set("log.appender.file.logOnError", false);
+  Service.prefs.set("log.appender.file.logOnError", false);
 
   let log = Log4Moz.repository.getLogger("Sync.Test.FileLog");
   log.info("this won't show up");
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
     // No log file was written.
     do_check_false(logsdir.directoryEntries.hasMoreElements());
 
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   });
 
   // Fake an unsuccessful sync due to prolonged failure.
   setLastSync(PROLONGED_ERROR_DURATION);
   Svc.Obs.notify("weave:service:sync:error");
 });
 
 add_test(function test_sync_error_logOnError_true() {
-  Svc.Prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.logOnError", true);
 
   let log = Log4Moz.repository.getLogger("Sync.Test.FileLog");
   const MESSAGE = "this WILL show up";
   log.info(MESSAGE);
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
 
@@ -169,48 +169,48 @@
       // Clean up.
       try {
         logfile.remove(false);
       } catch(ex) {
         dump("Couldn't delete file: " + ex + "\n");
         // Stupid Windows box.
       }
 
-      Svc.Prefs.resetBranch("");
+      Service.prefs.resetBranch("");
       run_next_test();
     });
   });
 
   // Fake an unsuccessful sync due to prolonged failure.
   setLastSync(PROLONGED_ERROR_DURATION);
   Svc.Obs.notify("weave:service:sync:error");
 });
 
 add_test(function test_login_error_logOnError_false() {
-  Svc.Prefs.set("log.appender.file.logOnError", false);
+  Service.prefs.set("log.appender.file.logOnError", false);
 
   let log = Log4Moz.repository.getLogger("Sync.Test.FileLog");
   log.info("this won't show up");
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
     // No log file was written.
     do_check_false(logsdir.directoryEntries.hasMoreElements());
 
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   });
 
   // Fake an unsuccessful login due to prolonged failure.
   setLastSync(PROLONGED_ERROR_DURATION);
   Svc.Obs.notify("weave:service:login:error");
 });
 
 add_test(function test_login_error_logOnError_true() {
-  Svc.Prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.logOnError", true);
 
   let log = Log4Moz.repository.getLogger("Sync.Test.FileLog");
   const MESSAGE = "this WILL show up";
   log.info(MESSAGE);
 
   Svc.Obs.add("weave:service:reset-file-log", function onResetFileLog() {
     Svc.Obs.remove("weave:service:reset-file-log", onResetFileLog);
 
@@ -231,17 +231,17 @@
       // Clean up.
       try {
         logfile.remove(false);
       } catch(ex) {
         dump("Couldn't delete file: " + ex + "\n");
         // Stupid Windows box.
       }
 
-      Svc.Prefs.resetBranch("");
+      Service.prefs.resetBranch("");
       run_next_test();
     });
   });
 
   // Fake an unsuccessful login due to prolonged failure.
   setLastSync(PROLONGED_ERROR_DURATION);
   Svc.Obs.notify("weave:service:login:error");
 });
@@ -249,18 +249,18 @@
 // Check that error log files are deleted above an age threshold.
 add_test(function test_logErrorCleanup_age() {
   let maxAge = CLEANUP_DELAY/1000;
   let firstlog_name;
   let oldLogs = [];
   let numLogs = 10;
   let errString = "some error log\n";
 
-  Svc.Prefs.set("log.appender.file.logOnError", true);
-  Svc.Prefs.set("log.appender.file.maxErrorAge", maxAge);
+  Service.prefs.set("log.appender.file.logOnError", true);
+  Service.prefs.set("log.appender.file.maxErrorAge", maxAge);
 
   // Make some files.
   for (let i = 0; i < numLogs; i++) {
     let filename = LOG_PREFIX_ERROR + Date.now() + i + ".txt";
     let newLog = FileUtils.getFile("ProfD", ["weave", "logs", filename]);
     let foStream = FileUtils.openFileOutputStream(newLog);
     foStream.write(errString, errString.length);
     foStream.close();
@@ -282,16 +282,16 @@
     // Clean up.
     try {
       logfile.remove(false);
     } catch(ex) {
       dump("Couldn't delete file: " + ex + "\n");
       // Stupid Windows box.
     }
 
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   });
 
   CommonUtils.namedTimer(function onTimer() {
     Svc.Obs.notify("weave:service:sync:error");
   }, CLEANUP_DELAY + DELAY_BUFFER, this, "cleanup-timer");
 });
diff --git a/services/sync/tests/unit/test_history_engine.js b/services/sync/tests/unit/test_history_engine.js
--- a/services/sync/tests/unit/test_history_engine.js
+++ b/services/sync/tests/unit/test_history_engine.js
@@ -14,17 +14,17 @@
 
 add_test(function test_processIncoming_mobile_history_batched() {
   _("SyncEngine._processIncoming works on history engine.");
 
   let FAKE_DOWNLOAD_LIMIT = 100;
 
   new SyncTestingInfrastructure();
 
-  Svc.Prefs.set("client.type", "mobile");
+  Service.prefs.set("client.type", "mobile");
   PlacesUtils.history.removeAllPages();
   Service.engineManager.register(HistoryEngine);
 
   // A collection that logs each GET
   let collection = new ServerCollection();
   collection.get_log = [];
   collection._get = collection.get;
   collection.get = function (options) {
@@ -126,17 +126,17 @@
         do_check_eq(collection.get_log[j].ids.length, MOBILE_BATCH_SIZE);
       else
         do_check_eq(collection.get_log[j].ids.length, 234 % MOBILE_BATCH_SIZE);
     }
 
   } finally {
     PlacesUtils.history.removeAllPages();
     server.stop(do_test_finished);
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
   }
 });
 
 function run_test() {
   generateNewKeys(Service.collectionKeys);
 
   run_next_test();
diff --git a/services/sync/tests/unit/test_hmac_error.js b/services/sync/tests/unit/test_hmac_error.js
--- a/services/sync/tests/unit/test_hmac_error.js
+++ b/services/sync/tests/unit/test_hmac_error.js
@@ -90,17 +90,17 @@
     key404Counter = 1;
     _("---------------------------");
     Service.sync();
     _("---------------------------");
 
     // Two rotary items, one client record... no errors.
     do_check_eq(hmacErrorCount, 0)
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Service.recordManager.clearCache();
     server.stop(run_next_test);
   }
 });
 
 add_test(function hmac_error_during_node_reassignment() {
   _("Attempt to replicate an HMAC error during node reassignment.");
   let [engine, rotaryColl, clientsColl, keysWBO, global] = shared_setup();
@@ -221,17 +221,17 @@
 
         onSyncFinished = function() {
           // Two rotary items, one client record... no errors.
           do_check_eq(hmacErrorCount, 0)
 
           Svc.Obs.remove("weave:service:sync:finish", obs);
           Svc.Obs.remove("weave:service:sync:error", obs);
 
-          Svc.Prefs.resetBranch("");
+          Service.prefs.resetBranch("");
           Service.recordManager.clearCache();
           server.stop(run_next_test);
         };
 
         Service.sync();
       },
       this);
     };
diff --git a/services/sync/tests/unit/test_identity_manager.js b/services/sync/tests/unit/test_identity_manager.js
--- a/services/sync/tests/unit/test_identity_manager.js
+++ b/services/sync/tests/unit/test_identity_manager.js
@@ -1,16 +1,18 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
+Cu.import("resource://services-common/preferences.js");
 Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/identity.js");
 Cu.import("resource://services-sync/util.js");
 
-let identity = new IdentityManager();
+let prefs = new Preferences(PREFS_BRANCH);
+let identity = new IdentityManager(prefs);
 
 function run_test() {
   initTestLogging("Trace");
   Log4Moz.repository.getLogger("Sync.Identity").level = Log4Moz.Level.Trace;
 
   run_next_test();
 }
 
@@ -25,58 +27,58 @@
 
   run_next_test();
 });
 
 add_test(function test_account_username() {
   _("Ensure the account and username attributes work properly.");
 
   _("Verify initial state");
-  do_check_eq(Svc.Prefs.get("account"), undefined);
-  do_check_eq(Svc.Prefs.get("username"), undefined);
+  do_check_eq(prefs.get("account"), undefined);
+  do_check_eq(prefs.get("username"), undefined);
   do_check_eq(identity.account, null);
   do_check_eq(identity.username, null);
 
   _("The 'username' attribute is normalized to lower case, updates preferences and identities.");
   identity.username = "TarZan";
   do_check_eq(identity.username, "tarzan");
-  do_check_eq(Svc.Prefs.get("username"), "tarzan");
+  do_check_eq(prefs.get("username"), "tarzan");
   do_check_eq(identity.username, "tarzan");
 
   _("If not set, the 'account attribute' falls back to the username for backwards compatibility.");
   do_check_eq(identity.account, "tarzan");
 
   _("Setting 'username' to a non-truthy value resets the pref.");
   identity.username = null;
   do_check_eq(identity.username, null);
   do_check_eq(identity.account, null);
   const default_marker = {};
-  do_check_eq(Svc.Prefs.get("username", default_marker), default_marker);
+  do_check_eq(prefs.get("username", default_marker), default_marker);
   do_check_eq(identity.username, null);
 
   _("The 'account' attribute will set the 'username' if it doesn't contain characters that aren't allowed in the username.");
   identity.account = "johndoe";
   do_check_eq(identity.account, "johndoe");
   do_check_eq(identity.username, "johndoe");
-  do_check_eq(Svc.Prefs.get("username"), "johndoe");
+  do_check_eq(prefs.get("username"), "johndoe");
   do_check_eq(identity.username, "johndoe");
 
   _("If 'account' contains disallowed characters such as @, 'username' will the base32 encoded SHA1 hash of 'account'");
   identity.account = "John@Doe.com";
   do_check_eq(identity.account, "john@doe.com");
   do_check_eq(identity.username, "7wohs32cngzuqt466q3ge7indszva4of");
 
   _("Setting 'account' to a non-truthy value resets the pref.");
   identity.account = null;
   do_check_eq(identity.account, null);
-  do_check_eq(Svc.Prefs.get("account", default_marker), default_marker);
+  do_check_eq(prefs.get("account", default_marker), default_marker);
   do_check_eq(identity.username, null);
-  do_check_eq(Svc.Prefs.get("username", default_marker), default_marker);
+  do_check_eq(prefs.get("username", default_marker), default_marker);
 
-  Svc.Prefs.resetBranch("");
+  prefs.resetBranch("");
   run_next_test();
 });
 
 add_test(function test_basic_password() {
   _("Ensure basic password setting works as expected.");
 
   identity.account = null;
   do_check_eq(identity.currentAuthState, LOGIN_FAILED_NO_USERNAME);
@@ -108,22 +110,22 @@
   // Just in case.
   identity.account = null;
   identity.deleteSyncCredentials();
 
   identity.account = "janesmith";
   identity.basicPassword = "ilovejohn";
   identity.persistCredentials();
 
-  let im1 = new IdentityManager();
+  let im1 = new IdentityManager(prefs);
   do_check_eq(im1._basicPassword, null);
   do_check_eq(im1.username, "janesmith");
   do_check_eq(im1.basicPassword, "ilovejohn");
 
-  let im2 = new IdentityManager();
+  let im2 = new IdentityManager(prefs);
   do_check_eq(im2._basicPassword, null);
 
   _("Now remove the password and ensure it is deleted from storage.");
   identity.basicPassword = null;
   identity.persistCredentials(); // This should nuke from storage.
   do_check_eq(im2.basicPassword, null);
 
   _("Ensure that retrieving an unset but unpersisted removal returns null.");
@@ -167,30 +169,30 @@
   _("But the SyncKeyBundle should not be created from bad keys.");
   do_check_eq(identity.syncKeyBundle, null);
 
   let syncKey = Utils.generatePassphrase();
   identity.syncKey = syncKey;
   do_check_eq(identity.syncKey, syncKey);
   do_check_neq(identity.syncKeyBundle, null);
 
-  let im = new IdentityManager();
+  let im = new IdentityManager(prefs);
   im.account = "pseudojohn";
   do_check_eq(im.syncKey, null);
   do_check_eq(im.syncKeyBundle, null);
 
   identity.account = null;
 
   run_next_test();
 });
 
 add_test(function test_sync_key_changes() {
   _("Ensure changes to Sync Key have appropriate side-effects.");
 
-  let im = new IdentityManager();
+  let im = new IdentityManager(prefs);
   let sk1 = Utils.generatePassphrase();
   let sk2 = Utils.generatePassphrase();
 
   im.account = "johndoe";
   do_check_eq(im.syncKey, null);
   do_check_eq(im.syncKeyBundle, null);
 
   im.syncKey = sk1;
@@ -210,17 +212,17 @@
   im.account = null;
 
   run_next_test();
 });
 
 add_test(function test_current_auth_state() {
   _("Ensure current auth state is reported properly.");
 
-  let im = new IdentityManager();
+  let im = new IdentityManager(prefs);
   do_check_eq(im.currentAuthState, LOGIN_FAILED_NO_USERNAME);
 
   im.account = "johndoe";
   do_check_eq(im.currentAuthState, LOGIN_FAILED_NO_PASSWORD);
 
   im.basicPassword = "ilovejane";
   do_check_eq(im.currentAuthState, LOGIN_FAILED_NO_PASSPHRASE);
 
@@ -244,31 +246,31 @@
   identity.account = "pseudojohn";
   identity.password = "supersecret";
 
   let syncKey = Utils.generatePassphrase();
   identity.syncKey = syncKey;
 
   identity.persistCredentials();
 
-  let im = new IdentityManager();
+  let im = new IdentityManager(prefs);
   im.account = "pseudojohn";
   do_check_eq(im.syncKey, syncKey);
   do_check_neq(im.syncKeyBundle, null);
 
   let kb1 = identity.syncKeyBundle;
   let kb2 = im.syncKeyBundle;
 
   do_check_eq(kb1.encryptionKeyB64, kb2.encryptionKeyB64);
   do_check_eq(kb1.hmacKeyB64, kb2.hmacKeyB64);
 
   identity.account = null;
   identity.persistCredentials();
 
-  let im2 = new IdentityManager();
+  let im2 = new IdentityManager(prefs);
   im2.account = "pseudojohn";
   do_check_eq(im2.syncKey, null);
 
   im2.account = null;
 
   _("Ensure deleted but not persisted value is retrieved.");
   identity.account = "someoneelse";
   identity.syncKey = Utils.generatePassphrase();
diff --git a/services/sync/tests/unit/test_interval_triggers.js b/services/sync/tests/unit/test_interval_triggers.js
--- a/services/sync/tests/unit/test_interval_triggers.js
+++ b/services/sync/tests/unit/test_interval_triggers.js
@@ -1,18 +1,21 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/engines.js");
 Cu.import("resource://services-sync/engines/clients.js");
+Cu.import("resource://services-sync/preferences.js");
 Cu.import("resource://services-sync/util.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
-Svc.DefaultPrefs.set("registerEngines", "");
+let prefs = new Preferences(PREFS_BRANCH);
+prefs.set("registerEngines", "");
+
 Cu.import("resource://services-sync/service.js");
 
 let scheduler = Service.scheduler;
 let clientsEngine = Service.clientsEngine;
 
 function sync_httpd_setup() {
   let global = new ServerWBO("global", {
     syncID: Service.syncID,
@@ -161,17 +164,17 @@
   function onSyncError() {
     _("Sync error.");
     syncFailures++;
   }
   Svc.Obs.add("weave:service:sync:error", onSyncError);
 
   _("Test unsuccessful sync calls adjustSyncInterval");
   // Force sync to fail.
-  Svc.Prefs.set("firstSync", "notReady");
+  prefs.set("firstSync", "notReady");
 
   let server = sync_httpd_setup();
   setUp();
 
   // Confirm defaults
   do_check_false(scheduler.idle);
   do_check_false(scheduler.numClients > 1);
   do_check_eq(scheduler.syncInterval, scheduler.singleDeviceInterval);
@@ -260,54 +263,54 @@
 });
 
 add_test(function test_back_triggers_sync() {
   let server = sync_httpd_setup();
   setUp();
 
   // Single device: no sync triggered.
   scheduler.idle = true;
-  scheduler.observe(null, "back", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "back", prefs.get("scheduler.idleTime"));
   do_check_false(scheduler.idle);
 
   // Multiple devices: sync is triggered.
   clientsEngine._store.create({id: "foo", cleartext: "bar"});
   scheduler.updateClientMode();
 
   Svc.Obs.add("weave:service:sync:finish", function onSyncFinish() {
     Svc.Obs.remove("weave:service:sync:finish", onSyncFinish);
 
     Service.recordManager.clearCache();
-    Svc.Prefs.resetBranch("");
+    prefs.resetBranch("");
     scheduler.setDefaults();
     clientsEngine.resetClient();
 
     Service.startOver();
     server.stop(run_next_test);
   });
 
   scheduler.idle = true;
-  scheduler.observe(null, "back", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "back", prefs.get("scheduler.idleTime"));
   do_check_false(scheduler.idle);
 });
 
 add_test(function test_adjust_interval_on_sync_error() {
   let server = sync_httpd_setup();
   setUp();
 
   let syncFailures = 0;
   function onSyncError() {
     _("Sync error.");
     syncFailures++;
   }
   Svc.Obs.add("weave:service:sync:error", onSyncError);
 
   _("Test unsuccessful sync updates client mode & sync intervals");
   // Force a sync fail.
-  Svc.Prefs.set("firstSync", "notReady");
+  prefs.set("firstSync", "notReady");
 
   do_check_eq(syncFailures, 0);
   do_check_false(scheduler.numClients > 1);
   do_check_eq(scheduler.syncInterval, scheduler.singleDeviceInterval);
 
   clientsEngine._store.create({id: "foo", cleartext: "bar"});
   Service.sync();
 
diff --git a/services/sync/tests/unit/test_jpakeclient.js b/services/sync/tests/unit/test_jpakeclient.js
--- a/services/sync/tests/unit/test_jpakeclient.js
+++ b/services/sync/tests/unit/test_jpakeclient.js
@@ -1,12 +1,16 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
 Cu.import("resource://services-common/log4moz.js");
+Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/identity.js");
 Cu.import("resource://services-sync/jpakeclient.js");
-Cu.import("resource://services-sync/constants.js");
+Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
 const JPAKE_LENGTH_SECRET     = 8;
 const JPAKE_LENGTH_CLIENTID   = 256;
 const KEYEXCHANGE_VERSION     = 3;
 
 /*
@@ -156,32 +160,33 @@
   onAbort: function onAbort(error) {
     do_throw("Shouldn't have aborted with " + error + "!");
   },
   onPaired: function onPaired() {
     do_throw("onPaired() shouldn't have been called!");
   },
   onComplete: function onComplete(data) {
     do_throw("Shouldn't have completed with " + data + "!");
-  }
+  },
+  prefs: Service.prefs,
 };
 
 
 const DATA = {"msg": "eggstreamly sekrit"};
 const POLLINTERVAL = 50;
 
 function run_test() {
-  Svc.Prefs.set("jpake.serverURL", TEST_SERVER_URL);
-  Svc.Prefs.set("jpake.pollInterval", POLLINTERVAL);
-  Svc.Prefs.set("jpake.maxTries", 2);
-  Svc.Prefs.set("jpake.firstMsgMaxTries", 5);
-  Svc.Prefs.set("jpake.lastMsgMaxTries", 5);
+  Service.prefs.set("jpake.serverURL", TEST_SERVER_URL);
+  Service.prefs.set("jpake.pollInterval", POLLINTERVAL);
+  Service.prefs.set("jpake.maxTries", 2);
+  Service.prefs.set("jpake.firstMsgMaxTries", 5);
+  Service.prefs.set("jpake.lastMsgMaxTries", 5);
   // Ensure clean up
   Svc.Obs.add("profile-before-change", function() {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   });
 
   // Ensure PSM is initialized.
   Cc["@mozilla.org/psm;1"].getService(Ci.nsISupports);
 
   // Simulate Sync setup with credentials in place. We want to make
   // sure the J-PAKE requests don't include those data.
   setBasicCredentials("johndoe", "ilovejane");
@@ -473,42 +478,42 @@
       run_next_test();
     }
   });
   snd.pairWithPIN("01234567" + cid, false);
 });
 
 
 add_test(function test_error_channel() {
-  let serverURL = Svc.Prefs.get("jpake.serverURL");
-  Svc.Prefs.set("jpake.serverURL", "http://localhost:12345/");
+  let serverURL = Service.prefs.get("jpake.serverURL");
+  Service.prefs.set("jpake.serverURL", "http://localhost:12345/");
 
   let rec = new JPAKEClient({
     __proto__: BaseController,
     onAbort: function onAbort(error) {
       do_check_eq(error, JPAKE_ERROR_CHANNEL);
-      Svc.Prefs.set("jpake.serverURL", serverURL);
+      Service.prefs.set("jpake.serverURL", serverURL);
       run_next_test();
     },
     onPairingStart: function onPairingStart(pin) {},
     displayPIN: function displayPIN(pin) {}
   });
   rec.receiveNoPIN();
 });
 
 
 add_test(function test_error_network() {
-  let serverURL = Svc.Prefs.get("jpake.serverURL");
-  Svc.Prefs.set("jpake.serverURL", "http://localhost:12345/");
+  let serverURL = Service.prefs.get("jpake.serverURL");
+  Service.prefs.set("jpake.serverURL", "http://localhost:12345/");
 
   let snd = new JPAKEClient({
     __proto__: BaseController,
     onAbort: function onAbort(error) {
       do_check_eq(error, JPAKE_ERROR_NETWORK);
-      Svc.Prefs.set("jpake.serverURL", serverURL);
+      Service.prefs.set("jpake.serverURL", serverURL);
       run_next_test();
     }
   });
   snd.pairWithPIN("0123456789ab", false);
 });
 
 
 add_test(function test_error_server_noETag() {
diff --git a/services/sync/tests/unit/test_keys.js b/services/sync/tests/unit/test_keys.js
--- a/services/sync/tests/unit/test_keys.js
+++ b/services/sync/tests/unit/test_keys.js
@@ -1,11 +1,12 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
+Cu.import("resource://services-common/preferences.js");
 Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/identity.js");
 Cu.import("resource://services-sync/keys.js");
 Cu.import("resource://services-sync/record.js");
 Cu.import("resource://services-sync/util.js");
 
 let collectionKeys = new CollectionKeyManager();
 
@@ -170,17 +171,18 @@
 
   run_next_test();
 });
 
 add_test(function test_collections_manager() {
   let log = Log4Moz.repository.getLogger("Test");
   Log4Moz.repository.rootLogger.addAppender(new Log4Moz.DumpAppender());
 
-  let identity = new IdentityManager();
+  let prefs = new Preferences(PREFS_BRANCH);
+  let identity = new IdentityManager(prefs);
 
   identity.account = "john@example.com";
   identity.syncKey = "a-bbbbb-ccccc-ddddd-eeeee-fffff";
 
   let keyBundle = identity.syncKeyBundle;
 
   /*
    * Build a test version of storage/crypto/keys.
diff --git a/services/sync/tests/unit/test_prefs_store.js b/services/sync/tests/unit/test_prefs_store.js
--- a/services/sync/tests/unit/test_prefs_store.js
+++ b/services/sync/tests/unit/test_prefs_store.js
@@ -23,22 +23,22 @@
 }
 
 function run_test() {
   let store = Service.engineManager.get("prefs")._store;
   let prefs = new Preferences();
   try {
 
     _("Test fixtures.");
-    Svc.Prefs.set("prefs.sync.testing.int", true);
-    Svc.Prefs.set("prefs.sync.testing.string", true);
-    Svc.Prefs.set("prefs.sync.testing.bool", true);
-    Svc.Prefs.set("prefs.sync.testing.dont.change", true);
-    Svc.Prefs.set("prefs.sync.testing.turned.off", false);
-    Svc.Prefs.set("prefs.sync.testing.nonexistent", true);
+    prefs.set("prefs.sync.testing.int", true);
+    prefs.set("prefs.sync.testing.string", true);
+    prefs.set("prefs.sync.testing.bool", true);
+    prefs.set("prefs.sync.testing.dont.change", true);
+    prefs.set("prefs.sync.testing.turned.off", false);
+    prefs.set("prefs.sync.testing.nonexistent", true);
 
     prefs.set("testing.int", 123);
     prefs.set("testing.string", "ohai");
     prefs.set("testing.bool", true);
     prefs.set("testing.dont.change", "Please don't change me.");
     prefs.set("testing.turned.off", "I won't get synced.");
     prefs.set("testing.not.turned.on", "I won't get synced either!");
 
@@ -69,32 +69,32 @@
     do_check_eq(record.value["services.sync.prefs.sync.testing.int"], true);
     do_check_eq(record.value["services.sync.prefs.sync.testing.string"], true);
     do_check_eq(record.value["services.sync.prefs.sync.testing.bool"], true);
     do_check_eq(record.value["services.sync.prefs.sync.testing.dont.change"], true);
     do_check_eq(record.value["services.sync.prefs.sync.testing.turned.off"], false);
     do_check_eq(record.value["services.sync.prefs.sync.testing.nonexistent"], true);
 
     _("Update some prefs, including one that's to be reset/deleted.");
-    Svc.Prefs.set("testing.deleteme", "I'm going to be deleted!");
+    prefs.set("testing.deleteme", "I'm going to be deleted!");
     record = new PrefRec("prefs", PREFS_GUID);
     record.value = {
       "testing.int": 42,
       "testing.string": "im in ur prefs",
       "testing.bool": false,
       "testing.deleteme": null,
       "services.sync.prefs.sync.testing.somepref": true
     };
     store.update(record);
     do_check_eq(prefs.get("testing.int"), 42);
     do_check_eq(prefs.get("testing.string"), "im in ur prefs");
     do_check_eq(prefs.get("testing.bool"), false);
     do_check_eq(prefs.get("testing.deleteme"), undefined);
     do_check_eq(prefs.get("testing.dont.change"), "Please don't change me.");
-    do_check_eq(Svc.Prefs.get("prefs.sync.testing.somepref"), true);
+    do_check_eq(prefs.get("prefs.sync.testing.somepref"), true);
 
     _("Enable persona");
     // Ensure we don't go to the network to fetch personas and end up leaking
     // stuff.
     Services.io.offline = true;
     do_check_false(!!prefs.get("lightweightThemes.isThemeSelected"));
     do_check_eq(LightweightThemeManager.currentTheme, null);
 
diff --git a/services/sync/tests/unit/test_prefs_tracker.js b/services/sync/tests/unit/test_prefs_tracker.js
--- a/services/sync/tests/unit/test_prefs_tracker.js
+++ b/services/sync/tests/unit/test_prefs_tracker.js
@@ -11,40 +11,40 @@
 function run_test() {
   let engine = Service.engineManager.get("prefs");
   let tracker = engine._tracker;
   let prefs = new Preferences();
 
   try {
 
     _("tracker.modified corresponds to preference.");
-    do_check_eq(Svc.Prefs.get("engine.prefs.modified"), undefined);
+    do_check_eq(Service.prefs.get("engine.prefs.modified"), undefined);
     do_check_false(tracker.modified);
 
     tracker.modified = true;
-    do_check_eq(Svc.Prefs.get("engine.prefs.modified"), true);
+    do_check_eq(Service.prefs.get("engine.prefs.modified"), true);
     do_check_true(tracker.modified);
 
     _("Engine's getChangedID() just returns the one GUID we have.");
     let changedIDs = engine.getChangedIDs();
     let ids = Object.keys(changedIDs);
     do_check_eq(ids.length, 1);
     do_check_eq(ids[0], CommonUtils.encodeBase64URL(Services.appinfo.ID));
 
-    Svc.Prefs.set("engine.prefs.modified", false);
+    Service.prefs.set("engine.prefs.modified", false);
     do_check_false(tracker.modified);
 
     _("No modified state, so no changed IDs.");
     do_check_empty(engine.getChangedIDs());
 
     _("Initial score is 0");
     do_check_eq(tracker.score, 0);
 
     _("Test fixtures.");
-    Svc.Prefs.set("prefs.sync.testing.int", true);
+    Service.prefs.set("prefs.sync.testing.int", true);
 
     _("Test fixtures haven't upped the tracker score yet because it hasn't started tracking yet.");
     do_check_eq(tracker.score, 0);
 
     _("Tell the tracker to start tracking changes.");
     Svc.Obs.notify("weave:engine:start-tracking");
     prefs.set("testing.int", 23);
     do_check_eq(tracker.score, SCORE_INCREMENT_XLARGE);
@@ -56,17 +56,17 @@
 
     _("Resetting a pref ups the score, too.");
     prefs.reset("testing.int");
     do_check_eq(tracker.score, SCORE_INCREMENT_XLARGE * 2);
     do_check_eq(tracker.modified, true);
     tracker.clearChangedIDs();
 
     _("So does changing a pref sync pref.");
-    Svc.Prefs.set("prefs.sync.testing.int", false);
+    Service.prefs.set("prefs.sync.testing.int", false);
     do_check_eq(tracker.score, SCORE_INCREMENT_XLARGE * 3);
     do_check_eq(tracker.modified, true);
     tracker.clearChangedIDs();
 
     _("Now that the pref sync pref has been flipped, changes to it won't be picked up.");
     prefs.set("testing.int", 42);
     do_check_eq(tracker.score, SCORE_INCREMENT_XLARGE * 3);
     do_check_eq(tracker.modified, false);
diff --git a/services/sync/tests/unit/test_resource.js b/services/sync/tests/unit/test_resource.js
--- a/services/sync/tests/unit/test_resource.js
+++ b/services/sync/tests/unit/test_resource.js
@@ -1,17 +1,21 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-common/log4moz.js");
 Cu.import("resource://services-common/observers.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/identity.js");
 Cu.import("resource://services-sync/resource.js");
 Cu.import("resource://services-sync/util.js");
 
+let prefs = new Preferences(PREFS_BRANCH);
+
 let logger;
 
 let fetched = false;
 function server_open(metadata, response) {
   let body;
   if (metadata.method == "GET") {
     fetched = true;
     body = "This path exists";
@@ -166,17 +170,17 @@
     "/timestamp": server_timestamp,
     "/headers": server_headers,
     "/backoff": server_backoff,
     "/pac1": server_pac,
     "/quota-notice": server_quota_notice,
     "/quota-error": server_quota_error
   });
 
-  Svc.Prefs.set("network.numRetries", 1); // speed up test
+  prefs.set("network.numRetries", 1); // speed up test
 
   // This apparently has to come first in order for our PAC URL to be hit.
   // Don't put any other HTTP requests earlier in the file!
   _("Testing handling of proxy auth redirection.");
   PACSystemSettings.PACURI = "http://localhost:8080/pac1";
   installFakePAC();
   let proxiedRes = new Resource("http://localhost:8080/open");
   let content = proxiedRes.get();
@@ -238,17 +242,18 @@
   let res2 = new Resource("http://localhost:8080/protected");
   content = res2.get();
   do_check_eq(content, "This path exists and is protected - failed");
   do_check_eq(content.status, 401);
   do_check_false(content.success);
 
   _("GET a password protected resource");
   let res3 = new Resource("http://localhost:8080/protected");
-  let identity = new IdentityManager();
+  prefs = new Preferences(PREFS_BRANCH);
+  let identity = new IdentityManager(prefs);
   let auth = identity.getBasicResourceAuthenticator("guest", "guest");
   res3.authenticator = auth;
   do_check_eq(res3.authenticator, auth);
   content = res3.get();
   do_check_eq(content, "This path exists and is protected");
   do_check_eq(content.status, 200);
   do_check_true(content.success);
 
diff --git a/services/sync/tests/unit/test_resource_async.js b/services/sync/tests/unit/test_resource_async.js
--- a/services/sync/tests/unit/test_resource_async.js
+++ b/services/sync/tests/unit/test_resource_async.js
@@ -1,20 +1,24 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-common/log4moz.js");
 Cu.import("resource://services-common/observers.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/identity.js");
 Cu.import("resource://services-sync/resource.js");
 Cu.import("resource://services-sync/util.js");
 
 const RES_UPLOAD_URL = "http://localhost:8080/upload";
 const RES_HEADERS_URL = "http://localhost:8080/headers";
 
+let prefs = new Preferences(PREFS_BRANCH);
+
 let logger;
 
 let fetched = false;
 function server_open(metadata, response) {
   let body;
   if (metadata.method == "GET") {
     fetched = true;
     body = "This path exists";
@@ -154,17 +158,17 @@
 let quotaValue;
 Observers.add("weave:service:quota:remaining",
               function (subject) { quotaValue = subject; });
 
 function run_test() {
   logger = Log4Moz.repository.getLogger('Test');
   Log4Moz.repository.rootLogger.addAppender(new Log4Moz.DumpAppender());
 
-  Svc.Prefs.set("network.numRetries", 1); // speed up test
+  prefs.set("network.numRetries", 1); // speed up test
   run_next_test();
 }
 
 // This apparently has to come first in order for our PAC URL to be hit.
 // Don't put any other HTTP requests earlier in the file!
 add_test(function test_proxy_auth_redirect() {
   _("Ensure that a proxy auth redirect (which switches out our channel) " +
     "doesn't break AsyncResource.");
@@ -316,17 +320,18 @@
     do_check_eq(content.status, 401);
     do_check_false(content.success);
     run_next_test();
   });
 });
 
 add_test(function test_get_protected_success() {
   _("GET a password protected resource");
-  let identity = new IdentityManager();
+  let prefs = new Preferences(PREFS_BRANCH);
+  let identity = new IdentityManager(prefs);
   let auth = identity.getBasicResourceAuthenticator("guest", "guest");
   let res3 = new AsyncResource("http://localhost:8080/protected");
   res3.authenticator = auth;
   do_check_eq(res3.authenticator, auth);
   res3.get(function (error, content) {
     do_check_eq(error, null);
     do_check_eq(content, "This path exists and is protected");
     do_check_eq(content.status, 200);
diff --git a/services/sync/tests/unit/test_resource_ua.js b/services/sync/tests/unit/test_resource_ua.js
--- a/services/sync/tests/unit/test_resource_ua.js
+++ b/services/sync/tests/unit/test_resource_ua.js
@@ -55,29 +55,29 @@
       do_check_eq(ua, expectedUA + ".desktop");
       ua = "";
       next();
     });
   }
 
   function test_desktop_get(next) {
     _("Testing async.");
-    Svc.Prefs.set("client.type", "desktop");
+    Service.prefs.set("client.type", "desktop");
     let r = new AsyncResource(TEST_GET_URL);
     r.get(function(error, content) {
       _("User-Agent: " + ua);
       do_check_eq(ua, expectedUA + ".desktop");
       ua = "";
       next();
     });
   }
 
   function test_mobile_get(next) {
     _("Testing mobile.");
-    Svc.Prefs.set("client.type", "mobile");
+    Service.prefs.set("client.type", "mobile");
     let r = new AsyncResource(TEST_GET_URL);
     r.get(function (error, content) {
       _("User-Agent: " + ua);
       do_check_eq(ua, expectedUA + ".mobile");
       ua = "";
       next();
     });
   }
diff --git a/services/sync/tests/unit/test_service_attributes.js b/services/sync/tests/unit/test_service_attributes.js
--- a/services/sync/tests/unit/test_service_attributes.js
+++ b/services/sync/tests/unit/test_service_attributes.js
@@ -22,79 +22,79 @@
     // Since we don't have a cluster URL yet, these will still not be defined.
     do_check_eq(Service.infoURL, undefined);
     do_check_eq(Service.userBaseURL, undefined);
     do_check_eq(Service.storageURL, undefined);
     do_check_eq(Service.metaURL, undefined);
 
     Service.serverURL = "http://weave.server/";
     Service.clusterURL = "http://weave.cluster/";
-    do_check_eq(Svc.Prefs.get("clusterURL"), "http://weave.cluster/");
+    do_check_eq(Service.prefs.get("clusterURL"), "http://weave.cluster/");
 
     do_check_eq(Service.userBaseURL, "http://weave.cluster/1.1/johndoe/");
     do_check_eq(Service.infoURL,
                 "http://weave.cluster/1.1/johndoe/info/collections");
     do_check_eq(Service.storageURL,
                 "http://weave.cluster/1.1/johndoe/storage/");
     do_check_eq(Service.metaURL,
                 "http://weave.cluster/1.1/johndoe/storage/meta/global");
 
     _("The 'miscURL' and 'userURL' attributes can be relative to 'serverURL' or absolute.");
-    Svc.Prefs.set("miscURL", "relative/misc/");
-    Svc.Prefs.set("userURL", "relative/user/");
+    Service.prefs.set("miscURL", "relative/misc/");
+    Service.prefs.set("userURL", "relative/user/");
     do_check_eq(Service.miscAPI,
                 "http://weave.server/relative/misc/1.0/");
     do_check_eq(Service.userAPIURI,
                 "http://weave.server/relative/user/1.0/");
 
-    Svc.Prefs.set("miscURL", "http://weave.misc.services/");
-    Svc.Prefs.set("userURL", "http://weave.user.services/");
+    Service.prefs.set("miscURL", "http://weave.misc.services/");
+    Service.prefs.set("userURL", "http://weave.user.services/");
     do_check_eq(Service.miscAPI, "http://weave.misc.services/1.0/");
     do_check_eq(Service.userAPIURI, "http://weave.user.services/1.0/");
 
     do_check_eq(Service.pwResetURL,
                 "http://weave.server/weave-password-reset");
 
     _("Empty/false value for 'username' resets preference.");
     Service.identity.username = "";
-    do_check_eq(Svc.Prefs.get("username"), undefined);
+    do_check_eq(Service.prefs.get("username"), undefined);
     do_check_eq(Service.identity.username, null);
 
     _("The 'serverURL' attributes updates/resets preferences.");
     // Identical value doesn't do anything
     Service.serverURL = Service.serverURL;
-    do_check_eq(Svc.Prefs.get("clusterURL"), "http://weave.cluster/");
+    do_check_eq(Service.prefs.get("clusterURL"), "http://weave.cluster/");
 
     Service.serverURL = "http://different.auth.node/";
-    do_check_eq(Svc.Prefs.get("serverURL"), "http://different.auth.node/");
-    do_check_eq(Svc.Prefs.get("clusterURL"), undefined);
+    do_check_eq(Service.prefs.get("serverURL"), "http://different.auth.node/");
+    do_check_eq(Service.prefs.get("clusterURL"), undefined);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   }
 }
 
 
 function test_syncID() {
   _("Service.syncID is auto-generated, corresponds to preference.");
   new FakeGUIDService();
 
   try {
     // Ensure pristine environment
-    do_check_eq(Svc.Prefs.get("client.syncID"), undefined);
+    do_check_eq(Service.prefs.get("client.syncID"), undefined);
 
     // Performing the first get on the attribute will generate a new GUID.
     do_check_eq(Service.syncID, "fake-guid-0");
-    do_check_eq(Svc.Prefs.get("client.syncID"), "fake-guid-0");
+    do_check_eq(Service.prefs.get("client.syncID"), "fake-guid-0");
 
-    Svc.Prefs.set("client.syncID", Utils.makeGUID());
-    do_check_eq(Svc.Prefs.get("client.syncID"), "fake-guid-1");
+    Service.prefs.set("client.syncID", Utils.makeGUID());
+    do_check_eq(Service.prefs.get("client.syncID"), "fake-guid-1");
     do_check_eq(Service.syncID, "fake-guid-1");
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     new FakeGUIDService();
   }
 }
 
 function test_locked() {
   _("The 'locked' attribute can be toggled with lock() and unlock()");
 
   // Defaults to false
diff --git a/services/sync/tests/unit/test_service_changePassword.js b/services/sync/tests/unit/test_service_changePassword.js
--- a/services/sync/tests/unit/test_service_changePassword.js
+++ b/services/sync/tests/unit/test_service_changePassword.js
@@ -65,13 +65,13 @@
     _("changePassword() returns false for a server error, the password won't change.");
     Services.logins.removeAllLogins();
     setBasicCredentials("janedoe", "ilovejohn");
     res = Service.changePassword("ILoveJohn86");
     do_check_false(res);
     do_check_eq(Service.identity.basicPassword, "ilovejohn");
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Services.logins.removeAllLogins();
     server.stop(run_next_test);
   }
 });
diff --git a/services/sync/tests/unit/test_service_checkAccount.js b/services/sync/tests/unit/test_service_checkAccount.js
--- a/services/sync/tests/unit/test_service_checkAccount.js
+++ b/services/sync/tests/unit/test_service_checkAccount.js
@@ -29,12 +29,12 @@
 
     _("Username fallback: Account that's not available.");
     do_check_eq(Service.checkAccount("johndoe"), "notAvailable");
 
     _("Username fallback: Account that's available.");
     do_check_eq(Service.checkAccount("janedoe"), "available");
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(do_test_finished);
   }
 }
diff --git a/services/sync/tests/unit/test_service_cluster.js b/services/sync/tests/unit/test_service_cluster.js
--- a/services/sync/tests/unit/test_service_cluster.js
+++ b/services/sync/tests/unit/test_service_cluster.js
@@ -57,17 +57,17 @@
 
     _("Any other server response (e.g. 500) will throw an error.");
     Service.identity.account = "joedoe";
     do_check_throws(function() {
       Service._clusterManager._findCluster();
     });
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     if (server) {
       server.stop(run_next_test);
     }
   }
 });
 
 add_test(function test_setCluster() {
   _("Test Service._setCluster()");
@@ -91,17 +91,17 @@
     do_check_eq(Service.clusterURL, "http://weave.user.node/");
 
     _("A 'null' response won't make a difference either.");
     Service.identity.account = "jimdoe";
     do_check_false(Service._clusterManager.setCluster());
     do_check_eq(Service.clusterURL, "http://weave.user.node/");
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
 
 function run_test() {
   initTestLogging();
   run_next_test();
 }
diff --git a/services/sync/tests/unit/test_service_createAccount.js b/services/sync/tests/unit/test_service_createAccount.js
--- a/services/sync/tests/unit/test_service_createAccount.js
+++ b/services/sync/tests/unit/test_service_createAccount.js
@@ -58,18 +58,18 @@
     do_check_eq(res, "invalid-captcha");
 
     _("Generic server error.");
     res = Service.createAccount("jim@doe.com", "preciousss",
                                 "challenge", "response");
     do_check_eq(res, "generic-server-error");
 
     _("Admin secret preference is passed as HTTP header token.");
-    Svc.Prefs.set("admin-secret", "my-server-secret");
+    Service.prefs.set("admin-secret", "my-server-secret");
     res = Service.createAccount("john@doe.com", "mysecretpw",
                                 "challenge", "response");
     do_check_eq(secretHeader, "my-server-secret");
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(do_test_finished);
   }
 }
diff --git a/services/sync/tests/unit/test_service_detect_upgrade.js b/services/sync/tests/unit/test_service_detect_upgrade.js
--- a/services/sync/tests/unit/test_service_detect_upgrade.js
+++ b/services/sync/tests/unit/test_service_detect_upgrade.js
@@ -181,17 +181,17 @@
 
     _("... and keys will now match.");
     retrieve_and_compare_default(true);
 
     // Clean up.
     Service.startOver();
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
 
 add_test(function v5_upgrade() {
   let passphrase = "abcdeabcdeabcdeabcdeabcdea";
 
   // Tracking info/collections.
@@ -283,17 +283,17 @@
     _("Status: " + Service.status);
     do_check_false(Service.isLoggedIn);
     do_check_eq(VERSION_OUT_OF_DATE, Service.status.sync);
 
     // Clean up.
     Service.startOver();
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
 
 function run_test() {
   let logger = Log4Moz.repository.rootLogger;
   Log4Moz.repository.rootLogger.addAppender(new Log4Moz.DumpAppender());
 
diff --git a/services/sync/tests/unit/test_service_login.js b/services/sync/tests/unit/test_service_login.js
--- a/services/sync/tests/unit/test_service_login.js
+++ b/services/sync/tests/unit/test_service_login.js
@@ -1,15 +1,15 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-common/log4moz.js");
 Cu.import("resource://services-sync/constants.js");
+Cu.import("resource://services-sync/policies.js");
 Cu.import("resource://services-sync/service.js");
-Cu.import("resource://services-sync/policies.js");
 Cu.import("resource://services-sync/util.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
 function login_handling(handler) {
   return function (request, response) {
     if (basic_auth_matches(request, "johndoe", "ilovejane") ||
         basic_auth_matches(request, "janedoe", "ilovejohn")) {
       handler(request, response);
@@ -32,17 +32,17 @@
 add_test(function test_offline() {
   try {
     _("The right bits are set when we're offline.");
     Services.io.offline = true;
     do_check_false(!!Service.login());
     do_check_eq(Service.status.login, LOGIN_FAILED_NETWORK_ERROR);
     Services.io.offline = false;
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     run_next_test();
   }
 });
 
 function setup() {
   Service.serverURL = TEST_SERVER_URL;
   Service.clusterURL = TEST_CLUSTER_URL;
 
@@ -125,17 +125,17 @@
     Service.logout();
     do_check_false(Service.isLoggedIn);
 
     _("Logging out again won't do any harm.");
     Service.logout();
     do_check_false(Service.isLoggedIn);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
 
 add_test(function test_login_on_sync() {
   let server = setup();
   setBasicCredentials("johndoe", "ilovejane", "bar");
 
@@ -233,12 +233,12 @@
 
     Service.identity.__defineGetter__("syncKey", oldGetter);
     Service.identity.__defineSetter__("syncKey", oldSetter);
 
     // N.B., a bunch of methods are stubbed at this point. Be careful putting
     // new tests after this point!
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   }
 });
diff --git a/services/sync/tests/unit/test_service_migratePrefs.js b/services/sync/tests/unit/test_service_migratePrefs.js
--- a/services/sync/tests/unit/test_service_migratePrefs.js
+++ b/services/sync/tests/unit/test_service_migratePrefs.js
@@ -1,28 +1,30 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-common/preferences.js");
 Cu.import("resource://services-sync/util.js");
 
+const prefs = Service.prefs;
+
 function test_migrate_logging() {
   _("Testing log pref migration.");
-  Svc.Prefs.set("log.appender.debugLog", "Warn");
-  Svc.Prefs.set("log.appender.debugLog.enabled", true);
-  do_check_true(Svc.Prefs.get("log.appender.debugLog.enabled"));
-  do_check_eq(Svc.Prefs.get("log.appender.file.level"), "Trace");
-  do_check_eq(Svc.Prefs.get("log.appender.file.logOnSuccess"), false);
+  prefs.set("log.appender.debugLog", "Warn");
+  prefs.set("log.appender.debugLog.enabled", true);
+  do_check_true(prefs.get("log.appender.debugLog.enabled"));
+  do_check_eq(prefs.get("log.appender.file.level"), "Trace");
+  do_check_eq(prefs.get("log.appender.file.logOnSuccess"), false);
 
   Service._migratePrefs();
 
-  do_check_eq("Warn", Svc.Prefs.get("log.appender.file.level"));
-  do_check_true(Svc.Prefs.get("log.appender.file.logOnSuccess"));
-  do_check_eq(Svc.Prefs.get("log.appender.debugLog"), undefined);
-  do_check_eq(Svc.Prefs.get("log.appender.debugLog.enabled"), undefined);
+  do_check_eq("Warn", prefs.get("log.appender.file.level"));
+  do_check_true(prefs.get("log.appender.file.logOnSuccess"));
+  do_check_eq(prefs.get("log.appender.debugLog"), undefined);
+  do_check_eq(prefs.get("log.appender.debugLog.enabled"), undefined);
 };
 
 function run_test() {
   _("Set some prefs on the old branch");
   let globalPref = new Preferences("");
   globalPref.set("extensions.weave.hello", "world");
   globalPref.set("extensions.weave.number", 42);
   globalPref.set("extensions.weave.yes", true);
diff --git a/services/sync/tests/unit/test_service_passwordUTF8.js b/services/sync/tests/unit/test_service_passwordUTF8.js
--- a/services/sync/tests/unit/test_service_passwordUTF8.js
+++ b/services/sync/tests/unit/test_service_passwordUTF8.js
@@ -1,14 +1,14 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-sync/resource.js");
+Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
-Cu.import("resource://services-sync/service.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
 const JAPANESE = "\u34ff\u35ff\u36ff\u37ff";
 const APPLES = "\uf8ff\uf8ff\uf8ff\uf8ff";
 const LOWBYTES = "\xff\xff\xff\xff";
 
 // Poor man's /etc/passwd.  Static since there's no btoa()/atob() in xpcshell.
 let basicauth = {};
@@ -83,11 +83,11 @@
     _("Can't use a password that has the same low bytes as ours.");
     server_password = Utils.encodeUTF8(JAPANESE);
     Service.identity.basicPassword = APPLES;
     do_check_false(Service.verifyLogin());
     do_check_eq(server_password, Utils.encodeUTF8(JAPANESE));
 
   } finally {
     server.stop(do_test_finished);
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   }
 }
diff --git a/services/sync/tests/unit/test_service_persistLogin.js b/services/sync/tests/unit/test_service_persistLogin.js
--- a/services/sync/tests/unit/test_service_persistLogin.js
+++ b/services/sync/tests/unit/test_service_persistLogin.js
@@ -34,12 +34,12 @@
     _("The passphrase has been persisted in the login service.");
     logins = Services.logins.findLogins({}, PWDMGR_HOST, null,
                                         PWDMGR_PASSPHRASE_REALM);
     do_check_eq(logins.length, 1);
     do_check_eq(logins[0].username, "johndoe");
     do_check_eq(logins[0].password, "abbbbbcccccdddddeeeeefffff");
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     Services.logins.removeAllLogins();
   }
 }
diff --git a/services/sync/tests/unit/test_service_startOver.js b/services/sync/tests/unit/test_service_startOver.js
--- a/services/sync/tests/unit/test_service_startOver.js
+++ b/services/sync/tests/unit/test_service_startOver.js
@@ -48,17 +48,17 @@
 
     do_check_eq(Service.status.service, CLIENT_NOT_CONFIGURED);
   });
 
   Service.startOver();
   do_check_true(observerCalled);
 
   // Verify the site was nuked from orbit.
-  do_check_eq(Svc.Prefs.get("username"), undefined);
+  do_check_eq(Service.prefs.get("username"), undefined);
   do_check_eq(Service.identity.basicPassword, null);
   do_check_eq(Service.identity.syncKey, null);
 
   do_check_eq(Service.status.service, CLIENT_NOT_CONFIGURED);
   do_check_false(Service.status.enforceBackoff);
   do_check_eq(Service.status.backoffInterval, 0);
   do_check_eq(Service.status.minimumNextSync, 0);
 
diff --git a/services/sync/tests/unit/test_service_startup.js b/services/sync/tests/unit/test_service_startup.js
--- a/services/sync/tests/unit/test_service_startup.js
+++ b/services/sync/tests/unit/test_service_startup.js
@@ -1,41 +1,43 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 Cu.import("resource://services-common/observers.js");
+Cu.import("resource://services-common/preferences.js");
+Cu.import("resource://services-sync/constants.js");
 Cu.import("resource://services-sync/engines.js");
 Cu.import("resource://services-sync/util.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
-Svc.Prefs.set("registerEngines", "Tab,Bookmarks,Form,History");
+let prefs = new Preferences(PREFS_BRANCH);
+prefs.set("registerEngines", "Tab,Bookmarks,Form,History");
+
 Cu.import("resource://services-sync/service.js");
 
 function run_test() {
   _("When imported, Service.onStartup is called");
   initTestLogging("Trace");
 
   new SyncTestingInfrastructure();
 
   // Test fixtures
   Service.identity.username = "johndoe";
 
-  Cu.import("resource://services-sync/service.js");
-
   _("Service is enabled.");
   do_check_eq(Service.enabled, true);
 
   _("Engines are registered.");
   let engines = Service.engineManager.getAll();
   do_check_true(Utils.deepEquals([engine.name for each (engine in engines)],
                                  ['tabs', 'bookmarks', 'forms', 'history']));
 
   _("Observers are notified of startup");
   do_test_pending();
   do_check_false(Service.status.ready);
   Observers.add("weave:service:ready", function (subject, data) {
     do_check_true(Service.status.ready);
 
     // Clean up.
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     do_test_finished();
   });
 }
diff --git a/services/sync/tests/unit/test_service_sync_401.js b/services/sync/tests/unit/test_service_sync_401.js
--- a/services/sync/tests/unit/test_service_sync_401.js
+++ b/services/sync/tests/unit/test_service_sync_401.js
@@ -36,17 +36,17 @@
 
   const GLOBAL_SCORE = 42;
 
   try {
     _("Set up test fixtures.");
     new SyncTestingInfrastructure("johndoe", "ilovejane", "foo");
     Service.scheduler.globalScore = GLOBAL_SCORE;
     // Avoid daily ping
-    Svc.Prefs.set("lastPing", Math.floor(Date.now() / 1000));
+    Service.prefs.set("lastPing", Math.floor(Date.now() / 1000));
 
     let threw = false;
     Svc.Obs.add("weave:service:sync:error", function (subject, data) {
       threw = true;
     });
 
     _("Initial state: We're successfully logged in.");
     Service.login();
@@ -73,12 +73,12 @@
     _("Our next sync will fail appropriately.");
     try {
       Service.sync();
     } catch (ex) {
     }
     do_check_eq(Service.status.login, LOGIN_FAILED_LOGIN_REJECTED);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(do_test_finished);
   }
 }
diff --git a/services/sync/tests/unit/test_service_sync_locked.js b/services/sync/tests/unit/test_service_sync_locked.js
--- a/services/sync/tests/unit/test_service_sync_locked.js
+++ b/services/sync/tests/unit/test_service_sync_locked.js
@@ -16,17 +16,17 @@
     return old;
   }
 
   Log4Moz.repository.rootLogger.addAppender(new Log4Moz.DumpAppender());
 
   augmentLogger(Service._log);
 
   // Avoid daily ping
-  Svc.Prefs.set("lastPing", Math.floor(Date.now() / 1000));
+  Service.prefs.set("lastPing", Math.floor(Date.now() / 1000));
 
   _("Check that sync will log appropriately if already in 'progress'.");
   Service._locked = true;
   Service.sync();
   Service._locked = false;
 
   do_check_eq(debug[debug.length - 2],
               "Exception: Could not acquire lock. Label: \"service.js: login\". No traceback available");
diff --git a/services/sync/tests/unit/test_service_sync_remoteSetup.js b/services/sync/tests/unit/test_service_sync_remoteSetup.js
--- a/services/sync/tests/unit/test_service_sync_remoteSetup.js
+++ b/services/sync/tests/unit/test_service_sync_remoteSetup.js
@@ -158,12 +158,12 @@
     collections.crypto = keys.modified = 100 + (Date.now()/1000);  // Future modification time.
     keys.encrypt(b);
     keys.upload(Service.resource(Service.cryptoKeysURL));
 
     do_check_false(Service.verifyAndFetchSymmetricKeys());
     do_check_eq(Service.status.login, LOGIN_FAILED_INVALID_PASSPHRASE);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(do_test_finished);
   }
 }
diff --git a/services/sync/tests/unit/test_service_verifyLogin.js b/services/sync/tests/unit/test_service_verifyLogin.js
--- a/services/sync/tests/unit/test_service_verifyLogin.js
+++ b/services/sync/tests/unit/test_service_verifyLogin.js
@@ -102,12 +102,12 @@
     _("Ensure a network error when getting the collection info sets the right Status bits.");
     Service.status.resetSync();
     Service.clusterURL = "http://localhost:12345/";
     do_check_false(Service.verifyLogin());
     do_check_eq(Service.status.service, LOGIN_FAILED);
     do_check_eq(Service.status.login, LOGIN_FAILED_NETWORK_ERROR);
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(do_test_finished);
   }
 }
diff --git a/services/sync/tests/unit/test_service_wipeClient.js b/services/sync/tests/unit/test_service_wipeClient.js
--- a/services/sync/tests/unit/test_service_wipeClient.js
+++ b/services/sync/tests/unit/test_service_wipeClient.js
@@ -89,17 +89,17 @@
   Service.identity.syncKey = key;
   Service.identity.persistCredentials();
 
   // Simulate passwords engine wipe without all the overhead. To do this
   // properly would require extra test infrastructure.
   Services.logins.removeAllLogins();
   Service.wipeClient();
 
-  let id = new IdentityManager();
+  let id = new IdentityManager(Service.prefs);
   do_check_eq(id.account, "testaccount");
   do_check_eq(id.basicPassword, "testpassword");
   do_check_eq(id.syncKey, key);
 
   Service.startOver();
 
   run_next_test();
 });
diff --git a/services/sync/tests/unit/test_service_wipeServer.js b/services/sync/tests/unit/test_service_wipeServer.js
--- a/services/sync/tests/unit/test_service_wipeServer.js
+++ b/services/sync/tests/unit/test_service_wipeServer.js
@@ -1,16 +1,19 @@
-Cu.import("resource://services-sync/util.js");
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
 Cu.import("resource://services-sync/record.js");
 Cu.import("resource://services-sync/resource.js");
+Cu.import("resource://services-sync/service.js");
+Cu.import("resource://services-sync/util.js");
 Cu.import("resource://testing-common/services/sync/fakeservices.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
-Svc.DefaultPrefs.set("registerEngines", "");
-Cu.import("resource://services-sync/service.js");
+Service.engineManager.clear();
 
 function FakeCollection() {
   this.deleted = false;
 }
 FakeCollection.prototype = {
   handler: function() {
     let self = this;
     return function(request, response) {
@@ -68,17 +71,17 @@
     do_check_eq(timestamp, diesel_coll.timestamp);
 
     _("wipeServer stopped deleting after encountering an error with the 'petrol' collection, thus only 'steam' has been deleted.");
     do_check_true(steam_coll.deleted);
     do_check_true(diesel_coll.deleted);
 
   } finally {
     server.stop(run_next_test);
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   }
 });
 
 add_test(function test_wipeServer_list_503() {
   _("Service.wipeServer() deletes collections given as argument.");
 
   let steam_coll = new FakeCollection();
   let diesel_coll = new FakeCollection();
@@ -109,17 +112,17 @@
     do_check_eq(error.status, 503);
 
     _("wipeServer stopped deleting after encountering an error with the 'petrol' collection, thus only 'steam' has been deleted.");
     do_check_true(steam_coll.deleted);
     do_check_false(diesel_coll.deleted);
 
   } finally {
     server.stop(run_next_test);
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
   }
 });
 
 add_test(function test_wipeServer_all_success() {
   _("Service.wipeServer() deletes all the things.");
 
   /**
    * Handle the bulk DELETE request sent by wipeServer.
@@ -140,17 +143,17 @@
 
   _("Try deletion.");
   new SyncTestingInfrastructure("johndoe", "irrelevant", "irrelevant");
   let returnedTimestamp = Service.wipeServer();
   do_check_true(deleted);
   do_check_eq(returnedTimestamp, serverTimestamp);
 
   server.stop(run_next_test);
-  Svc.Prefs.resetBranch("");
+  Service.prefs.resetBranch("");
 });
 
 add_test(function test_wipeServer_all_404() {
   _("Service.wipeServer() accepts a 404.");
 
   /**
    * Handle the bulk DELETE request sent by wipeServer. Returns a 404.
    */
@@ -172,17 +175,17 @@
 
   _("Try deletion.");
   new SyncTestingInfrastructure("johndoe", "irrelevant", "irrelevant");
   let returnedTimestamp = Service.wipeServer();
   do_check_true(deleted);
   do_check_eq(returnedTimestamp, serverTimestamp);
 
   server.stop(run_next_test);
-  Svc.Prefs.resetBranch("");
+  Service.prefs.resetBranch("");
 });
 
 add_test(function test_wipeServer_all_503() {
   _("Service.wipeServer() throws if it encounters a non-200/404 response.");
 
   /**
    * Handle the bulk DELETE request sent by wipeServer. Returns a 503.
    */
@@ -204,26 +207,26 @@
     Service.wipeServer();
     do_throw("Should have thrown!");
   } catch (ex) {
     error = ex;
   }
   do_check_eq(error.status, 503);
 
   server.stop(run_next_test);
-  Svc.Prefs.resetBranch("");
+  Service.prefs.resetBranch("");
 });
 
 add_test(function test_wipeServer_all_connectionRefused() {
   _("Service.wipeServer() throws if it encounters a network problem.");
   setUpTestFixtures();
 
   _("Try deletion.");
   try {
     Service.wipeServer();
     do_throw("Should have thrown!");
   } catch (ex) {
     do_check_eq(ex.result, Cr.NS_ERROR_CONNECTION_REFUSED);
   }
 
   run_next_test();
-  Svc.Prefs.resetBranch("");
+  Service.prefs.resetBranch("");
 });
diff --git a/services/sync/tests/unit/test_status_checkSetup.js b/services/sync/tests/unit/test_status_checkSetup.js
--- a/services/sync/tests/unit/test_status_checkSetup.js
+++ b/services/sync/tests/unit/test_status_checkSetup.js
@@ -33,11 +33,11 @@
 
     _("Let's provide a passphrase");
     Status._authManager.syncKey = "a-bcdef-abcde-acbde-acbde-acbde";
     _("checkSetup()");
     do_check_eq(Status.checkSetup(), STATUS_OK);
     Status.resetSync();
 
   } finally {
-    Svc.Prefs.resetBranch("");
+    Status.prefs.resetBranch("");
   }
 }
diff --git a/services/sync/tests/unit/test_syncengine.js b/services/sync/tests/unit/test_syncengine.js
--- a/services/sync/tests/unit/test_syncengine.js
+++ b/services/sync/tests/unit/test_syncengine.js
@@ -15,67 +15,67 @@
   let syncTesting = new SyncTestingInfrastructure();
   Service.clusterURL = "https://cluster/";
   let engine = makeSteamEngine();
   try {
     do_check_eq(engine.storageURL, "https://cluster/1.1/foo/storage/");
     do_check_eq(engine.engineURL, "https://cluster/1.1/foo/storage/steam");
     do_check_eq(engine.metaURL, "https://cluster/1.1/foo/storage/meta/global");
   } finally {
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function test_syncID() {
   _("SyncEngine.syncID corresponds to preference");
   let syncTesting = new SyncTestingInfrastructure();
   let engine = makeSteamEngine();
   try {
     // Ensure pristine environment
-    do_check_eq(Svc.Prefs.get("steam.syncID"), undefined);
+    do_check_eq(engine.prefs.get("steam.syncID"), undefined);
 
     // Performing the first get on the attribute will generate a new GUID.
     do_check_eq(engine.syncID, "fake-guid-0");
-    do_check_eq(Svc.Prefs.get("steam.syncID"), "fake-guid-0");
+    do_check_eq(engine.prefs.get("steam.syncID"), "fake-guid-0");
 
-    Svc.Prefs.set("steam.syncID", Utils.makeGUID());
-    do_check_eq(Svc.Prefs.get("steam.syncID"), "fake-guid-1");
+    engine.prefs.set("steam.syncID", Utils.makeGUID());
+    do_check_eq(engine.prefs.get("steam.syncID"), "fake-guid-1");
     do_check_eq(engine.syncID, "fake-guid-1");
   } finally {
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function test_lastSync() {
   _("SyncEngine.lastSync and SyncEngine.lastSyncLocal correspond to preferences");
   let syncTesting = new SyncTestingInfrastructure();
   let engine = makeSteamEngine();
   try {
     // Ensure pristine environment
-    do_check_eq(Svc.Prefs.get("steam.lastSync"), undefined);
+    do_check_eq(engine.prefs.get("steam.lastSync"), undefined);
     do_check_eq(engine.lastSync, 0);
-    do_check_eq(Svc.Prefs.get("steam.lastSyncLocal"), undefined);
+    do_check_eq(engine.prefs.get("steam.lastSyncLocal"), undefined);
     do_check_eq(engine.lastSyncLocal, 0);
 
     // Floats are properly stored as floats and synced with the preference
     engine.lastSync = 123.45;
     do_check_eq(engine.lastSync, 123.45);
-    do_check_eq(Svc.Prefs.get("steam.lastSync"), "123.45");
+    do_check_eq(engine.prefs.get("steam.lastSync"), "123.45");
 
     // Integer is properly stored
     engine.lastSyncLocal = 67890;
     do_check_eq(engine.lastSyncLocal, 67890);
-    do_check_eq(Svc.Prefs.get("steam.lastSyncLocal"), "67890");
+    do_check_eq(engine.prefs.get("steam.lastSyncLocal"), "67890");
 
     // resetLastSync() resets the value (and preference) to 0
     engine.resetLastSync();
     do_check_eq(engine.lastSync, 0);
-    do_check_eq(Svc.Prefs.get("steam.lastSync"), "0");
+    do_check_eq(engine.prefs.get("steam.lastSync"), "0");
   } finally {
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function test_toFetch() {
   _("SyncEngine.toFetch corresponds to file on disk");
   let syncTesting = new SyncTestingInfrastructure();
   const filename = "weave/toFetch/steam.json";
   let engine = makeSteamEngine();
@@ -95,17 +95,17 @@
     // Read file from disk
     toFetch = [Utils.makeGUID(), Utils.makeGUID()];
     syncTesting.fakeFilesystem.fakeContents[filename] = JSON.stringify(toFetch);
     engine.loadToFetch();
     do_check_eq(engine.toFetch.length, 2);
     do_check_eq(engine.toFetch[0], toFetch[0]);
     do_check_eq(engine.toFetch[1], toFetch[1]);
   } finally {
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function test_previousFailed() {
   _("SyncEngine.previousFailed corresponds to file on disk");
   let syncTesting = new SyncTestingInfrastructure();
   const filename = "weave/failed/steam.json";
   let engine = makeSteamEngine();
@@ -125,42 +125,42 @@
     // Read file from disk
     previousFailed = [Utils.makeGUID(), Utils.makeGUID()];
     syncTesting.fakeFilesystem.fakeContents[filename] = JSON.stringify(previousFailed);
     engine.loadPreviousFailed();
     do_check_eq(engine.previousFailed.length, 2);
     do_check_eq(engine.previousFailed[0], previousFailed[0]);
     do_check_eq(engine.previousFailed[1], previousFailed[1]);
   } finally {
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function test_resetClient() {
   _("SyncEngine.resetClient resets lastSync and toFetch");
   let syncTesting = new SyncTestingInfrastructure();
   let engine = makeSteamEngine();
   try {
     // Ensure pristine environment
-    do_check_eq(Svc.Prefs.get("steam.lastSync"), undefined);
-    do_check_eq(Svc.Prefs.get("steam.lastSyncLocal"), undefined);
+    do_check_eq(engine.prefs.get("steam.lastSync"), undefined);
+    do_check_eq(engine.prefs.get("steam.lastSyncLocal"), undefined);
     do_check_eq(engine.toFetch.length, 0);
 
     engine.lastSync = 123.45;
     engine.lastSyncLocal = 67890;
     engine.toFetch = [Utils.makeGUID(), Utils.makeGUID(), Utils.makeGUID()];
     engine.previousFailed = [Utils.makeGUID(), Utils.makeGUID(), Utils.makeGUID()];
 
     engine.resetClient();
     do_check_eq(engine.lastSync, 0);
     do_check_eq(engine.lastSyncLocal, 0);
     do_check_eq(engine.toFetch.length, 0);
     do_check_eq(engine.previousFailed.length, 0);
   } finally {
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function test_wipeServer() {
   _("SyncEngine.wipeServer deletes server data and resets the client.");
   let syncTesting = new SyncTestingInfrastructure();
   Service.serverURL = TEST_SERVER_URL;
   Service.clusterURL = TEST_CLUSTER_URL;
@@ -181,17 +181,17 @@
     _("Wipe server data and reset client.");
     engine.wipeServer();
     do_check_eq(steamCollection.payload, undefined);
     do_check_eq(engine.lastSync, 0);
     do_check_eq(engine.toFetch.length, 0);
 
   } finally {
     server.stop(do_test_finished);
-    Svc.Prefs.resetBranch("");
+    engine.prefs.resetBranch("");
   }
 }
 
 function run_test() {
   test_url_attributes();
   test_syncID();
   test_lastSync();
   test_toFetch();
diff --git a/services/sync/tests/unit/test_syncengine_sync.js b/services/sync/tests/unit/test_syncengine_sync.js
--- a/services/sync/tests/unit/test_syncengine_sync.js
+++ b/services/sync/tests/unit/test_syncengine_sync.js
@@ -6,23 +6,25 @@
 Cu.import("resource://services-sync/policies.js");
 Cu.import("resource://services-sync/record.js");
 Cu.import("resource://services-sync/resource.js");
 Cu.import("resource://services-sync/service.js");
 Cu.import("resource://services-sync/util.js");
 Cu.import("resource://testing-common/services/sync/rotaryengine.js");
 Cu.import("resource://testing-common/services/sync/utils.js");
 
+const prefs = Service.prefs;
+
 function makeRotaryEngine() {
   return new RotaryEngine(Service);
 }
 
 function cleanAndGo(server) {
-  Svc.Prefs.resetBranch("");
-  Svc.Prefs.set("log.logger.engine.rotary", "Trace");
+  prefs.resetBranch("");
+  prefs.set("log.logger.engine.rotary", "Trace");
   Service.recordManager.clearCache();
   server.stop(run_next_test);
 }
 
 function configureService(username, password) {
   Service.clusterURL = TEST_CLUSTER_URL;
 
   Service.identity.account = username || "foo";
@@ -49,17 +51,17 @@
   server.createContents(USER, contents);
   server.start();
 
   return [engine, server, USER];
 }
 
 function run_test() {
   generateNewKeys(Service.collectionKeys);
-  Svc.Prefs.set("log.logger.engine.rotary", "Trace");
+  prefs.set("log.logger.engine.rotary", "Trace");
   run_next_test();
 }
 
 /*
  * Tests
  *
  * SyncEngine._sync() is divided into four rather independent steps:
  *
@@ -607,17 +609,17 @@
 
 add_test(function test_processIncoming_mobile_batchSize() {
   _("SyncEngine._processIncoming doesn't fetch everything at once on mobile clients");
 
   let syncTesting = new SyncTestingInfrastructure();
   Service.serverURL = TEST_SERVER_URL;
   Service.clusterURL = TEST_CLUSTER_URL;
   Service.identity.username = "foo";
-  Svc.Prefs.set("client.type", "mobile");
+  prefs.set("client.type", "mobile");
 
   // A collection that logs each GET
   let collection = new ServerCollection();
   collection.get_log = [];
   collection._get = collection.get;
   collection.get = function (options) {
     this.get_log.push(options);
     return this._get(options);
@@ -678,17 +680,17 @@
 
 
 add_test(function test_processIncoming_store_toFetch() {
   _("If processIncoming fails in the middle of a batch on mobile, state is saved in toFetch and lastSync.");
   let syncTesting = new SyncTestingInfrastructure();
   Service.serverURL = TEST_SERVER_URL;
   Service.clusterURL = TEST_CLUSTER_URL;
   Service.identity.username = "foo";
-  Svc.Prefs.set("client.type", "mobile");
+  prefs.set("client.type", "mobile");
 
   // A collection that throws at the fourth get.
   let collection = new ServerCollection();
   collection._get_calls = 0;
   collection._get = collection.get;
   collection.get = function() {
     this._get_calls += 1;
     if (this._get_calls > 3) {
@@ -1016,17 +1018,17 @@
 
 
 add_test(function test_processIncoming_previousFailed() {
   _("Ensure that failed records are retried.");
   let syncTesting = new SyncTestingInfrastructure();
   Service.serverURL = TEST_SERVER_URL;
   Service.clusterURL = TEST_CLUSTER_URL;
   Service.identity.username = "foo";
-  Svc.Prefs.set("client.type", "mobile");
+  prefs.set("client.type", "mobile");
 
   const APPLY_BATCH_SIZE = 4;
   const NUMBER_OF_RECORDS = 14;
 
   // Engine that fails the first 2 records.
   let engine = makeRotaryEngine();
   engine.mobileGUIDFetchBatchSize = engine.applyIncomingBatchSize = APPLY_BATCH_SIZE;
   engine._store._applyIncomingBatch = engine._store.applyIncomingBatch;
@@ -1222,17 +1224,17 @@
     do_check_eq(batchDownload(3), 3);
 
     // Now see with a more realistic limit.
     _("Test batching with sufficient ID batch size.");
     do_check_eq(batchDownload(BOGUS_RECORDS.length), 1);
 
     // If we're on mobile, that limit is used by default.
     _("Test batching with tiny mobile batch size.");
-    Svc.Prefs.set("client.type", "mobile");
+    prefs.set("client.type", "mobile");
     engine.mobileGUIDFetchBatchSize = 2;
     do_check_eq(batchDownload(BOGUS_RECORDS.length), 4);
 
   } finally {
     cleanAndGo(server);
   }
 });
 
diff --git a/services/sync/tests/unit/test_syncscheduler.js b/services/sync/tests/unit/test_syncscheduler.js
--- a/services/sync/tests/unit/test_syncscheduler.js
+++ b/services/sync/tests/unit/test_syncscheduler.js
@@ -91,59 +91,59 @@
   const TIMESTAMP1 = 1275493471649;
 
   _("The 'nextSync' attribute stores a millisecond timestamp rounded down to the nearest second.");
   do_check_eq(scheduler.nextSync, 0);
   scheduler.nextSync = TIMESTAMP1;
   do_check_eq(scheduler.nextSync, Math.floor(TIMESTAMP1 / 1000) * 1000);
 
   _("'syncInterval' defaults to singleDeviceInterval.");
-  do_check_eq(Svc.Prefs.get('syncInterval'), undefined);
+  do_check_eq(scheduler.prefs.get('syncInterval'), undefined);
   do_check_eq(scheduler.syncInterval, scheduler.singleDeviceInterval);
 
   _("'syncInterval' corresponds to a preference setting.");
   scheduler.syncInterval = INTERVAL;
   do_check_eq(scheduler.syncInterval, INTERVAL);
-  do_check_eq(Svc.Prefs.get('syncInterval'), INTERVAL);
+  do_check_eq(scheduler.prefs.get('syncInterval'), INTERVAL);
 
   _("'syncThreshold' corresponds to preference, defaults to SINGLE_USER_THRESHOLD");
-  do_check_eq(Svc.Prefs.get('syncThreshold'), undefined);
+  do_check_eq(scheduler.prefs.get('syncThreshold'), undefined);
   do_check_eq(scheduler.syncThreshold, SINGLE_USER_THRESHOLD);
   scheduler.syncThreshold = THRESHOLD;
   do_check_eq(scheduler.syncThreshold, THRESHOLD);
 
   _("'globalScore' corresponds to preference, defaults to zero.");
-  do_check_eq(Svc.Prefs.get('globalScore'), 0);
+  do_check_eq(scheduler.prefs.get('globalScore'), 0);
   do_check_eq(scheduler.globalScore, 0);
   scheduler.globalScore = SCORE;
   do_check_eq(scheduler.globalScore, SCORE);
-  do_check_eq(Svc.Prefs.get('globalScore'), SCORE);
+  do_check_eq(scheduler.prefs.get('globalScore'), SCORE);
 
   _("Intervals correspond to default preferences.");
   do_check_eq(scheduler.singleDeviceInterval,
-              Svc.Prefs.get("scheduler.singleDeviceInterval") * 1000);
+              scheduler.prefs.get("scheduler.singleDeviceInterval") * 1000);
   do_check_eq(scheduler.idleInterval,
-              Svc.Prefs.get("scheduler.idleInterval") * 1000);
+              scheduler.prefs.get("scheduler.idleInterval") * 1000);
   do_check_eq(scheduler.activeInterval,
-              Svc.Prefs.get("scheduler.activeInterval") * 1000);
+              scheduler.prefs.get("scheduler.activeInterval") * 1000);
   do_check_eq(scheduler.immediateInterval,
-              Svc.Prefs.get("scheduler.immediateInterval") * 1000);
+              scheduler.prefs.get("scheduler.immediateInterval") * 1000);
 
   _("Custom values for prefs will take effect after a restart.");
-  Svc.Prefs.set("scheduler.singleDeviceInterval", 42);
-  Svc.Prefs.set("scheduler.idleInterval", 23);
-  Svc.Prefs.set("scheduler.activeInterval", 18);
-  Svc.Prefs.set("scheduler.immediateInterval", 31415);
+  scheduler.prefs.set("scheduler.singleDeviceInterval", 42);
+  scheduler.prefs.set("scheduler.idleInterval", 23);
+  scheduler.prefs.set("scheduler.activeInterval", 18);
+  scheduler.prefs.set("scheduler.immediateInterval", 31415);
   scheduler.setDefaults();
   do_check_eq(scheduler.idleInterval, 23000);
   do_check_eq(scheduler.singleDeviceInterval, 42000);
   do_check_eq(scheduler.activeInterval, 18000);
   do_check_eq(scheduler.immediateInterval, 31415000);
 
-  Svc.Prefs.resetBranch("");
+  scheduler.prefs.resetBranch("");
   scheduler.setDefaults();
   run_next_test();
 });
 
 add_test(function test_updateClientMode() {
   _("Test updateClientMode adjusts scheduling attributes based on # of clients appropriately");
   do_check_eq(scheduler.syncThreshold, SINGLE_USER_THRESHOLD);
   do_check_eq(scheduler.syncInterval, scheduler.singleDeviceInterval);
@@ -344,17 +344,17 @@
   cleanUpAndGo();
 });
 
 add_test(function test_handleSyncError() {
   let server = sync_httpd_setup();
   setUp();
 
   // Force sync to fail.
-  Svc.Prefs.set("firstSync", "notReady");
+  scheduler.prefs.set("firstSync", "notReady");
 
   _("Ensure expected initial environment.");
   do_check_eq(scheduler._syncErrors, 0);
   do_check_false(Status.enforceBackoff);
   do_check_eq(scheduler.syncInterval, scheduler.singleDeviceInterval);
   do_check_eq(Status.backoffInterval, 0);
 
   // Trigger sync with an error several times & observe
@@ -510,17 +510,17 @@
   scheduler.delayedAutoConnect(0);
 });
 
 add_test(function test_no_autoconnect_during_wizard() {
   let server = sync_httpd_setup();
   setUp();
 
   // Simulate the Sync setup wizard.
-  Svc.Prefs.set("firstSync", "notReady");
+  scheduler.prefs.set("firstSync", "notReady");
 
   // Ensure we don't actually try to sync (or log in for that matter).
   function onLoginStart() {
     do_throw("Should not get here!");
   }
   Svc.Obs.add("weave:service:login:start", onLoginStart);
 
   waitForZeroTimer(function () {
@@ -553,78 +553,78 @@
 });
 
 add_test(function test_autoconnectDelay_pref() {
   Svc.Obs.add("weave:service:sync:finish", function onSyncFinish() {
     Svc.Obs.remove("weave:service:sync:finish", onSyncFinish);
     cleanUpAndGo(server);
   });
 
-  Svc.Prefs.set("autoconnectDelay", 1);
+  scheduler.prefs.set("autoconnectDelay", 1);
 
   let server = sync_httpd_setup();
   setUp();
 
   Svc.Obs.notify("weave:service:ready");
 
   // autoconnectDelay pref is multiplied by 1000.
   do_check_eq(scheduler._autoTimer.delay, 1000);
   do_check_eq(Status.service, STATUS_OK);
 });
 
 add_test(function test_idle_adjustSyncInterval() {
   // Confirm defaults.
   do_check_eq(scheduler.idle, false);
 
   // Single device: nothing changes.
-  scheduler.observe(null, "idle", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "idle", scheduler.prefs.get("scheduler.idleTime"));
   do_check_eq(scheduler.idle, true);
   do_check_eq(scheduler.syncInterval, scheduler.singleDeviceInterval);
 
   // Multiple devices: switch to idle interval.
   scheduler.idle = false;
   clientsEngine._store.create({id: "foo", cleartext: "bar"});
   scheduler.updateClientMode();
-  scheduler.observe(null, "idle", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "idle", scheduler.prefs.get("scheduler.idleTime"));
   do_check_eq(scheduler.idle, true);
   do_check_eq(scheduler.syncInterval, scheduler.idleInterval);
 
   cleanUpAndGo();
 });
 
 add_test(function test_back_triggersSync() {
   // Confirm defaults.
   do_check_false(scheduler.idle);
   do_check_eq(Status.backoffInterval, 0);
 
   // Set up: Define 2 clients and put the system in idle.
   scheduler.numClients = 2;
-  scheduler.observe(null, "idle", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "idle", scheduler.prefs.get("scheduler.idleTime"));
   do_check_true(scheduler.idle);
 
   // We don't actually expect the sync (or the login, for that matter) to
   // succeed. We just want to ensure that it was attempted.
   Svc.Obs.add("weave:service:login:error", function onLoginError() {
     Svc.Obs.remove("weave:service:login:error", onLoginError);
     cleanUpAndGo();
   });
 
   // Send a 'back' event to trigger sync soonish.
-  scheduler.observe(null, "back", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "back", scheduler.prefs.get("scheduler.idleTime"));
 });
 
 add_test(function test_back_triggersSync_observesBackoff() {
   // Confirm defaults.
   do_check_false(scheduler.idle);
 
   // Set up: Set backoff, define 2 clients and put the system in idle.
   const BACKOFF = 7337;
   Status.backoffInterval = scheduler.idleInterval + BACKOFF;
   scheduler.numClients = 2;
-  scheduler.observe(null, "idle", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "idle", scheduler.prefs.get("scheduler.idleTime"));
   do_check_eq(scheduler.idle, true);
 
   function onLoginStart() {
     do_throw("Shouldn't have kicked off a sync!");
   }
   Svc.Obs.add("weave:service:login:start", onLoginStart);
 
   timer = Utils.namedTimer(function () {
@@ -632,38 +632,38 @@
 
     do_check_true(scheduler.nextSync <= Date.now() + Status.backoffInterval);
     do_check_eq(scheduler.syncTimer.delay, Status.backoffInterval);
 
     cleanUpAndGo();
   }, IDLE_OBSERVER_BACK_DELAY * 1.5, {}, "timer");
 
   // Send a 'back' event to try to trigger sync soonish.
-  scheduler.observe(null, "back", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "back", scheduler.prefs.get("scheduler.idleTime"));
 });
 
 add_test(function test_back_debouncing() {
   _("Ensure spurious back-then-idle events, as observed on OS X, don't trigger a sync.");
 
   // Confirm defaults.
   do_check_eq(scheduler.idle, false);
 
   // Set up: Define 2 clients and put the system in idle.
   scheduler.numClients = 2;
-  scheduler.observe(null, "idle", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "idle", scheduler.prefs.get("scheduler.idleTime"));
   do_check_eq(scheduler.idle, true);
 
   function onLoginStart() {
     do_throw("Shouldn't have kicked off a sync!");
   }
   Svc.Obs.add("weave:service:login:start", onLoginStart);
 
   // Create spurious back-then-idle events as observed on OS X:
-  scheduler.observe(null, "back", Svc.Prefs.get("scheduler.idleTime"));
-  scheduler.observe(null, "idle", Svc.Prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "back", scheduler.prefs.get("scheduler.idleTime"));
+  scheduler.observe(null, "idle", scheduler.prefs.get("scheduler.idleTime"));
 
   timer = Utils.namedTimer(function () {
     Svc.Obs.remove("weave:service:login:start", onLoginStart);
     cleanUpAndGo();
   }, IDLE_OBSERVER_BACK_DELAY * 1.5, {}, "timer");
 });
 
 add_test(function test_no_sync_node() {
diff --git a/services/sync/tests/unit/test_syncstoragerequest.js b/services/sync/tests/unit/test_syncstoragerequest.js
--- a/services/sync/tests/unit/test_syncstoragerequest.js
+++ b/services/sync/tests/unit/test_syncstoragerequest.js
@@ -20,58 +20,60 @@
 add_test(function test_user_agent_desktop() {
   let handler = httpd_handler(200, "OK");
   let server = httpd_setup({"/resource": handler});
 
   let expectedUA = Services.appinfo.name + "/" + Services.appinfo.version +
                    " FxSync/" + WEAVE_VERSION + "." +
                    Services.appinfo.appBuildID + ".desktop";
 
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
   request.onComplete = function onComplete(error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 200);
     do_check_eq(handler.request.getHeader("User-Agent"), expectedUA);
     server.stop(run_next_test);
   };
   do_check_eq(request.get(), request);
 });
 
 add_test(function test_user_agent_mobile() {
   let handler = httpd_handler(200, "OK");
   let server = httpd_setup({"/resource": handler});
 
-  Svc.Prefs.set("client.type", "mobile");
+  Service.prefs.set("client.type", "mobile");
   let expectedUA = Services.appinfo.name + "/" + Services.appinfo.version +
                    " FxSync/" + WEAVE_VERSION + "." +
                    Services.appinfo.appBuildID + ".mobile";
 
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
   request.get(function (error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 200);
     do_check_eq(handler.request.getHeader("User-Agent"), expectedUA);
-    Svc.Prefs.resetBranch("");
+    Service.prefs.resetBranch("");
     server.stop(run_next_test);
   });
 });
 
 add_test(function test_auth() {
   let handler = httpd_handler(200, "OK");
   let server = httpd_setup({"/resource": handler});
 
   setBasicCredentials("johndoe", "ilovejane", "XXXXXXXXX");
 
   let request = Service.getStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
   request.get(function (error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 200);
     do_check_true(basic_auth_matches(handler.request, "johndoe", "ilovejane"));
 
-    Svc.Prefs.reset("");
+    Service.prefs.reset("");
 
     server.stop(run_next_test);
   });
 });
 
 /**
  *  The X-Weave-Timestamp header updates SyncStorageRequest.serverTime.
  */
@@ -79,17 +81,18 @@
   const TIMESTAMP = 1274380461;
   function handler(request, response) {
     response.setHeader("X-Weave-Timestamp", "" + TIMESTAMP, false);
     response.setStatusLine(request.httpVersion, 200, "OK");
   }
   let server = httpd_setup({"/resource": handler});
 
   do_check_eq(SyncStorageRequest.serverTime, undefined);
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
   request.get(function (error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 200);
     do_check_eq(SyncStorageRequest.serverTime, TIMESTAMP);
     delete SyncStorageRequest.serverTime;
     server.stop(run_next_test);
   });
 });
@@ -105,17 +108,18 @@
   let server = httpd_setup({"/resource": handler});
 
   let backoffInterval;
   Svc.Obs.add("weave:service:backoff:interval", function onBackoff(subject) {
     Svc.Obs.remove("weave:service:backoff:interval", onBackoff);
     backoffInterval = subject;
   });
 
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
   request.get(function (error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 200);
     do_check_eq(backoffInterval, 600);
     server.stop(run_next_test);
   });
 });
 
@@ -130,17 +134,18 @@
   let server = httpd_setup({"/resource": handler});
 
   let quotaValue;
   Svc.Obs.add("weave:service:quota:remaining", function onQuota(subject) {
     Svc.Obs.remove("weave:service:quota:remaining", onQuota);
     quotaValue = subject;
   });
 
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
   request.get(function (error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 200);
     do_check_eq(quotaValue, 1048576);
     server.stop(run_next_test);
   });
 });
 
@@ -155,17 +160,18 @@
   let server = httpd_setup({"/resource": handler});
 
   let quotaValue;
   function onQuota(subject) {
     quotaValue = subject;
   }
   Svc.Obs.add("weave:service:quota:remaining", onQuota);
 
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
   request.get(function (error) {
     do_check_eq(error, null);
     do_check_eq(this.response.status, 400);
     do_check_eq(quotaValue, undefined);
     Svc.Obs.remove("weave:service:quota:remaining", onQuota);
     server.stop(run_next_test);
   });
 });
@@ -174,17 +180,18 @@
   function handler(request, response) {
     response.setHeader("X-Weave-Timestamp", "" + TIMESTAMP, false);
     response.setHeader("X-Weave-Quota-Remaining", '1048576', false);
     response.setHeader("X-Weave-Backoff", '600', false);
     response.setStatusLine(request.httpVersion, 200, "OK");
   }
   let server = httpd_setup({"/resource": handler});
 
-  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL);
+  let request = new SyncStorageRequest(STORAGE_REQUEST_RESOURCE_URL,
+                                       Service.prefs);
 
   // Aborting a request that hasn't been sent yet is pointless and will throw.
   do_check_throws(function () {
     request.abort();
   });
 
   function throwy() {
     do_throw("Shouldn't have gotten here!");
diff --git a/services/sync/tests/unit/test_tab_store.js b/services/sync/tests/unit/test_tab_store.js
--- a/services/sync/tests/unit/test_tab_store.js
+++ b/services/sync/tests/unit/test_tab_store.js
@@ -30,38 +30,38 @@
 
   _("Create a first record");
   let rec = {id: "id1",
              clientName: "clientName1",
              cleartext: "cleartext1",
              modified: 1000};
   store.applyIncoming(rec);
   do_check_eq(store._remoteClients["id1"], "cleartext1");
-  do_check_eq(Svc.Prefs.get("notifyTabState"), 1);
+  do_check_eq(store.prefs.get("notifyTabState"), 1);
 
   _("Create a second record");
   let rec = {id: "id2",
              clientName: "clientName2",
              cleartext: "cleartext2",
              modified: 2000};
   store.applyIncoming(rec);
   do_check_eq(store._remoteClients["id2"], "cleartext2");
-  do_check_eq(Svc.Prefs.get("notifyTabState"), 0);
+  do_check_eq(store.prefs.get("notifyTabState"), 0);
 
   _("Create a third record");
   let rec = {id: "id3",
              clientName: "clientName3",
              cleartext: "cleartext3",
              modified: 3000};
   store.applyIncoming(rec);
   do_check_eq(store._remoteClients["id3"], "cleartext3");
-  do_check_eq(Svc.Prefs.get("notifyTabState"), 0);
+  do_check_eq(store.prefs.get("notifyTabState"), 0);
 
   // reset the notifyTabState
-  Svc.Prefs.reset("notifyTabState");
+  store.prefs.reset("notifyTabState");
 }
 
 function fakeSessionSvc(url, numtabs) {
   // first delete the getter, or the previously
   // created fake Session
   delete Svc.Session;
   Svc.Session = {
     getBrowserState: function() {
diff --git a/services/sync/tps/extensions/tps/modules/sync.jsm b/services/sync/tps/extensions/tps/modules/sync.jsm
--- a/services/sync/tps/extensions/tps/modules/sync.jsm
+++ b/services/sync/tps/extensions/tps/modules/sync.jsm
@@ -74,26 +74,26 @@
     Weave.Service.identity.syncKey       = prefs.getCharPref('tps.account.passphrase');
     Weave.Svc.Obs.notify("weave:service:setup-complete");
   },
 
   Sync: function TPS__Sync(options) {
     Logger.logInfo('Mozmill starting sync operation: ' + options);
     switch(options) {
       case SYNC_WIPE_REMOTE:
-        Weave.Svc.Prefs.set("firstSync", "wipeRemote");
+        Weave.Service.prefs.set("firstSync", "wipeRemote");
         break;
       case SYNC_WIPE_CLIENT:
-        Weave.Svc.Prefs.set("firstSync", "wipeClient");
+        Weave.Service.prefs.set("firstSync", "wipeClient");
         break;
       case SYNC_RESET_CLIENT:
-        Weave.Svc.Prefs.set("firstSync", "resetClient");
+        Weave.Service.prefs.set("firstSync", "resetClient");
         break;
       default:
-        Weave.Svc.Prefs.reset("firstSync");
+        Weave.Service.prefs.reset("firstSync");
     }
 
     if (Weave.Status.service != Weave.STATUS_OK) {
       return "Sync status not ok: " + Weave.Status.service;
     }
 
     this._syncErrors = 0;
 
diff --git a/services/sync/tps/extensions/tps/modules/tps.jsm b/services/sync/tps/extensions/tps/modules/tps.jsm
--- a/services/sync/tps/extensions/tps/modules/tps.jsm
+++ b/services/sync/tps/extensions/tps/modules/tps.jsm
@@ -574,17 +574,17 @@
           }
         }
       }
 
       Logger.logInfo("Starting phase " + parseInt(phase, 10) + "/" +
                      Object.keys(this._phaselist).length);
 
       Logger.logInfo("setting client.name to " + this.phases["phase" + this._currentPhase]);
-      Weave.Svc.Prefs.set("client.name", this.phases["phase" + this._currentPhase]);
+      Weave.Service.prefs.set("client.name", this.phases["phase" + this._currentPhase]);
 
       // TODO Phases should be defined in a data type that has strong
       // ordering, not by lexical sorting.
       let currentPhase = parseInt(this._currentPhase, 10);
       // Reset everything at the beginning of the test.
       if (currentPhase <= 1) {
         this_phase.unshift([this.ResetData]);
       }
@@ -748,17 +748,17 @@
     if (account["serverURL"]) {
       Weave.Service.serverURL = account["serverURL"];
     }
 
     Logger.logInfo("Setting client credentials.");
     if (account["admin-secret"]) {
       // if admin-secret is specified, we'll dynamically create
       // a new sync account
-      Weave.Svc.Prefs.set("admin-secret", account["admin-secret"]);
+      Weave.Service.prefs.set("admin-secret", account["admin-secret"]);
       let suffix = account["account-suffix"];
       Weave.Service.identity.account = "tps" + suffix + "@mozilla.com";
       Weave.Service.identity.basicPassword = "tps" + suffix + "tps" + suffix;
       Weave.Service.identity.syncKey = Weave.Utils.generatePassphrase();
       Weave.Service.createAccount(Weave.Service.identity.account,
                             Weave.Service.identity.basicPassword,
                             "dummy1", "dummy2");
     } else if (account["username"] && account["password"] &&
@@ -779,28 +779,28 @@
 
     this.waitForTracking();
   },
 
   Sync: function TPS__Sync(options) {
     Logger.logInfo("executing Sync " + (options ? options : ""));
 
     if (options == SYNC_WIPE_REMOTE) {
-      Weave.Svc.Prefs.set("firstSync", "wipeRemote");
+      Weave.Service.prefs.set("firstSync", "wipeRemote");
     }
     else if (options == SYNC_WIPE_CLIENT) {
-      Weave.Svc.Prefs.set("firstSync", "wipeClient");
+      Weave.Service.prefs.set("firstSync", "wipeClient");
     }
     else if (options == SYNC_RESET_CLIENT) {
-      Weave.Svc.Prefs.set("firstSync", "resetClient");
+      Weave.Service.prefs.set("firstSync", "resetClient");
     }
     else if (options) {
       throw new Error("Unhandled options to Sync(): " + options);
     } else {
-      Weave.Svc.Prefs.reset("firstSync");
+      Weave.Service.prefs.reset("firstSync");
     }
 
     this.Login(false);
 
     this._waitingForSync = true;
     this.StartAsyncOperation();
 
     Weave.Service.sync();
